!function(window, document, undefined) {
    "use strict";
    function minErr(module) {
        return function() {
            var message, i, code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, stringify = function(obj) {
                return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? JSON.stringify(obj) : obj;
            };
            for (message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var arg, index = +match.slice(1, -1);
                return index + 2 < templateArgs.length ? (arg = templateArgs[index + 2], "function" == typeof arg ? arg.toString().replace(/ ?\{[\s\S]*$/, "") : "undefined" == typeof arg ? "undefined" : "string" != typeof arg ? toJson(arg) : arg) : match;
            }), message = message + "\nhttp://errors.angularjs.org/1.2.21/" + (module ? module + "/" : "") + code, 
            i = 2; i < arguments.length; i++) message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
            return new Error(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        var length = obj.length;
        return 1 === obj.nodeType && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key); else if (isArray(obj) || isArrayLike(obj)) for (key = 0; key < obj.length; key++) iterator.call(context, obj[key], key); else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context); else for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key);
        return obj;
    }
    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys.sort();
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        for (var digit, index = uid.length; index; ) {
            if (index--, digit = uid[index].charCodeAt(0), 57 == digit) return uid[index] = "A", 
            uid.join("");
            if (90 != digit) return uid[index] = String.fromCharCode(digit + 1), uid.join("");
            uid[index] = "0";
        }
        return uid.unshift("0"), uid.join("");
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst[key] = value;
            });
        }), setHashKey(dst, h), dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null != value && "object" == typeof value;
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function map(obj, iterator, context) {
        var results = [];
        return forEach(obj, function(value, index, list) {
            results.push(iterator.call(context, value, index, list));
        }), results;
    }
    function includes(array, obj) {
        return -1 != indexOf(array, obj);
    }
    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);
        for (var i = 0; i < array.length; i++) if (obj === array[i]) return i;
        return -1;
    }
    function arrayRemove(array, value) {
        var index = indexOf(array, value);
        return index >= 0 && array.splice(index, 1), value;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (destination) {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            if (stackSource = stackSource || [], stackDest = stackDest || [], isObject(source)) {
                var index = indexOf(stackSource, source);
                if (-1 !== index) return stackDest[index];
                stackSource.push(source), stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) result = copy(source[i], null, stackSource, stackDest), 
                isObject(source[i]) && (stackSource.push(source[i]), stackDest.push(result)), destination.push(result);
            } else {
                var h = destination.$$hashKey;
                forEach(destination, function(value, key) {
                    delete destination[key];
                });
                for (var key in source) result = copy(source[key], null, stackSource, stackDest), 
                isObject(source[key]) && (stackSource.push(source[key]), stackDest.push(result)), 
                destination[key] = result;
                setHashKey(destination, h);
            }
        } else destination = source, source && (isArray(source) ? destination = copy(source, [], stackSource, stackDest) : isDate(source) ? destination = new Date(source.getTime()) : isRegExp(source) ? (destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]), 
        destination.lastIndex = source.lastIndex) : isObject(source) && (destination = copy(source, {}, stackSource, stackDest)));
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0; i < src.length; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) !hasOwnProperty.call(src, key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) && o1.getTime() == o2.getTime();
                if (isRegExp(o1) && isRegExp(o2)) return o1.toString() == o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return !1;
                keySet = {};
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return "undefined" == typeof obj ? undefined : JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function toBoolean(value) {
        if ("function" == typeof value) value = !0; else if (value && 0 !== value.length) {
            var v = lowercase("" + value);
            value = !("f" == v || "0" == v || "false" == v || "no" == v || "n" == v || "[]" == v);
        } else value = !1;
        return value;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var TEXT_NODE = 3, elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue && (key_value = keyValue.replace(/\+/g, "%20").split("="), key = tryDecodeURIComponent(key_value[0]), 
            isDefined(key))) {
                var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val;
            }
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function angularInit(element, bootstrap) {
        function append(element) {
            element && elements.push(element);
        }
        var appElement, module, elements = [ element ], names = [ "ng:app", "ng-app", "x-ng-app", "data-ng-app" ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
        forEach(names, function(name) {
            names[name] = !0, append(document.getElementById(name)), name = name.replace(":", "\\:"), 
            element.querySelectorAll && (forEach(element.querySelectorAll("." + name), append), 
            forEach(element.querySelectorAll("." + name + "\\:"), append), forEach(element.querySelectorAll("[" + name + "]"), append));
        }), forEach(elements, function(element) {
            if (!appElement) {
                var className = " " + element.className + " ", match = NG_APP_CLASS_REGEXP.exec(className);
                match ? (appElement = element, module = (match[2] || "").replace(/\s+/g, ",")) : forEach(element.attributes, function(attr) {
                    !appElement && names[attr.name] && (appElement = element, module = attr.value);
                });
            }
        }), appElement && bootstrap(appElement, module ? [ module ] : []);
    }
    function bootstrap(element, modules) {
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag);
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", "$animate", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        void (angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }));
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        jQuery = window.jQuery, jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
        }), jqLitePatchJQueryRemove("remove", !0, !0, !1), jqLitePatchJQueryRemove("empty", !1, !1, !1), 
        jqLitePatchJQueryRemove("html", !1, !1, !0)) : jqLite = JQLite, angular.element = jqLite;
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockElements(nodes) {
        var startNode = nodes[0], endNode = nodes[nodes.length - 1];
        if (startNode === endNode) return jqLite(startNode);
        var element = startNode, elements = [ element ];
        do {
            if (element = element.nextSibling, !element) break;
            elements.push(element);
        } while (element !== endNode);
        return jqLite(elements);
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod) {
                        return function() {
                            return invokeQueue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], runBlocks = [], config = invokeLater("$injector", "invoke"), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            $$minErr: minErr,
            $$csp: csp
        }), angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                ngValue: ngValueDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider
            });
        } ]);
    }
    function jqNextId() {
        return ++jqId;
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
        function removePatch(param) {
            var set, setIndex, setLength, element, childIndex, childLength, children, list = filterElems && param ? [ this.filter(param) ] : [ this ], fireEvent = dispatchThis;
            if (!getterIfNoArguments || null != param) for (;list.length; ) for (set = list.shift(), 
            setIndex = 0, setLength = set.length; setLength > setIndex; setIndex++) for (element = jqLite(set[setIndex]), 
            fireEvent ? element.triggerHandler("$destroy") : fireEvent = !fireEvent, childIndex = 0, 
            childLength = (children = element.children()).length; childLength > childIndex; childIndex++) list.push(jQuery(children[childIndex]));
            return originalJqFn.apply(this, arguments);
        }
        var originalJqFn = jQuery.fn[name];
        originalJqFn = originalJqFn.$original || originalJqFn, removePatch.$original = originalJqFn, 
        jQuery.fn[name] = removePatch;
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, j, jj, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            tmp.removeChild(tmp.firstChild), i = wrap[0]; i--; ) tmp = tmp.lastChild;
            for (j = 0, jj = tmp.childNodes.length; jj > j; ++j) nodes.push(tmp.childNodes[j]);
            tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", nodes;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : jqLiteBuildFragment(html, context);
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        if (isString(element) && (element = trim(element)), !(this instanceof JQLite)) {
            if (isString(element) && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        if (isString(element)) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
            var fragment = jqLite(document.createDocumentFragment());
            fragment.append(this);
        } else jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element) {
        jqLiteRemoveData(element);
        for (var i = 0, children = element.childNodes || []; i < children.length; i++) jqLiteDealoc(children[i]);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
        handle && (isUndefined(type) ? forEach(events, function(eventHandler, type) {
            removeEventListenerFn(element, type, eventHandler), delete events[type];
        }) : forEach(type.split(" "), function(type) {
            isUndefined(fn) ? (removeEventListenerFn(element, type, events[type]), delete events[type]) : arrayRemove(events[type] || [], fn);
        }));
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete jqCache[expandoId].data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, key, value) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId || -1];
        return isDefined(value) ? (expandoStore || (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {}), void (expandoStore[key] = value)) : expandoStore && expandoStore[key];
    }
    function jqLiteData(element, key, value) {
        var data = jqLiteExpandoStore(element, "data"), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
        if (data || isSimpleGetter || jqLiteExpandoStore(element, "data", data = {}), isSetter) data[key] = value; else {
            if (!keyDefined) return data;
            if (isSimpleGetter) return data && data[key];
            extend(data, key);
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            elements = elements.nodeName || !isDefined(elements.length) || isWindow(elements) ? [ elements ] : elements;
            for (var i = 0; i < elements.length; i++) root.push(elements[i]);
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        9 == element.nodeType && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++) if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            element = element.parentNode || 11 === element.nodeType && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
        for (;element.firstChild; ) element.removeChild(element.firstChild);
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            if (event.preventDefault || (event.preventDefault = function() {
                event.returnValue = !1;
            }), event.stopPropagation || (event.stopPropagation = function() {
                event.cancelBubble = !0;
            }), event.target || (event.target = event.srcElement || document), isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault;
                event.preventDefault = function() {
                    event.defaultPrevented = !0, prevent.call(event);
                }, event.defaultPrevented = !1;
            }
            event.isDefaultPrevented = function() {
                return event.defaultPrevented || event.returnValue === !1;
            };
            var eventHandlersCopy = shallowCopy(events[type || event.type] || []);
            forEach(eventHandlersCopy, function(fn) {
                fn.call(element, event);
            }), 8 >= msie ? (event.preventDefault = null, event.stopPropagation = null, event.isDefaultPrevented = null) : (delete event.preventDefault, 
            delete event.stopPropagation, delete event.isDefaultPrevented);
        };
        return eventHandler.elem = element, eventHandler;
    }
    function hashKey(obj, nextUidFn) {
        var key, objType = typeof obj;
        return "function" == objType || "object" == objType && null !== obj ? "function" == typeof (key = obj.$$hashKey) ? key = obj.$$hashKey() : key === undefined && (key = obj.$$hashKey = (nextUidFn || nextUid)()) : key = obj, 
        objType + ":" + key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    function annotate(fn) {
        var $inject, fnText, argDecl, last;
        return "function" == typeof fn ? ($inject = fn.$inject) || ($inject = [], fn.length && (fnText = fn.toString().replace(STRIP_COMMENTS, ""), 
        argDecl = fnText.match(FN_ARGS), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
            arg.replace(FN_ARG, function(all, underscore, name) {
                $inject.push(name);
            });
        })), fn.$inject = $inject) : isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), 
        $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0), $inject;
    }
    function createInjector(modulesToLoad) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function factory(name, factoryFn) {
            return provider(name, {
                $get: factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val));
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var moduleFn, invokeQueue, i, ii, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        if (isString(module)) for (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; ii > i; i++) {
                            var invokeArgs = invokeQueue[i], provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        } else isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName);
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function invoke(fn, self, locals) {
                var length, i, key, args = [], $inject = annotate(fn);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
                }
                return isArray(fn) && (fn = fn[length]), fn.apply(self, args);
            }
            function instantiate(Type, locals) {
                var instance, returnedValue, Constructor = function() {};
                return Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype, 
                instance = new Constructor(), returnedValue = invoke(Type, instance, locals), isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function() {
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
        });
        return forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return forEach(list, function(element) {
                    result || "a" !== lowercase(element.nodeName) || (result = element);
                }), result;
            }
            function scroll() {
                var elm, hash = $location.hash();
                hash ? (elm = document.getElementById(hash)) ? elm.scrollIntoView() : (elm = getFirstAnchor(document.getElementsByName(hash))) ? elm.scrollIntoView() : "top" === hash && $window.scrollTo(0, 0) : $window.scrollTo(0, 0);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function() {
                $rootScope.$evalAsync(scroll);
            }), scroll;
        } ];
    }
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, !1);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function startPoller(interval, setTimeout) {
            !function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                }), pollTimeout = setTimeout(check, interval);
            }();
        }
        function fireUrlChange() {
            newLocation = null, lastBrowserUrl != self.url() && (lastBrowserUrl = self.url(), 
            forEach(urlChangeListeners, function(listener) {
                listener(self.url());
            }));
        }
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            }), 0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var pollTimeout, pollFns = [];
        self.addPollFn = function(fn) {
            return isUndefined(pollTimeout) && startPoller(100, setTimeout), pollFns.push(fn), 
            fn;
        };
        var lastBrowserUrl = location.href, baseElement = document.find("base"), newLocation = null;
        self.url = function(url, replace) {
            if (location !== window.location && (location = window.location), history !== window.history && (history = window.history), 
            url) {
                if (lastBrowserUrl == url) return;
                return lastBrowserUrl = url, $sniffer.history ? replace ? history.replaceState(null, "", url) : (history.pushState(null, "", url), 
                baseElement.attr("href", baseElement.attr("href"))) : (newLocation = url, replace ? location.replace(url) : location.href = url), 
                self;
            }
            return newLocation || location.href.replace(/%27/g, "'");
        };
        var urlChangeListeners = [], urlChangeInit = !1;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", fireUrlChange), 
            $sniffer.hashchange ? jqLite(window).on("hashchange", fireUrlChange) : self.addPollFn(fireUrlChange), 
            urlChangeInit = !0), urlChangeListeners.push(callback), callback;
        }, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {}, lastCookieString = "", cookiePath = self.baseHref();
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (!name) {
                if (rawDocument.cookie !== lastCookieString) for (lastCookieString = rawDocument.cookie, 
                cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
                index = cookie.indexOf("="), index > 0 && (name = unescape(cookie.substring(0, index)), 
                lastCookies[name] === undefined && (lastCookies[name] = unescape(cookie.substring(index + 1))));
                return lastCookies;
            }
            value === undefined ? rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1, 
            cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"));
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (!isUndefined(value)) return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                        value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        delete data[key], size--;
                    },
                    removeAll: function() {
                        data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w_\-]+)(?:\:([^;]+))?;?)/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertArg(directiveFactory, "directiveFactory"), 
            hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = directive.require || directive.controller && directive.name, 
                        directive.restrict = directive.restrict || "A", directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function(node, index) {
                    3 == node.nodeType && node.nodeValue.match(/\S+/) && ($compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0]);
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                return safeAddClass($compileNodes, "ng-scope"), function(scope, cloneConnectFn, transcludeControllers, parentBoundTranscludeFn) {
                    assertArg(scope, "scope");
                    var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
                    forEach(transcludeControllers, function(instance, name) {
                        $linkNode.data("$" + name + "Controller", instance);
                    });
                    for (var i = 0, ii = $linkNode.length; ii > i; i++) {
                        var node = $linkNode[i], nodeType = node.nodeType;
                        (1 === nodeType || 9 === nodeType) && $linkNode.eq(i).data("$scope", scope);
                    }
                    return cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    $linkNode;
                };
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, n, childBoundTranscludeFn, nodeListLength = nodeList.length, stableNodeList = new Array(nodeListLength);
                    for (i = 0; nodeListLength > i; i++) stableNodeList[i] = nodeList[i];
                    for (i = 0, n = 0, ii = linkFns.length; ii > i; n++) node = stableNodeList[n], nodeLinkFn = linkFns[i++], 
                    childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    jqLite.data(node, "$scope", childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && safeAddClass(attrs.$$element, "ng-scope"), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                linkFns.push(nodeLinkFn, childLinkFn), linkFnFound = linkFnFound || nodeLinkFn || childLinkFn, 
                previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers) {
                    var scopeCreated = !1;
                    transcludedScope || (transcludedScope = scope.$new(), transcludedScope.$$transcluded = !0, 
                    scopeCreated = !0);
                    var clone = transcludeFn(transcludedScope, cloneFn, controllers, previousBoundTranscludeFn);
                    return scopeCreated && clone.on("$destroy", function() {
                        transcludedScope.$destroy();
                    }), clone;
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case 1:
                    addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        if (attr = nAttrs[j], !msie || msie >= 8 || attr.specified) {
                            name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), 
                            (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = snake_case(ngAttrName.substr(6), "-"));
                            var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                            ngAttrName === directiveNName + "Start" && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", 
                            name = name.substr(0, name.length - 6)), nName = directiveNormalize(name.toLowerCase()), 
                            attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                            getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName), 
                            addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                        }
                    }
                    if (className = node.className, isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case 3:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case 8:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), 
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
                    } catch (e) {}
                }
                return directives.sort(byPriority), directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        1 == node.nodeType && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), 
                        nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = !1;
                    if (isString(require)) {
                        for (;"^" == (value = require.charAt(0)) || "?" == value; ) require = require.substr(1), 
                        "^" == value && (retrievalMethod = "inheritedData"), optional = optional || "?" == value;
                        if (value = null, elementControllers && "data" === retrievalMethod && (value = elementControllers[require]), 
                        value = value || $element[retrievalMethod]("$" + require + "Controller"), !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        return value;
                    }
                    return isArray(require) && (value = [], forEach(require, function(require) {
                        value.push(getControllers(directiveName, require, $element, elementControllers));
                    })), value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn) {
                        var transcludeControllers;
                        return arguments.length < 2 && (cloneAttachFn = scope, scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
                    }
                    var attrs, $element, i, ii, linkFn, controller, isolateScope, transcludeFn, elementControllers = {};
                    if (attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr)), 
                    $element = attrs.$$element, newIsolateScopeDirective) {
                        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
                        isolateScope = scope.$new(!0), !templateDirective || templateDirective !== newIsolateScopeDirective && templateDirective !== newIsolateScopeDirective.$$originalDirective ? $element.data("$isolateScopeNoTemplate", isolateScope) : $element.data("$isolateScope", isolateScope), 
                        safeAddClass($element, "ng-isolate-scope"), forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, optional = "?" == match[2], mode = match[1];
                            switch (isolateScope.$$isolateBindings[scopeName] = mode + attrName, mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateScope[scopeName] = value;
                                }), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (isolateScope[scopeName] = $interpolate(attrs[attrName])(scope));
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) return;
                                parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function(a, b) {
                                    return a === b;
                                }, parentSet = parentGet.assign || function() {
                                    throw lastValue = isolateScope[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                }, lastValue = isolateScope[scopeName] = parentGet(scope), isolateScope.$watch(function() {
                                    var parentValue = parentGet(scope);
                                    return compare(parentValue, isolateScope[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateScope[scopeName]) : isolateScope[scopeName] = parentValue), 
                                    lastValue = parentValue;
                                }, null, parentGet.literal);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]), isolateScope[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;

                              default:
                                throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition);
                            }
                        });
                    }
                    for (transcludeFn = boundTranscludeFn && controllersBoundTransclude, controllerDirectives && forEach(controllerDirectives, function(directive) {
                        var controllerInstance, locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        };
                        controller = directive.controller, "@" == controller && (controller = attrs[directive.name]), 
                        controllerInstance = $controller(controller, locals), elementControllers[directive.name] = controllerInstance, 
                        hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance), 
                        directive.controllerAs && (locals.$scope[directive.controllerAs] = controllerInstance);
                    }), i = 0, ii = preLinkFns.length; ii > i; i++) try {
                        linkFn = preLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($element));
                    }
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) try {
                        linkFn = postLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($element));
                    }
                }
                previousCompileContext = previousCompileContext || {};
                for (var newScopeDirective, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, 
                    terminalPriority > directive.priority) break;
                    if ((directiveValue = directive.scope) && (newScopeDirective = newScopeDirective || directive, 
                    directive.templateUrl || (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode), 
                    isObject(directiveValue) && (newIsolateScopeDirective = directive))), directiveName = directive.name, 
                    !directive.templateUrl && directive.controller && (directiveValue = directive.controller, 
                    controllerDirectives = controllerDirectives || {}, assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), 
                    childTranscludeFn = compile($template, transcludeFn))), directive.template) if (hasTemplate = !0, 
                    assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, 
                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : jqLite(trim(directiveValue)), 
                        compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: !0
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                    directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), tDirectives.push(directive), match = directive);
                } catch (e) {
                    $exceptionHandler(e);
                }
                return match;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), 
                    dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, 
                    dstAttr[key] = srcAttr[key]);
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl;
                return $compileNode.empty(), $http.get($sce.getTrustedResourceUrl(templateUrl), {
                    cache: $templateCache
                }).success(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : jqLite(trim(content)), compileNode = $template[0], 
                        1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node == compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                }).error(function(response, code, headers, config) {
                    throw $compileMinErr("tpload", "Failed to load template: {0}", config.url);
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    linkQueue ? (linkQueue.push(scope), linkQueue.push(node), linkQueue.push(rootElement), 
                    linkQueue.push(childBoundTranscludeFn)) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var parent = templateNode.parent(), hasCompileParent = parent.length;
                        return hasCompileParent && safeAddClass(templateNode.parent(), "ng-binding"), function(scope, node) {
                            var parent = node.parent(), bindings = parent.data("$binding") || [];
                            bindings.push(interpolateFn), parent.data("$binding", bindings), hasCompileParent || safeAddClass(parent, "ng-binding"), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                return "xlinkHref" == attrNormalizedName || "FORM" == tag && "action" == attrNormalizedName || "IMG" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0;
            }
            function addAttrInterpolateDirective(node, directives, value, name) {
                var interpolateFn = $interpolate(value, !0);
                if (interpolateFn) {
                    if ("multiple" === name && "SELECT" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = {});
                                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                    interpolateFn = $interpolate(attr[name], !0, getTrustedContext(node, name)), interpolateFn && (attr[name] = interpolateFn(scope), 
                                    ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] == firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1;
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove), newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
                for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            var Attributes = function(element, attr) {
                this.$$element = element, this.$attr = attr || {};
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses), toRemove = tokenDifference(oldClasses, newClasses);
                    0 === toAdd.length ? $animate.removeClass(this.$$element, toRemove) : 0 === toRemove.length ? $animate.addClass(this.$$element, toAdd) : $animate.setClass(this.$$element, toAdd, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, booleanKey = getBooleanAttrName(this.$$element[0], key);
                    booleanKey && (this.$$element.prop(key, value), attrName = booleanKey), this[key] = value, 
                    attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), 
                    nodeName = nodeName_(this.$$element), ("A" === nodeName && "href" === key || "IMG" === nodeName && "src" === key) && (this[key] = value = $$sanitizeUri(value, "src" === key)), 
                    writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[key], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        listeners.$$inter || fn(attrs[key]);
                    }), fn;
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile;
        } ];
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function $ControllerProvider() {
        var controllers = {}, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals) {
                var instance, match, constructor, identifier;
                if (isString(expression) && (match = expression.match(CNTRL_REG), constructor = match[1], 
                identifier = match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || getter($window, constructor, !0), 
                assertArgFn(expression, constructor, !0)), instance = $injector.instantiate(expression, locals), 
                identifier) {
                    if (!locals || "object" != typeof locals.$scope) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
                    locals.$scope[identifier] = instance;
                }
                return instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function() {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function parseHeaders(headers) {
        var key, val, i, parsed = {};
        return headers ? (forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), key = lowercase(trim(line.substr(0, i))), val = trim(line.substr(i + 1)), 
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }), parsed) : parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            return headersObj || (headersObj = parseHeaders(headers)), name ? headersObj[lowercase(name)] || null : headersObj;
        };
    }
    function transformData(data, headers, fns) {
        return isFunction(fns) ? fns(data, headers) : (forEach(fns, function(fn) {
            data = fn(data, headers);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/, CONTENT_TYPE_APPLICATION_JSON = {
            "Content-Type": "application/json;charset=utf-8"
        }, defaults = this.defaults = {
            transformResponse: [ function(data) {
                return isString(data) && (data = data.replace(PROTECTION_PREFIX, ""), JSON_START.test(data) && JSON_END.test(data) && (data = fromJson(data))), 
                data;
            } ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        }, interceptorFactories = this.interceptors = [], responseInterceptorFactories = this.responseInterceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            function $http(requestConfig) {
                function transformResponse(response) {
                    var resp = extend({}, response, {
                        data: transformData(response.data, response.headers, config.transformResponse)
                    });
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function mergeHeaders(config) {
                    function execHeaders(headers) {
                        var headerContent;
                        forEach(headers, function(headerFn, header) {
                            isFunction(headerFn) && (headerContent = headerFn(), null != headerContent ? headers[header] = headerContent : delete headers[header]);
                        });
                    }
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return execHeaders(reqHeaders), reqHeaders;
                }
                var config = {
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, headers = mergeHeaders(requestConfig);
                extend(config, requestConfig), config.headers = headers, config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData, headers).then(transformResponse, transformResponse);
                }, chain = [ serverRequest, undefined ], promise = $q.when(config);
                for (forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError);
                }); chain.length; ) {
                    var thenFn = chain.shift(), rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                return promise.success = function(fn) {
                    return promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise.error = function(fn) {
                    return promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise;
            }
            function createShortMethods() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData, reqHeaders) {
                function done(status, response, headersString, statusText) {
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    resolvePromise(response, status, headersString, statusText), $rootScope.$$phase || $rootScope.$apply();
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function removePendingReq() {
                    var idx = indexOf($http.pendingRequests, config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, url = buildUrl(config.url, config.params);
                if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                (config.cache || defaults.cache) && config.cache !== !1 && "GET" == config.method && (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache) if (cachedResp = cache.get(url), isDefined(cachedResp)) {
                    if (isPromiseLike(cachedResp)) return cachedResp.then(removePendingReq, removePendingReq), 
                    cachedResp;
                    isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK");
                } else cache.put(url, promise);
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) || (value = [ value ]), 
                    forEach(value, function(v) {
                        isObject(v) && (isDate(v) ? v = v.toISOString() : isObject(v) && (v = toJson(v))), 
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    }));
                }), parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")), 
                url;
            }
            var defaultCache = $cacheFactory("$http"), reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), forEach(responseInterceptorFactories, function(interceptorFactory, index) {
                var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);
                reversedInterceptors.splice(index, 0, {
                    response: function(response) {
                        return responseFn($q.when(response));
                    },
                    responseError: function(response) {
                        return responseFn($q.reject(response));
                    }
                });
            }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put"), $http.defaults = defaults, $http;
        } ];
    }
    function createXhr(method) {
        if (8 >= msie && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) return new window.ActiveXObject("Microsoft.XMLHTTP");
        if (window.XMLHttpRequest) return new window.XMLHttpRequest();
        throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.");
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), 
            8 >= msie && (script.onreadystatechange = function() {
                isString(script.readyState) && /loaded|complete/.test(script.readyState) && (script.onreadystatechange = null, 
                callback({
                    type: "load"
                }));
            }), rawDocument.body.appendChild(script), callback;
        }
        var ABORTED = -1;
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                status = ABORTED, jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), 
                status = 1223 === status ? 204 : status, statusText = statusText || "", callback(status, response, headersString, statusText), 
                $browser.$$completeOutstandingRequest(noop);
            }
            var status;
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data, callbacks[callbackId].called = !0;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr(method);
                if (xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onreadystatechange = function() {
                    if (xhr && 4 == xhr.readyState) {
                        var responseHeaders = null, response = null, statusText = "";
                        status !== ABORTED && (responseHeaders = xhr.getAllResponseHeaders(), response = "response" in xhr ? xhr.response : xhr.responseText), 
                        status === ABORTED && 10 > msie || (statusText = xhr.statusText), completeRequest(callback, status || xhr.status, response, responseHeaders, statusText);
                    }
                }, withCredentials && (xhr.withCredentials = !0), responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(post || null);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function $interpolate(text, mustHaveExpression, trustedContext) {
                for (var startIndex, endIndex, fn, exp, index = 0, parts = [], length = text.length, hasInterpolation = !1, concat = []; length > index; ) -1 != (startIndex = text.indexOf(startSymbol, index)) && -1 != (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) ? (index != startIndex && parts.push(text.substring(index, startIndex)), 
                parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex))), 
                fn.exp = exp, index = endIndex + endSymbolLength, hasInterpolation = !0) : (index != length && parts.push(text.substring(index)), 
                index = length);
                if ((length = parts.length) || (parts.push(""), length = 1), trustedContext && parts.length > 1) throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                return !mustHaveExpression || hasInterpolation ? (concat.length = length, fn = function(context) {
                    try {
                        for (var part, i = 0, ii = length; ii > i; i++) {
                            if ("function" == typeof (part = parts[i])) if (part = part(context), part = trustedContext ? $sce.getTrusted(trustedContext, part) : $sce.valueOf(part), 
                            null == part) part = ""; else switch (typeof part) {
                              case "string":
                                break;

                              case "number":
                                part = "" + part;
                                break;

                              default:
                                part = toJson(part);
                            }
                            concat[i] = part;
                        }
                        return concat.join("");
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }, fn.exp = text, fn.parts = parts, fn) : void 0;
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", function($rootScope, $window, $q) {
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, deferred = $q.defer(), promise = deferred.promise, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply;
                return count = isDefined(count) ? count : 0, promise.then(null, null, fn), promise.$$intervalId = setInterval(function() {
                    deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), 
                    clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), 
                $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], 
                !0) : !1;
            }, interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function(num) {
                    return 1 === num ? "one" : "other";
                }
            };
        };
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
        var parsedUrl = urlResolve(absoluteUrl, appBase);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj, appBase) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl, appBase);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index);
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this, appBase), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        }, this.$$rewrite = function(url) {
            var appUrl, prevAppUrl;
            return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, 
            (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? appBaseNoFile + appUrl : appBaseNoFile == url + "/" ? appBaseNoFile : void 0;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url), withoutHashUrl = "#" == withoutBaseUrl.charAt(0) ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
            if (!isString(withoutHashUrl)) throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
            parseAppUrl(withoutHashUrl, this, appBase), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), 
            this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        }, this.$$rewrite = function(url) {
            return stripHash(appBase) == stripHash(url) ? url : void 0;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$rewrite = function(url) {
            var appUrl;
            return appBase == stripHash(url) ? url : (appUrl = beginsWith(appBaseNoFile, url)) ? appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" ? appBaseNoFile : void 0;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = !1;
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isDefined(mode) ? (html5Mode = mode, this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", function($rootScope, $browser, $sniffer, $rootElement) {
            function afterLocationChange(oldUrl) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            html5Mode ? (appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url) : (appBase = stripHash(initialUrl), 
            LocationMode = LocationHashbangUrl), $location = new LocationMode(appBase, "#" + hashPrefix), 
            $location.$$parse($location.$$rewrite(initialUrl)), $rootElement.on("click", function(event) {
                if (!event.ctrlKey && !event.metaKey && 2 != event.which) {
                    for (var elm = jqLite(event.target); "a" !== lowercase(elm[0].nodeName); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    var absHref = elm.prop("href");
                    if (isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                    LocationMode === LocationHashbangInHtml5Url) {
                        var href = elm.attr("href") || elm.attr("xlink:href");
                        if (href.indexOf("://") < 0) {
                            var prefix = "#" + hashPrefix;
                            if ("/" == href[0]) absHref = appBase + prefix + href; else if ("#" == href[0]) absHref = appBase + prefix + ($location.path() || "/") + href; else {
                                for (var stack = $location.path().split("/"), parts = href.split("/"), i = 0; i < parts.length; i++) "." != parts[i] && (".." == parts[i] ? stack.pop() : parts[i].length && stack.push(parts[i]));
                                absHref = appBase + prefix + stack.join("/");
                            }
                        }
                    }
                    var rewrittenUrl = $location.$$rewrite(absHref);
                    absHref && !elm.attr("target") && rewrittenUrl && !event.isDefaultPrevented() && (event.preventDefault(), 
                    rewrittenUrl != $browser.url() && ($location.$$parse(rewrittenUrl), $rootScope.$apply(), 
                    window.angular["ff-684208-preventDefault"] = !0));
                }
            }), $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0), $browser.onUrlChange(function(newUrl) {
                $location.absUrl() != newUrl && ($rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    $location.$$parse(newUrl), $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented ? ($location.$$parse(oldUrl), 
                    $browser.url(oldUrl)) : afterLocationChange(oldUrl);
                }), $rootScope.$$phase || $rootScope.$digest());
            });
            var changeCounter = 0;
            return $rootScope.$watch(function() {
                var oldUrl = $browser.url(), currentReplace = $location.$$replace;
                return changeCounter && oldUrl == $location.absUrl() || (changeCounter++, $rootScope.$evalAsync(function() {
                    $rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented ? $location.$$parse(oldUrl) : ($browser.url($location.absUrl(), currentReplace), 
                    afterLocationChange(oldUrl));
                })), $location.$$replace = !1, changeCounter;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name) throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.document && obj.location && obj.alert && obj.setInterval) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object) throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
        return obj;
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || BIND && obj === BIND) throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
    }
    function setter(obj, path, setValue, fullExp, options) {
        options = options || {};
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = obj[key];
            propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = propertyObj, obj.then && options.unwrapPromises && (promiseWarning(fullExp), 
            "$$v" in obj || !function(promise) {
                promise.then(function(val) {
                    promise.$$v = val;
                });
            }(obj), obj.$$v === undefined && (obj.$$v = {}), obj = obj.$$v);
        }
        return key = ensureSafeMemberName(element.shift(), fullExp), ensureSafeObject(obj, fullExp), 
        ensureSafeObject(obj[key], fullExp), obj[key] = setValue, setValue;
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
        return ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp), 
        ensureSafeMemberName(key2, fullExp), ensureSafeMemberName(key3, fullExp), ensureSafeMemberName(key4, fullExp), 
        options.unwrapPromises ? function(scope, locals) {
            var promise, pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = pathVal[key0], pathVal && pathVal.then && (promiseWarning(fullExp), 
            "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key1 ? null == pathVal ? undefined : (pathVal = pathVal[key1], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key2 ? null == pathVal ? undefined : (pathVal = pathVal[key2], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key3 ? null == pathVal ? undefined : (pathVal = pathVal[key3], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key4 ? null == pathVal ? undefined : (pathVal = pathVal[key4], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), pathVal) : pathVal) : pathVal) : pathVal) : pathVal);
        } : function(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = pathVal[key0], key1 ? null == pathVal ? undefined : (pathVal = pathVal[key1], 
            key2 ? null == pathVal ? undefined : (pathVal = pathVal[key2], key3 ? null == pathVal ? undefined : (pathVal = pathVal[key3], 
            key4 ? null == pathVal ? undefined : pathVal = pathVal[key4] : pathVal) : pathVal) : pathVal) : pathVal);
        };
    }
    function getterFn(path, options, fullExp) {
        if (getterFnCache.hasOwnProperty(path)) return getterFnCache[path];
        var fn, pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp) fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options) : function(scope, locals) {
            var val, i = 0;
            do val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals), 
            locals = undefined, scope = val; while (pathKeysLength > i);
            return val;
        }; else {
            var code = "var p;\n";
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp), code += "if(s == null) return undefined;\ns=" + (index ? "s" : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"];\n' + (options.unwrapPromises ? 'if (s && s.then) {\n pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=v;});\n}\n s=s.$$v\n}\n' : "");
            }), code += "return s;";
            var evaledFnGetter = new Function("s", "k", "pw", code);
            evaledFnGetter.toString = valueFn(code), fn = options.unwrapPromises ? function(scope, locals) {
                return evaledFnGetter(scope, locals, promiseWarning);
            } : evaledFnGetter;
        }
        return "hasOwnProperty" !== path && (getterFnCache[path] = fn), fn;
    }
    function $ParseProvider() {
        var cache = {}, $parseOptions = {
            csp: !1,
            unwrapPromises: !1,
            logPromiseWarnings: !0
        };
        this.unwrapPromises = function(value) {
            return isDefined(value) ? ($parseOptions.unwrapPromises = !!value, this) : $parseOptions.unwrapPromises;
        }, this.logPromiseWarnings = function(value) {
            return isDefined(value) ? ($parseOptions.logPromiseWarnings = value, this) : $parseOptions.logPromiseWarnings;
        }, this.$get = [ "$filter", "$sniffer", "$log", function($filter, $sniffer, $log) {
            return $parseOptions.csp = $sniffer.csp, promiseWarning = function(fullExp) {
                $parseOptions.logPromiseWarnings && !promiseWarningCache.hasOwnProperty(fullExp) && (promiseWarningCache[fullExp] = !0, 
                $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. Automatic unwrapping of promises in Angular expressions is deprecated."));
            }, function(exp) {
                var parsedExpression;
                switch (typeof exp) {
                  case "string":
                    if (cache.hasOwnProperty(exp)) return cache[exp];
                    var lexer = new Lexer($parseOptions), parser = new Parser(lexer, $filter, $parseOptions);
                    return parsedExpression = parser.parse(exp), "hasOwnProperty" !== exp && (cache[exp] = parsedExpression), 
                    parsedExpression;

                  case "function":
                    return exp;

                  default:
                    return noop;
                }
            };
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        function defaultCallback(value) {
            return value;
        }
        function defaultErrback(reason) {
            return reject(reason);
        }
        function all(promises) {
            var deferred = defer(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, ref(promise).then(function(value) {
                    results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results));
                }, function(reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason);
                });
            }), 0 === counter && deferred.resolve(results), deferred.promise;
        }
        var defer = function() {
            var value, deferred, pending = [];
            return deferred = {
                resolve: function(val) {
                    if (pending) {
                        var callbacks = pending;
                        pending = undefined, value = ref(val), callbacks.length && nextTick(function() {
                            for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], 
                            value.then(callback[0], callback[1], callback[2]);
                        });
                    }
                },
                reject: function(reason) {
                    deferred.resolve(createInternalRejectedPromise(reason));
                },
                notify: function(progress) {
                    if (pending) {
                        var callbacks = pending;
                        pending.length && nextTick(function() {
                            for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], 
                            callback[2](progress);
                        });
                    }
                },
                promise: {
                    then: function(callback, errback, progressback) {
                        var result = defer(), wrappedCallback = function(value) {
                            try {
                                result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
                            } catch (e) {
                                result.reject(e), exceptionHandler(e);
                            }
                        }, wrappedErrback = function(reason) {
                            try {
                                result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
                            } catch (e) {
                                result.reject(e), exceptionHandler(e);
                            }
                        }, wrappedProgressback = function(progress) {
                            try {
                                result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        };
                        return pending ? pending.push([ wrappedCallback, wrappedErrback, wrappedProgressback ]) : value.then(wrappedCallback, wrappedErrback, wrappedProgressback), 
                        result.promise;
                    },
                    "catch": function(callback) {
                        return this.then(null, callback);
                    },
                    "finally": function(callback) {
                        function makePromise(value, resolved) {
                            var result = defer();
                            return resolved ? result.resolve(value) : result.reject(value), result.promise;
                        }
                        function handleCallback(value, isResolved) {
                            var callbackOutput = null;
                            try {
                                callbackOutput = (callback || defaultCallback)();
                            } catch (e) {
                                return makePromise(e, !1);
                            }
                            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                                return makePromise(value, isResolved);
                            }, function(error) {
                                return makePromise(error, !1);
                            }) : makePromise(value, isResolved);
                        }
                        return this.then(function(value) {
                            return handleCallback(value, !0);
                        }, function(error) {
                            return handleCallback(error, !1);
                        });
                    }
                }
            };
        }, ref = function(value) {
            return isPromiseLike(value) ? value : {
                then: function(callback) {
                    var result = defer();
                    return nextTick(function() {
                        result.resolve(callback(value));
                    }), result.promise;
                }
            };
        }, reject = function(reason) {
            var result = defer();
            return result.reject(reason), result.promise;
        }, createInternalRejectedPromise = function(reason) {
            return {
                then: function(callback, errback) {
                    var result = defer();
                    return nextTick(function() {
                        try {
                            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
                        } catch (e) {
                            result.reject(e), exceptionHandler(e);
                        }
                    }), result.promise;
                }
            };
        }, when = function(value, callback, errback, progressback) {
            var done, result = defer(), wrappedCallback = function(value) {
                try {
                    return (isFunction(callback) ? callback : defaultCallback)(value);
                } catch (e) {
                    return exceptionHandler(e), reject(e);
                }
            }, wrappedErrback = function(reason) {
                try {
                    return (isFunction(errback) ? errback : defaultErrback)(reason);
                } catch (e) {
                    return exceptionHandler(e), reject(e);
                }
            }, wrappedProgressback = function(progress) {
                try {
                    return (isFunction(progressback) ? progressback : defaultCallback)(progress);
                } catch (e) {
                    exceptionHandler(e);
                }
            };
            return nextTick(function() {
                ref(value).then(function(value) {
                    done || (done = !0, result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback)));
                }, function(reason) {
                    done || (done = !0, result.resolve(wrappedErrback(reason)));
                }, function(progress) {
                    done || result.notify(wrappedProgressback(progress));
                });
            }), result.promise;
        };
        return {
            defer: defer,
            reject: reject,
            when: when,
            all: all
        };
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this["this"] = this.$root = this, this.$$destroyed = !1, this.$$asyncQueue = [], 
                this.$$postDigestQueue = [], this.$$listeners = {}, this.$$listenerCount = {}, this.$$isolateBindings = {};
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function compileToFn(exp, name) {
                var fn = $parse(exp);
                return assertArgFn(fn, name), fn;
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate) {
                    var child;
                    return isolate ? (child = new Scope(), child.$root = this.$root, child.$$asyncQueue = this.$$asyncQueue, 
                    child.$$postDigestQueue = this.$$postDigestQueue) : (this.$$childScopeClass || (this.$$childScopeClass = function() {
                        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                        this.$$listeners = {}, this.$$listenerCount = {}, this.$id = nextUid(), this.$$childScopeClass = null;
                    }, this.$$childScopeClass.prototype = this), child = new this.$$childScopeClass()), 
                    child["this"] = child, child.$parent = this, child.$$prevSibling = this.$$childTail, 
                    this.$$childHead ? (this.$$childTail.$$nextSibling = child, this.$$childTail = child) : this.$$childHead = this.$$childTail = child, 
                    child;
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var scope = this, get = compileToFn(watchExp, "watch"), array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    if (lastDirtyWatch = null, !isFunction(listener)) {
                        var listenFn = compileToFn(listener || noop, "listener");
                        watcher.fn = function(newVal, oldVal, scope) {
                            listenFn(scope);
                        };
                    }
                    if ("string" == typeof watchExp && get.constant) {
                        var originalFn = watcher.fn;
                        watcher.fn = function(newVal, oldVal, scope) {
                            originalFn.call(this, newVal, oldVal, scope), arrayRemove(array, watcher);
                        };
                    }
                    return array || (array = scope.$$watchers = []), array.unshift(watcher), function() {
                        arrayRemove(array, watcher), lastDirtyWatch = null;
                    };
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionWatch() {
                        newValue = objGetter(self);
                        var newLength, key, bothNaN;
                        if (isObject(newValue)) if (isArrayLike(newValue)) {
                            oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                            changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                            oldValue.length = oldLength = newLength);
                            for (var i = 0; newLength > i; i++) bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i], 
                            bothNaN || oldValue[i] === newValue[i] || (changeDetected++, oldValue[i] = newValue[i]);
                        } else {
                            oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                            newLength = 0;
                            for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, oldValue.hasOwnProperty(key) ? (bothNaN = oldValue[key] !== oldValue[key] && newValue[key] !== newValue[key], 
                            bothNaN || oldValue[key] === newValue[key] || (changeDetected++, oldValue[key] = newValue[key])) : (oldLength++, 
                            oldValue[key] = newValue[key], changeDetected++));
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key) && (oldLength--, 
                                delete oldValue[key]);
                            }
                        } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, objGetter = $parse(obj), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch($watchCollectionWatch, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, next, current, logIdx, logMsg, asyncTask, asyncQueue = this.$$asyncQueue, postDigestQueue = this.$$postDigestQueue, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), lastDirtyWatch = null;
                    do {
                        for (dirty = !1, current = target; asyncQueue.length; ) {
                            try {
                                asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression);
                            } catch (e) {
                                clearPhase(), $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (length = watchers.length; length--; ) try {
                                if (watch = watchers[length]) if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp, 
                                logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last), watchLog[logIdx].push(logMsg));
                            } catch (e) {
                                clearPhase(), $exceptionHandler(e);
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog));
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueue.length; ) try {
                        postDigestQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this !== $rootScope && (forEach(this.$$listenerCount, bind(null, decrementListenerCount, this)), 
                        parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null, 
                        this.$$listeners = {}, this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [], 
                        this.$destroy = this.$digest = this.$apply = noop, this.$on = this.$watch = function() {
                            return noop;
                        });
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr) {
                    $rootScope.$$phase || $rootScope.$$asyncQueue.length || $browser.defer(function() {
                        $rootScope.$$asyncQueue.length && $rootScope.$digest();
                    }), this.$$asyncQueue.push({
                        scope: this,
                        expression: expr
                    });
                },
                $$postDigest: function(fn) {
                    this.$$postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        return beginPhase("$apply"), this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        namedListeners[indexOf(namedListeners, listener)] = null, decrementListenerCount(self, 1, name);
                    };
                },
                $emit: function(name) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event;
                        scope = scope.$parent;
                    } while (scope);
                    return event;
                },
                $broadcast: function(name) {
                    for (var listeners, i, length, target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event;
                }
            };
            var $rootScope = new Scope();
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return msie && !(msie >= 8) || (normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex)) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function escapeForRegexp(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function() {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sniffer", "$sceDelegate", function($parse, $sniffer, $sceDelegate) {
            if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : function(self, locals) {
                    return sce.getTrusted(type, parsed(self, locals));
                };
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var vendorPrefix, match, eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, documentMode = document.documentMode, vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            if (bodyStyle) {
                for (var prop in bodyStyle) if (match = vendorRegex.exec(prop)) {
                    vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                    break;
                }
                vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), 
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), 
                !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), 
                animations = isString(document.body.style.webkitAnimation));
            }
            return {
                history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
                hasEvent: function(event) {
                    if ("input" == event && 9 == msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android,
                msie: msie,
                msieDocumentMode: documentMode
            };
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$exceptionHandler", function($rootScope, $browser, $q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                var timeoutId, deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), 
                delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1;
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var comparatorType = typeof comparator, predicates = [];
            predicates.check = function(value) {
                for (var j = 0; j < predicates.length; j++) if (!predicates[j](value)) return !1;
                return !0;
            }, "function" !== comparatorType && (comparator = "boolean" === comparatorType && comparator ? function(obj, text) {
                return angular.equals(obj, text);
            } : function(obj, text) {
                if (obj && text && "object" == typeof obj && "object" == typeof text) {
                    for (var objKey in obj) if ("$" !== objKey.charAt(0) && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) return !0;
                    return !1;
                }
                return text = ("" + text).toLowerCase(), ("" + obj).toLowerCase().indexOf(text) > -1;
            });
            var search = function(obj, text) {
                if ("string" == typeof text && "!" === text.charAt(0)) return !search(obj, text.substr(1));
                switch (typeof obj) {
                  case "boolean":
                  case "number":
                  case "string":
                    return comparator(obj, text);

                  case "object":
                    switch (typeof text) {
                      case "object":
                        return comparator(obj, text);

                      default:
                        for (var objKey in obj) if ("$" !== objKey.charAt(0) && search(obj[objKey], text)) return !0;
                    }
                    return !1;

                  case "array":
                    for (var i = 0; i < obj.length; i++) if (search(obj[i], text)) return !0;
                    return !1;

                  default:
                    return !1;
                }
            };
            switch (typeof expression) {
              case "boolean":
              case "number":
              case "string":
                expression = {
                    $: expression
                };

              case "object":
                for (var key in expression) !function(path) {
                    "undefined" != typeof expression[path] && predicates.push(function(value) {
                        return search("$" == path ? value : value && value[path], expression[path]);
                    });
                }(key);
                break;

              case "function":
                predicates.push(expression);
                break;

              default:
                return array;
            }
            for (var filtered = [], j = 0; j < array.length; j++) {
                var value = array[j];
                predicates.check(value) && filtered.push(value);
            }
            return filtered;
        };
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (null == number || !isFinite(number) || isObject(number)) return "";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [], hasExponent = !1;
        if (-1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? (numStr = "0", number = 0) : (formatedText = numStr, 
            hasExponent = !0);
        }
        if (hasExponent) fractionSize > 0 && number > -1 && 1 > number && (formatedText = number.toFixed(fractionSize)); else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), 
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) for (pos = whole.length - lgroup, i = 0; pos > i; i++) (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++) (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (;fraction.length < fractionSize; ) fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize));
        }
        return parts.push(isNegative ? pattern.negPre : pattern.posPre), parts.push(formatedText), 
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf), parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits; ) num = "0" + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), 
            padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset(), paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])), 
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour, m = int(match[5] || 0) - tzMin, s = int(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date)) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            return forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object) {
            return toJson(object, !0);
        };
    }
    function limitToFilter() {
        return function(input, limit) {
            if (!isArray(input) && !isString(input)) return input;
            if (limit = 1/0 === Math.abs(Number(limit)) ? Number(limit) : int(limit), isString(input)) return limit ? limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length) : "";
            var i, n, out = [];
            for (limit > input.length ? limit = input.length : limit < -input.length && (limit = -input.length), 
            limit > 0 ? (i = 0, n = limit) : (i = input.length + limit, n = input.length); n > i; i++) out.push(input[i]);
            return out;
        };
    }
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (0 !== comp) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return toBoolean(descending) ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function compare(v1, v2) {
                var t1 = typeof v1, t2 = typeof v2;
                return t1 == t2 ? (isDate(v1) && isDate(v2) && (v1 = v1.valueOf(), v2 = v2.valueOf()), 
                "string" == t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), v1 === v2 ? 0 : v2 > v1 ? -1 : 1) : t2 > t1 ? -1 : 1;
            }
            if (!isArray(array)) return array;
            if (!sortPredicate) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ], sortPredicate = map(sortPredicate, function(predicate) {
                var descending = !1, get = predicate || identity;
                if (isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), 
                predicate = predicate.substring(1)), get = $parse(predicate), get.constant)) {
                    var key = get();
                    return reverseComparator(function(a, b) {
                        return compare(a[key], b[key]);
                    }, descending);
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            for (var arrayCopy = [], i = 0; i < array.length; i++) arrayCopy.push(array[i]);
            return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function FormController(element, attrs, $scope, $animate) {
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            $animate.removeClass(element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey), 
            $animate.addClass(element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        var form = this, parentForm = element.parent().controller("form") || nullFormCtrl, invalidCount = 0, errors = form.$error = {}, controls = [];
        form.$name = attrs.name || attrs.ngForm, form.$dirty = !1, form.$pristine = !0, 
        form.$valid = !0, form.$invalid = !1, parentForm.$addControl(form), element.addClass(PRISTINE_CLASS), 
        toggleValidCss(!0), form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control);
        }, form.$removeControl = function(control) {
            control.$name && form[control.$name] === control && delete form[control.$name], 
            forEach(errors, function(queue, validationToken) {
                form.$setValidity(validationToken, !0, control);
            }), arrayRemove(controls, control);
        }, form.$setValidity = function(validationToken, isValid, control) {
            var queue = errors[validationToken];
            if (isValid) queue && (arrayRemove(queue, control), queue.length || (invalidCount--, 
            invalidCount || (toggleValidCss(isValid), form.$valid = !0, form.$invalid = !1), 
            errors[validationToken] = !1, toggleValidCss(!0, validationToken), parentForm.$setValidity(validationToken, !0, form))); else {
                if (invalidCount || toggleValidCss(isValid), queue) {
                    if (includes(queue, control)) return;
                } else errors[validationToken] = queue = [], invalidCount++, toggleValidCss(!1, validationToken), 
                parentForm.$setValidity(validationToken, !1, form);
                queue.push(control), form.$valid = !1, form.$invalid = !0;
            }
        }, form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), 
            form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty();
        }, form.$setPristine = function() {
            $animate.removeClass(element, DIRTY_CLASS), $animate.addClass(element, PRISTINE_CLASS), 
            form.$dirty = !1, form.$pristine = !0, forEach(controls, function(control) {
                control.$setPristine();
            });
        };
    }
    function validate(ctrl, validatorName, validity, value) {
        return ctrl.$setValidity(validatorName, validity), validity ? value : undefined;
    }
    function testFlags(validity, flags) {
        var i, flag;
        if (flags) for (i = 0; i < flags.length; ++i) if (flag = flags[i], validity[flag]) return !0;
        return !1;
    }
    function addNativeHtml5Validators(ctrl, validatorName, badFlags, ignoreFlags, validity) {
        if (isObject(validity)) {
            ctrl.$$hasNativeValidators = !0;
            var validator = function(value) {
                return ctrl.$error[validatorName] || testFlags(validity, ignoreFlags) || !testFlags(validity, badFlags) ? value : void ctrl.$setValidity(validatorName, !1);
            };
            ctrl.$parsers.push(validator);
        }
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY), placeholder = element[0].placeholder, noevent = {};
        if (ctrl.$$validityState = validity, !$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function() {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var listener = function(ev) {
            if (!composing) {
                var value = element.val();
                if (msie && "input" === (ev || noevent).type && element[0].placeholder !== placeholder) return void (placeholder = element[0].placeholder);
                toBoolean(attr.ngTrim || "T") && (value = trim(value));
                var revalidate = validity && ctrl.$$hasNativeValidators;
                (ctrl.$viewValue !== value || "" === value && revalidate) && (scope.$$phase ? ctrl.$setViewValue(value) : scope.$apply(function() {
                    ctrl.$setViewValue(value);
                }));
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var timeout, deferListener = function() {
                timeout || (timeout = $browser.defer(function() {
                    listener(), timeout = null;
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener();
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
        var patternValidator, match, pattern = attr.ngPattern;
        if (pattern) {
            var validateRegex = function(regexp, value) {
                return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value);
            };
            match = pattern.match(/^\/(.*)\/([gim]*)$/), match ? (pattern = new RegExp(match[1], match[2]), 
            patternValidator = function(value) {
                return validateRegex(pattern, value);
            }) : patternValidator = function(value) {
                var patternObj = scope.$eval(pattern);
                if (!patternObj || !patternObj.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
                return validateRegex(patternObj, value);
            }, ctrl.$formatters.push(patternValidator), ctrl.$parsers.push(patternValidator);
        }
        if (attr.ngMinlength) {
            var minlength = int(attr.ngMinlength), minLengthValidator = function(value) {
                return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value);
            };
            ctrl.$parsers.push(minLengthValidator), ctrl.$formatters.push(minLengthValidator);
        }
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength), maxLengthValidator = function(value) {
                return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value);
            };
            ctrl.$parsers.push(maxLengthValidator), ctrl.$formatters.push(maxLengthValidator);
        }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (textInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$parsers.push(function(value) {
            var empty = ctrl.$isEmpty(value);
            return empty || NUMBER_REGEXP.test(value) ? (ctrl.$setValidity("number", !0), "" === value ? null : empty ? value : parseFloat(value)) : (ctrl.$setValidity("number", !1), 
            undefined);
        }), addNativeHtml5Validators(ctrl, "number", numberBadFlags, null, ctrl.$$validityState), 
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? "" : "" + value;
        }), attr.min) {
            var minValidator = function(value) {
                var min = parseFloat(attr.min);
                return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value);
            };
            ctrl.$parsers.push(minValidator), ctrl.$formatters.push(minValidator);
        }
        if (attr.max) {
            var maxValidator = function(value) {
                var max = parseFloat(attr.max);
                return validate(ctrl, "max", ctrl.$isEmpty(value) || max >= value, value);
            };
            ctrl.$parsers.push(maxValidator), ctrl.$formatters.push(maxValidator);
        }
        ctrl.$formatters.push(function(value) {
            return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value);
        });
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var urlValidator = function(value) {
            return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value);
        };
        ctrl.$formatters.push(urlValidator), ctrl.$parsers.push(urlValidator);
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var emailValidator = function(value) {
            return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value);
        };
        ctrl.$formatters.push(emailValidator), ctrl.$parsers.push(emailValidator);
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid()), element.on("click", function() {
            element[0].checked && scope.$apply(function() {
                ctrl.$setViewValue(attr.value);
            });
        }), ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
        isString(trueValue) || (trueValue = !0), isString(falseValue) || (falseValue = !1), 
        element.on("click", function() {
            scope.$apply(function() {
                ctrl.$setViewValue(element[0].checked);
            });
        }), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value !== trueValue;
        }, ctrl.$formatters.push(function(value) {
            return value === trueValue;
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name, [ "$animate", function($animate) {
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) return classVal;
                if (isString(classVal)) return classVal.split(" ");
                if (isObject(classVal)) {
                    var classes = [];
                    return forEach(classVal, function(v, k) {
                        v && (classes = classes.concat(k.split(" ")));
                    }), classes;
                }
                return classVal;
            }
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {}, classesToUpdate = [];
                        return forEach(classes, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), element.data("$classCounts", classCounts), classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                        toRemove = digestClassCounts(toRemove, -1), toAdd = digestClassCounts(toAdd, 1), 
                        0 === toAdd.length ? $animate.removeClass(element, toRemove) : 0 === toRemove.length ? $animate.addClass(element, toAdd) : $animate.setClass(element, toAdd, toRemove);
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === !0 || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (oldVal) {
                                if (!equals(newVal, oldVal)) {
                                    var oldClasses = arrayClasses(oldVal);
                                    updateClasses(oldClasses, newClasses);
                                }
                            } else addClasses(newClasses);
                        }
                        oldVal = shallowCopy(newVal);
                    }
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function() {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    }), "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
                        var mod = 1 & $index;
                        if (mod !== (1 & old$index)) {
                            var classes = arrayClasses(scope.$eval(attr[name]));
                            mod === selector ? addClasses(classes) : removeClasses(classes);
                        }
                    });
                }
            };
        } ];
    }
    var VALIDITY_STATE_PROPERTY = "validity", lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, nodeName_, slice = [].slice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = [ "0", "0", "0" ];
    msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), isNaN(msie) && (msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])), 
    noop.$inject = [], identity.$inject = [];
    var isArray = function() {
        return isFunction(Array.isArray) ? Array.isArray : function(value) {
            return "[object Array]" === toString.call(value);
        };
    }(), trim = function() {
        return String.prototype.trim ? function(value) {
            return isString(value) ? value.trim() : value;
        } : function(value) {
            return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value;
        };
    }();
    nodeName_ = 9 > msie ? function(element) {
        return element = element.nodeName ? element : element[0], element.scopeName && "HTML" != element.scopeName ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName;
    } : function(element) {
        return element.nodeName ? element.nodeName : element[0].nodeName;
    };
    var csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
        if (!active) try {
            new Function("");
        } catch (e) {
            active = !0;
        }
        return csp.isActive_ = active;
    }, SNAKE_CASE_REGEXP = /[A-Z]/g, version = {
        full: "1.2.21",
        major: 1,
        minor: 2,
        dot: 21,
        codeName: "wizard-props"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
        element.addEventListener(type, fn, !1);
    } : function(element, type, fn) {
        element.attachEvent("on" + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
        element.removeEventListener(type, fn, !1);
    } : function(element, type, fn) {
        element.detachEvent("on" + type, fn);
    }, SPECIAL_CHARS_REGEXP = (JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    }, /([\:\-\_]+(.))/g), MOZ_HACK_REGEXP = /^moz([A-Z])/, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            function trigger() {
                fired || (fired = !0, fn());
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), 
            JQLite(window).on("load", trigger));
        },
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[uppercase(value)] = !0;
    }), forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            if (name = camelCase(name), !isDefined(value)) {
                var val;
                return 8 >= msie && (val = element.currentStyle && element.currentStyle[name], "" === val && (val = "auto")), 
                val = val || element.style[name], 8 >= msie && (val = "" === val ? undefined : val), 
                val;
            }
            element.style[name] = value;
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, 
                element.removeAttribute(lowercasedName));
            } else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return null === ret ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
                return isUndefined(value) ? textProp ? element[textProp] : "" : void (element[textProp] = value);
            }
            var NODE_TYPE_TEXT_PROPERTY = [];
            return 9 > msie ? (NODE_TYPE_TEXT_PROPERTY[1] = "innerText", NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue") : NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent", 
            getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if ("SELECT" === nodeName_(element) && element.multiple) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), 0 === result.length ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) return element.innerHTML;
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        dealoc: jqLiteDealoc,
        on: function onFn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
            events || jqLiteExpandoStore(element, "events", events = {}), handle || jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events)), 
            forEach(type.split(" "), function(type) {
                var eventFns = events[type];
                if (!eventFns) {
                    if ("mouseenter" == type || "mouseleave" == type) {
                        var contains = document.body.contains || document.body.compareDocumentPosition ? function(a, b) {
                            var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                            return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
                        } : function(a, b) {
                            if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                            return !1;
                        };
                        events[type] = [];
                        var eventmap = {
                            mouseleave: "mouseout",
                            mouseenter: "mouseover"
                        };
                        onFn(element, eventmap[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            (!related || related !== target && !contains(target, related)) && handle(event, type);
                        });
                    } else addEventListenerFn(element, type, handle), events[type] = [];
                    eventFns = events[type];
                }
                eventFns.push(fn);
            });
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                1 === element.nodeType && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            forEach(new JQLite(node), function(child) {
                (1 === element.nodeType || 11 === element.nodeType) && element.appendChild(child);
            });
        },
        prepend: function(element, node) {
            if (1 === element.nodeType) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode)[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element);
        },
        remove: function(element) {
            jqLiteDealoc(element);
            var parent = element.parentNode;
            parent && parent.removeChild(element);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            forEach(new JQLite(newElement), function(node) {
                parent.insertBefore(node, index.nextSibling), index = node;
            });
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        next: function(element) {
            if (element.nextElementSibling) return element.nextElementSibling;
            for (var elm = element.nextSibling; null != elm && 1 !== elm.nodeType; ) elm = elm.nextSibling;
            return elm;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, eventName, eventData) {
            var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName], eventFnsCopy = shallowCopy(eventFns || []);
            eventData = eventData || [];
            var event = [ {
                preventDefault: noop,
                stopPropagation: noop
            } ];
            forEach(eventFnsCopy, function(fn) {
                fn.apply(element, event.concat(eventData));
            });
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0; i < this.length; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    }), HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector"), $animateMinErr = minErr("$animate"), $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {}, this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && "." != name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null), 
            this.$$classNameFilter;
        }, this.$get = [ "$timeout", "$$asyncCallback", function($timeout, $$asyncCallback) {
            function async(fn) {
                fn && $$asyncCallback(fn);
            }
            return {
                enter: function(element, parent, after, done) {
                    after ? after.after(element) : (parent && parent[0] || (parent = after.parent()), 
                    parent.append(element)), async(done);
                },
                leave: function(element, done) {
                    element.remove(), async(done);
                },
                move: function(element, parent, after, done) {
                    this.enter(element, parent, after, done);
                },
                addClass: function(element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "", 
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    }), async(done);
                },
                removeClass: function(element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "", 
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    }), async(done);
                },
                setClass: function(element, add, remove, done) {
                    forEach(element, function(element) {
                        jqLiteAddClass(element, add), jqLiteRemoveClass(element, remove);
                    }), async(done);
                },
                enabled: noop
            };
        } ];
    } ], $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i, $interpolateMinErr = minErr("$interpolate"), PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location");
    LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url, replace) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return match[1] && this.path(decodeURIComponent(match[1])), (match[2] || match[1]) && this.search(match[3] || ""), 
            this.hash(match[5] || "", replace), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return "/" == path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search)) this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", identity),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    var promiseWarning, $parseMinErr = minErr("$parse"), promiseWarningCache = {}, CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, OPERATORS = {
        "null": function() {
            return null;
        },
        "true": function() {
            return !0;
        },
        "false": function() {
            return !1;
        },
        undefined: noop,
        "+": function(self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "^": function(self, locals, a, b) {
            return a(self, locals) ^ b(self, locals);
        },
        "=": noop,
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "&": function(self, locals, a, b) {
            return a(self, locals) & b(self, locals);
        },
        "|": function(self, locals, a, b) {
            return b(self, locals)(self, locals, a(self, locals));
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        }
    }, ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.ch = undefined, this.lastCh = ":", this.tokens = []; this.index < this.text.length; ) {
                if (this.ch = this.text.charAt(this.index), this.is("\"'")) this.readString(this.ch); else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(this.ch)) this.readIdent(); else if (this.is("(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: this.ch
                }), this.index++; else {
                    if (this.isWhitespace(this.ch)) {
                        this.index++;
                        continue;
                    }
                    var ch2 = this.ch + this.peek(), ch3 = ch2 + this.peek(2), fn = OPERATORS[this.ch], fn2 = OPERATORS[ch2], fn3 = OPERATORS[ch3];
                    fn3 ? (this.tokens.push({
                        index: this.index,
                        text: ch3,
                        fn: fn3
                    }), this.index += 3) : fn2 ? (this.tokens.push({
                        index: this.index,
                        text: ch2,
                        fn: fn2
                    }), this.index += 2) : fn ? (this.tokens.push({
                        index: this.index,
                        text: this.ch,
                        fn: fn
                    }), this.index += 1) : this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
                this.lastCh = this.ch;
            }
            return this.tokens;
        },
        is: function(chars) {
            return -1 !== chars.indexOf(this.ch);
        },
        was: function(chars) {
            return -1 !== chars.indexOf(this.lastCh);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || " " === ch;
        },
        isIdent: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            number = 1 * number, this.tokens.push({
                index: start,
                text: number,
                literal: !0,
                constant: !0,
                fn: function() {
                    return number;
                }
            });
        },
        readIdent: function() {
            for (var lastDot, peekIndex, methodName, ch, parser = this, ident = "", start = this.index; this.index < this.text.length && (ch = this.text.charAt(this.index), 
            "." === ch || this.isIdent(ch) || this.isNumber(ch)); ) "." === ch && (lastDot = this.index), 
            ident += ch, this.index++;
            if (lastDot) for (peekIndex = this.index; peekIndex < this.text.length; ) {
                if (ch = this.text.charAt(peekIndex), "(" === ch) {
                    methodName = ident.substr(lastDot - start + 1), ident = ident.substr(0, lastDot - start), 
                    this.index = peekIndex;
                    break;
                }
                if (!this.isWhitespace(ch)) break;
                peekIndex++;
            }
            var token = {
                index: start,
                text: ident
            };
            if (OPERATORS.hasOwnProperty(ident)) token.fn = OPERATORS[ident], token.literal = !0, 
            token.constant = !0; else {
                var getter = getterFn(ident, this.options, this.text);
                token.fn = extend(function(self, locals) {
                    return getter(self, locals);
                }, {
                    assign: function(self, value) {
                        return setter(self, ident, value, parser.text, parser.options);
                    }
                });
            }
            this.tokens.push(token), methodName && (this.tokens.push({
                index: lastDot,
                text: "."
            }), this.tokens.push({
                index: lastDot + 1,
                text: methodName
            }));
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        string: string,
                        literal: !0,
                        constant: !0,
                        fn: function() {
                            return string;
                        }
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        constant: !0
    }), Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.statements();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value.literal = !!value.literal, value.constant = !!value.constant, value;
        },
        primary: function() {
            var primary;
            if (this.expect("(")) primary = this.filterChain(), this.consume(")"); else if (this.expect("[")) primary = this.arrayDeclaration(); else if (this.expect("{")) primary = this.object(); else {
                var token = this.expect();
                primary = token.fn, primary || this.throwError("not a primary expression", token), 
                primary.literal = !!token.literal, primary.constant = !!token.constant;
            }
            for (var next, context; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = this.functionCall(primary, context), 
            context = null) : "[" === next.text ? (context = primary, primary = this.objectIndex(primary)) : "." === next.text ? (context = primary, 
            primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            if (this.tokens.length > 0) {
                var token = this.tokens[0], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        consume: function(e1) {
            this.expect(e1) || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
        },
        unaryFn: function(fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant
            });
        },
        ternaryFn: function(left, middle, right) {
            return extend(function(self, locals) {
                return left(self, locals) ? middle(self, locals) : right(self, locals);
            }, {
                constant: left.constant && middle.constant && right.constant
            });
        },
        binaryFn: function(left, fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant
            });
        },
        statements: function() {
            for (var statements = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), 
            !this.expect(";")) return 1 === statements.length ? statements[0] : function(self, locals) {
                for (var value, i = 0; i < statements.length; i++) {
                    var statement = statements[i];
                    statement && (value = statement(self, locals));
                }
                return value;
            };
        },
        filterChain: function() {
            for (var token, left = this.expression(); ;) {
                if (!(token = this.expect("|"))) return left;
                left = this.binaryFn(left, token.fn, this.filter());
            }
        },
        filter: function() {
            for (var token = this.expect(), fn = this.$filter(token.text), argsFn = []; ;) {
                if (!(token = this.expect(":"))) {
                    var fnInvoke = function(self, locals, input) {
                        for (var args = [ input ], i = 0; i < argsFn.length; i++) args.push(argsFn[i](self, locals));
                        return fn.apply(self, args);
                    };
                    return function() {
                        return fnInvoke;
                    };
                }
                argsFn.push(this.expression());
            }
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var right, token, left = this.ternary();
            return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), 
            right = this.ternary(), function(scope, locals) {
                return left.assign(scope, right(scope, locals), locals);
            }) : left;
        },
        ternary: function() {
            var middle, token, left = this.logicalOR();
            return (token = this.expect("?")) ? (middle = this.ternary(), (token = this.expect(":")) ? this.ternaryFn(left, middle, this.ternary()) : void this.throwError("expected :", token)) : left;
        },
        logicalOR: function() {
            for (var token, left = this.logicalAND(); ;) {
                if (!(token = this.expect("||"))) return left;
                left = this.binaryFn(left, token.fn, this.logicalAND());
            }
        },
        logicalAND: function() {
            var token, left = this.equality();
            return (token = this.expect("&&")) && (left = this.binaryFn(left, token.fn, this.logicalAND())), 
            left;
        },
        equality: function() {
            var token, left = this.relational();
            return (token = this.expect("==", "!=", "===", "!==")) && (left = this.binaryFn(left, token.fn, this.equality())), 
            left;
        },
        relational: function() {
            var token, left = this.additive();
            return (token = this.expect("<", ">", "<=", ">=")) && (left = this.binaryFn(left, token.fn, this.relational())), 
            left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = this.binaryFn(left, token.fn, this.multiplicative());
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = this.binaryFn(left, token.fn, this.unary());
            return left;
        },
        unary: function() {
            var token;
            return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.fn, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.fn, this.unary()) : this.primary();
        },
        fieldAccess: function(object) {
            var parser = this, field = this.expect().text, getter = getterFn(field, this.options, this.text);
            return extend(function(scope, locals, self) {
                return getter(self || object(scope, locals));
            }, {
                assign: function(scope, value, locals) {
                    return setter(object(scope, locals), field, value, parser.text, parser.options);
                }
            });
        },
        objectIndex: function(obj) {
            var parser = this, indexFn = this.expression();
            return this.consume("]"), extend(function(self, locals) {
                var v, p, o = obj(self, locals), i = indexFn(self, locals);
                return ensureSafeMemberName(i, parser.text), o ? (v = ensureSafeObject(o[i], parser.text), 
                v && v.then && parser.options.unwrapPromises && (p = v, "$$v" in v || (p.$$v = undefined, 
                p.then(function(val) {
                    p.$$v = val;
                })), v = v.$$v), v) : undefined;
            }, {
                assign: function(self, value, locals) {
                    var key = indexFn(self, locals), safe = ensureSafeObject(obj(self, locals), parser.text);
                    return safe[key] = value;
                }
            });
        },
        functionCall: function(fn, contextGetter) {
            var argsFn = [];
            if (")" !== this.peekToken().text) do argsFn.push(this.expression()); while (this.expect(","));
            this.consume(")");
            var parser = this;
            return function(scope, locals) {
                for (var args = [], context = contextGetter ? contextGetter(scope, locals) : scope, i = 0; i < argsFn.length; i++) args.push(argsFn[i](scope, locals));
                var fnPtr = fn(scope, locals, context) || noop;
                ensureSafeObject(context, parser.text), ensureSafeFunction(fnPtr, parser.text);
                var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
                return ensureSafeObject(v, parser.text);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [], allConstant = !0;
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                var elementFn = this.expression();
                elementFns.push(elementFn), elementFn.constant || (allConstant = !1);
            } while (this.expect(","));
            return this.consume("]"), extend(function(self, locals) {
                for (var array = [], i = 0; i < elementFns.length; i++) array.push(elementFns[i](self, locals));
                return array;
            }, {
                literal: !0,
                constant: allConstant
            });
        },
        object: function() {
            var keyValues = [], allConstant = !0;
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                var token = this.expect(), key = token.string || token.text;
                this.consume(":");
                var value = this.expression();
                keyValues.push({
                    key: key,
                    value: value
                }), value.constant || (allConstant = !1);
            } while (this.expect(","));
            return this.consume("}"), extend(function(self, locals) {
                for (var object = {}, i = 0; i < keyValues.length; i++) {
                    var keyValue = keyValues[i];
                    object[keyValue.key] = keyValue.value(self, locals);
                }
                return object;
            }, {
                literal: !0,
                constant: allConstant
            });
        }
    };
    var getterFnCache = {}, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href, !0);
    $FilterProvider.$inject = [ "$provide" ], currencyFilter.$inject = [ "$locale" ], 
    numberFilter.$inject = [ "$locale" ];
    var DECIMAL_SEP = ".", DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, !0),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return 8 >= msie && (attr.href || attr.name || attr.$set("href", ""), element.append(document.createComment("IE fix"))), 
            attr.href || attr.xlinkHref || attr.name ? void 0 : function(scope, element) {
                var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                element.on("click", function(event) {
                    element.attr(href) || event.preventDefault();
                });
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function() {
                return {
                    priority: 100,
                    link: function(scope, element, attr) {
                        scope.$watch(attr[normalized], function(value) {
                            attr.$set(attrName, !!value);
                        });
                    }
                };
            };
        }
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        value && (attr.$set(name, value), msie && propName && element.prop(propName, attr[name]));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop
    };
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate" ];
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function() {
                    return {
                        pre: function(scope, formElement, attr, controller) {
                            if (!attr.action) {
                                var preventDefaultListener = function(event) {
                                    event.preventDefault ? event.preventDefault() : event.returnValue = !1;
                                };
                                addEventListenerFn(formElement[0], "submit", preventDefaultListener), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", preventDefaultListener);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = formElement.parent().controller("form"), alias = attr.name || attr.ngForm;
                            alias && setter(scope, alias, controller, alias), parentFormCtrl && formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller), alias && setter(scope, alias, undefined, alias), 
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/, inputType = {
        text: textInputType,
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, numberBadFlags = [ "badInput" ], inputDirective = [ "$browser", "$sniffer", function($browser, $sniffer) {
        return {
            restrict: "E",
            require: "?ngModel",
            link: function(scope, element, attr, ctrl) {
                ctrl && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
        };
    } ], VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            $animate.removeClass($element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey), 
            $animate.addClass($element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$parsers = [], 
        this.$formatters = [], this.$viewChangeListeners = [], this.$pristine = !0, this.$dirty = !1, 
        this.$valid = !0, this.$invalid = !1, this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        this.$render = noop, this.$isEmpty = function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS), toggleValidCss(!0), this.$setValidity = function(validationErrorKey, isValid) {
            $error[validationErrorKey] !== !isValid && (isValid ? ($error[validationErrorKey] && invalidCount--, 
            invalidCount || (toggleValidCss(!0), this.$valid = !0, this.$invalid = !1)) : (toggleValidCss(!1), 
            this.$invalid = !0, this.$valid = !1, invalidCount++), $error[validationErrorKey] = !isValid, 
            toggleValidCss(isValid, validationErrorKey), parentForm.$setValidity(validationErrorKey, isValid, this));
        }, this.$setPristine = function() {
            this.$dirty = !1, this.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), 
            $animate.addClass($element, PRISTINE_CLASS);
        }, this.$setViewValue = function(value) {
            this.$viewValue = value, this.$pristine && (this.$dirty = !0, this.$pristine = !1, 
            $animate.removeClass($element, PRISTINE_CLASS), $animate.addClass($element, DIRTY_CLASS), 
            parentForm.$setDirty()), forEach(this.$parsers, function(fn) {
                value = fn(value);
            }), this.$modelValue !== value && (this.$modelValue = value, ngModelSet($scope, value), 
            forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            }));
        };
        var ctrl = this;
        $scope.$watch(function() {
            var value = ngModelGet($scope);
            if (ctrl.$modelValue !== value) {
                var formatters = ctrl.$formatters, idx = formatters.length;
                for (ctrl.$modelValue = value; idx--; ) value = formatters[idx](value);
                ctrl.$viewValue !== value && (ctrl.$viewValue = value, ctrl.$render());
            }
            return value;
        });
    } ], ngModelDirective = function() {
        return {
            require: [ "ngModel", "^?form" ],
            controller: NgModelController,
            link: function(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                formCtrl.$addControl(modelCtrl), scope.$on("$destroy", function() {
                    formCtrl.$removeControl(modelCtrl);
                });
            }
        };
    }, ngChangeDirective = valueFn({
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), requiredDirective = function() {
        return {
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    attr.required = !0;
                    var validator = function(value) {
                        return attr.required && ctrl.$isEmpty(value) ? void ctrl.$setValidity("required", !1) : (ctrl.$setValidity("required", !0), 
                        value);
                    };
                    ctrl.$formatters.push(validator), ctrl.$parsers.unshift(validator), attr.$observe("required", function() {
                        validator(ctrl.$viewValue);
                    });
                }
            }
        };
    }, ngListDirective = function() {
        return {
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ",", parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trim(value));
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(", ") : undefined;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        return {
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        attr.$set("value", value);
                    });
                };
            }
        };
    }, ngBindDirective = ngDirective({
        compile: function(templateElement) {
            return templateElement.addClass("ng-binding"), function(scope, element, attr) {
                element.data("$binding", attr.ngBind), scope.$watch(attr.ngBind, function(value) {
                    element.text(value == undefined ? "" : value);
                });
            };
        }
    }), ngBindTemplateDirective = [ "$interpolate", function($interpolate) {
        return function(scope, element, attr) {
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            element.addClass("ng-binding").data("$binding", interpolateFn), attr.$observe("ngBindTemplate", function(value) {
                element.text(value);
            });
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", function($sce, $parse) {
        return {
            compile: function(tElement) {
                return tElement.addClass("ng-binding"), function(scope, element, attr) {
                    function getStringValue() {
                        return (parsed(scope) || "").toString();
                    }
                    element.data("$binding", attr.ngBindHtml);
                    var parsed = $parse(attr.ngBindHtml);
                    scope.$watch(getStringValue, function() {
                        element.html($sce.getTrustedHtml(parsed(scope)) || "");
                    });
                };
            }
        };
    } ], ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {};
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(name) {
        var directiveName = directiveNormalize("ng-" + name);
        ngEventDirectives[directiveName] = [ "$parse", function($parse) {
            return {
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function(scope, element) {
                        element.on(lowercase(name), function(event) {
                            scope.$apply(function() {
                                fn(scope, {
                                    $event: event
                                });
                            });
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    toBoolean(value) ? childScope || (childScope = $scope.$new(), $transclude(childScope, function(clone) {
                        clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    })) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockElements(block.clone), 
                    $animate.leave(previousElements, function() {
                        previousElements = null;
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$http", "$templateCache", "$anchorScroll", "$animate", "$sce", function($http, $templateCache, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement, function() {
                            previousElement = null;
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function(src) {
                        var afterAnimation = function() {
                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($http.get(src, {
                            cache: $templateCache
                        }).success(function(response) {
                            if (thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element, afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded"), 
                                scope.$eval(onloadExp);
                            }
                        }).error(function() {
                            thisChangeId === changeCounter && cleanupLastIncludeContent();
                        }), scope.$emit("$includeContentRequested")) : (cleanupLastIncludeContent(), ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                $element.html(ctrl.template), $compile($element.contents())(scope);
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), isWhen = /^when(Minus)?(.+)$/;
                forEach(attr, function(expression, attributeName) {
                    isWhen.test(attributeName) && (whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]));
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol));
                }), scope.$watch(function() {
                    var value = parseFloat(scope.$eval(numberExp));
                    return isNaN(value) ? "" : (value in whens || (value = $locale.pluralCat(value - offset)), 
                    whensExpFns[value](scope, element, !0));
                }, function(newVal) {
                    element.text(newVal);
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        function getBlockStart(block) {
            return block.clone[0];
        }
        function getBlockEnd(block) {
            return block.clone[block.clone.length - 1];
        }
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat");
        return {
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, expression = $attr.ngRepeat, match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), hashFnLocals = {
                    $id: hashKey
                };
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                if (lhs = match[1], rhs = match[2], trackByExp = match[3], trackByExp ? (trackByExpGetter = $parse(trackByExp), 
                trackByIdExpFn = function(key, value, index) {
                    return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                    hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                }) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                var lastBlockMap = {};
                $scope.$watchCollection(rhs, function(collection) {
                    var index, length, nextNode, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, elementsToRemove, previousNode = $element[0], nextBlockMap = {}, nextBlockOrder = [];
                    if (isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                        trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                        for (key in collection) collection.hasOwnProperty(key) && "$" != key.charAt(0) && collectionKeys.push(key);
                        collectionKeys.sort();
                    }
                    for (arrayLength = collectionKeys.length, length = nextBlockOrder.length = collectionKeys.length, 
                    index = 0; length > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                    value = collection[key], trackById = trackByIdFn(key, value, index), assertNotHasOwnProperty(trackById, "`track by` id"), 
                    lastBlockMap.hasOwnProperty(trackById)) block = lastBlockMap[trackById], delete lastBlockMap[trackById], 
                    nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                        if (nextBlockMap.hasOwnProperty(trackById)) throw forEach(nextBlockOrder, function(block) {
                            block && block.scope && (lastBlockMap[block.id] = block);
                        }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}", expression, trackById);
                        nextBlockOrder[index] = {
                            id: trackById
                        }, nextBlockMap[trackById] = !1;
                    }
                    for (key in lastBlockMap) lastBlockMap.hasOwnProperty(key) && (block = lastBlockMap[key], 
                    elementsToRemove = getBlockElements(block.clone), $animate.leave(elementsToRemove), 
                    forEach(elementsToRemove, function(element) {
                        element[NG_REMOVED] = !0;
                    }), block.scope.$destroy());
                    for (index = 0, length = collectionKeys.length; length > index; index++) {
                        if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], 
                        block = nextBlockOrder[index], nextBlockOrder[index - 1] && (previousNode = getBlockEnd(nextBlockOrder[index - 1])), 
                        block.scope) {
                            childScope = block.scope, nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) != nextNode && $animate.move(getBlockElements(block.clone), null, jqLite(previousNode)), 
                            previousNode = getBlockEnd(block);
                        } else childScope = $scope.$new();
                        childScope[valueIdentifier] = value, keyIdentifier && (childScope[keyIdentifier] = key), 
                        childScope.$index = index, childScope.$first = 0 === index, childScope.$last = index === arrayLength - 1, 
                        childScope.$middle = !(childScope.$first || childScope.$last), childScope.$odd = !(childScope.$even = 0 === (1 & index)), 
                        block.scope || $transclude(childScope, function(clone) {
                            clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " "), 
                            $animate.enter(clone, null, jqLite(previousNode)), previousNode = clone, block.scope = childScope, 
                            block.clone = clone, nextBlockMap[block.id] = block;
                        });
                    }
                    lastBlockMap = nextBlockMap;
                });
            }
        };
    } ], ngShowDirective = [ "$animate", function($animate) {
        return function(scope, element, attr) {
            scope.$watch(attr.ngShow, function(value) {
                $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide");
            });
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return function(scope, element, attr) {
            scope.$watch(attr.ngHide, function(value) {
                $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide");
            });
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousElements = [], selectedScopes = [];
                scope.$watch(watchExpr, function(value) {
                    var i, ii;
                    for (i = 0, ii = previousElements.length; ii > i; ++i) previousElements[i].remove();
                    for (previousElements.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = selectedElements[i];
                        selectedScopes[i].$destroy(), previousElements[i] = selected, $animate.leave(selected, function() {
                            previousElements.splice(i, 1);
                        });
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && (scope.$eval(attr.change), 
                    forEach(selectedTranscludes, function(selectedTransclude) {
                        var selectedScope = scope.$new();
                        selectedScopes.push(selectedScope), selectedTransclude.transclude(selectedScope, function(caseElement) {
                            var anchor = selectedTransclude.element;
                            selectedElements.push(caseElement), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    }));
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], 
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeDirective = ngDirective({
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    }), scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" == attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], ngOptionsMinErr = minErr("ngOptions"), ngOptionsDirective = valueFn({
        terminal: !0
    }), selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var nullOption, unknownOption, self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl;
                self.databound = $attrs.ngModel, self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_, nullOption = nullOption_, unknownOption = unknownOption_;
                }, self.addOption = function(value) {
                    assertNotHasOwnProperty(value, '"option value"'), optionsMap[value] = !0, ngModelCtrl.$viewValue == value && ($element.val(value), 
                    unknownOption.parent() && unknownOption.remove());
                }, self.removeOption = function(value) {
                    this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue == value && this.renderUnknownOption(value));
                }, self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal), $element.prepend(unknownOption), $element.val(unknownVal), 
                    unknownOption.prop("selected", !0);
                }, self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                }, $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), 
                        selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) : isUndefined(viewValue) && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue);
                    }, selectElement.on("change", function() {
                        scope.$apply(function() {
                            unknownOption.parent() && unknownOption.remove(), ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    }, scope.$watch(function() {
                        equals(lastView, ctrl.$viewValue) || (lastView = shallowCopy(ctrl.$viewValue), ctrl.$render());
                    }), selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                option.selected && array.push(option.value);
                            }), ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    function render() {
                        var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, locals = {}, selectedSet = !1;
                        if (multiple) if (trackFn && isArray(modelValue)) {
                            selectedSet = new HashMap([]);
                            for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) locals[valueName] = modelValue[trackIndex], 
                            selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
                        } else selectedSet = new HashMap(modelValue);
                        for (index = 0; length = keys.length, length > index; index++) {
                            if (key = index, keyName) {
                                if (key = keys[index], "$" === key.charAt(0)) continue;
                                locals[keyName] = key;
                            }
                            if (locals[valueName] = values[key], optionGroupName = groupByFn(scope, locals) || "", 
                            (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], 
                            optionGroupNames.push(optionGroupName)), multiple) selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals))); else {
                                if (trackFn) {
                                    var modelCast = {};
                                    modelCast[valueName] = modelValue, selected = trackFn(scope, modelCast) === trackFn(scope, locals);
                                } else selected = modelValue === valueFn(scope, locals);
                                selectedSet = selectedSet || selected;
                            }
                            label = displayFn(scope, locals), label = isDefined(label) ? label : "", optionGroup.push({
                                id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                label: label,
                                selected: selected
                            });
                        }
                        for (multiple || (nullOption || null === modelValue ? optionGroups[""].unshift({
                            id: "",
                            label: "",
                            selected: !selectedSet
                        }) : selectedSet || optionGroups[""].unshift({
                            id: "?",
                            label: "",
                            selected: !0
                        })), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
                            for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], 
                            optionGroupsCache.length <= groupIndex ? (existingParent = {
                                element: optGroupTemplate.clone().attr("label", optionGroupName),
                                label: optionGroup.label
                            }, existingOptions = [ existingParent ], optionGroupsCache.push(existingOptions), 
                            selectElement.append(existingParent.element)) : (existingOptions = optionGroupsCache[groupIndex], 
                            existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), 
                            lastElement = null, index = 0, length = optionGroup.length; length > index; index++) option = optionGroup[index], 
                            (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, 
                            existingOption.label !== option.label && lastElement.text(existingOption.label = option.label), 
                            existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), 
                            existingOption.selected !== option.selected && (lastElement.prop("selected", existingOption.selected = option.selected), 
                            msie && lastElement.prop("selected", existingOption.selected))) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).text(option.label), 
                            existingOptions.push(existingOption = {
                                element: element,
                                label: option.label,
                                id: option.id,
                                selected: option.selected
                            }), lastElement ? lastElement.after(element) : existingParent.element.append(element), 
                            lastElement = element);
                            for (index++; existingOptions.length > index; ) existingOptions.pop().element.remove();
                        }
                        for (;optionGroupsCache.length > groupIndex; ) optionGroupsCache.pop()[0].element.remove();
                    }
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ];
                    nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), 
                    nullOption.remove()), selectElement.empty(), selectElement.on("change", function() {
                        scope.$apply(function() {
                            var optionGroup, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex, collection = valuesFn(scope) || [], locals = {};
                            if (multiple) {
                                for (value = [], groupIndex = 0, groupLength = optionGroupsCache.length; groupLength > groupIndex; groupIndex++) for (optionGroup = optionGroupsCache[groupIndex], 
                                index = 1, length = optionGroup.length; length > index; index++) if ((optionElement = optionGroup[index].element)[0].selected) {
                                    if (key = optionElement.val(), keyName && (locals[keyName] = key), trackFn) for (trackIndex = 0; trackIndex < collection.length && (locals[valueName] = collection[trackIndex], 
                                    trackFn(scope, locals) != key); trackIndex++) ; else locals[valueName] = collection[key];
                                    value.push(valueFn(scope, locals));
                                }
                            } else {
                                if (key = selectElement.val(), "?" == key) value = undefined; else if ("" === key) value = null; else if (trackFn) {
                                    for (trackIndex = 0; trackIndex < collection.length; trackIndex++) if (locals[valueName] = collection[trackIndex], 
                                    trackFn(scope, locals) == key) {
                                        value = valueFn(scope, locals);
                                        break;
                                    }
                                } else locals[valueName] = collection[key], keyName && (locals[keyName] = key), 
                                value = valueFn(scope, locals);
                                optionGroupsCache[0].length > 1 && optionGroupsCache[0][1].id !== key && (optionGroupsCache[0][1].selected = !1);
                            }
                            ctrl.$setViewValue(value);
                        });
                    }), ctrl.$render = render, scope.$watch(render);
                }
                if (ctrls[1]) {
                    for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                    selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length;
                    }), optionsExp ? setupAsOptions(scope, element, ngModelCtrl) : multiple ? setupAsMultiple(scope, element, ngModelCtrl) : setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                }
            }
        };
    } ], optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), !0);
                    interpolateFn || attr.$set("value", element.text());
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    selectCtrl && selectCtrl.databound ? element.prop("selected", !1) : selectCtrl = nullSelectCtrl, 
                    interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
                        attr.$set("value", newVal), newVal !== oldVal && selectCtrl.removeOption(oldVal), 
                        selectCtrl.addOption(newVal);
                    }) : selectCtrl.addOption(attr.value), element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ], styleDirective = valueFn({
        restrict: "E",
        terminal: !0
    });
    return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), 
    publishExternalAPI(angular), void jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    }));
}(window, document), !window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>'), 
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(window, angular, undefined) {
    "use strict";
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst.hasOwnProperty(key) || (dst[key] = value);
            });
        }), dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function arraySearch(array, value) {
        if (Array.prototype.indexOf) return array.indexOf(value, Number(arguments[2]) || 0);
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        for (from = 0 > from ? Math.ceil(from) : Math.floor(from), 0 > from && (from += len); len > from; from++) if (from in array && array[from] === value) return from;
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parentParams, parents = ancestors($current, $to), inherited = {}, inheritList = [];
        for (var i in parents) if (parents[i].params && parents[i].params.length) {
            parentParams = parents[i].params;
            for (var j in parentParams) arraySearch(inheritList, parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), 
            inherited[parentParams[j]] = currentParams[parentParams[j]]);
        }
        return extend({}, inherited, newParams);
    }
    function normalize(keys, values) {
        var normalized = {};
        return forEach(keys, function(name) {
            var value = values[name];
            normalized[name] = null != value ? String(value) : null;
        }), normalized;
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return !1;
        }
        return !0;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        return forEach(keys, function(name) {
            filtered[name] = values[name];
        }), filtered;
    }
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            function visit(value, key) {
                if (visited[key] !== VISIT_DONE) {
                    if (cycle.push(key), visited[key] === VISIT_IN_PROGRESS) throw cycle.splice(0, cycle.indexOf(key)), 
                    new Error("Cyclic dependency: " + cycle.join(" -> "));
                    if (visited[key] = VISIT_IN_PROGRESS, isString(value)) plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES); else {
                        var params = $injector.annotate(value);
                        forEach(params, function(param) {
                            param !== key && invocables.hasOwnProperty(param) && visit(invocables[param], param);
                        }), plan.push(key, value, params);
                    }
                    cycle.pop(), visited[key] = VISIT_DONE;
                }
            }
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var plan = [], cycle = [], visited = {};
            return forEach(invocables, visit), invocables = cycle = visited = null, function(locals, parent, self) {
                function done() {
                    --wait || (merged || merge(values, parent.$$values), result.$$values = values, result.$$promises = !0, 
                    resolution.resolve(values));
                }
                function fail(reason) {
                    result.$$failure = reason, resolution.reject(reason);
                }
                function invoke(key, invocable, params) {
                    function onfailure(reason) {
                        invocation.reject(reason), fail(reason);
                    }
                    function proceed() {
                        if (!isDefined(result.$$failure)) try {
                            invocation.resolve($injector.invoke(invocable, self, values)), invocation.promise.then(function(result) {
                                values[key] = result, done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    var invocation = $q.defer(), waitParams = 0;
                    forEach(params, function(dep) {
                        promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep) && (waitParams++, promises[dep].then(function(result) {
                            values[dep] = result, --waitParams || proceed();
                        }, onfailure));
                    }), waitParams || proceed(), promises[key] = invocation.promise;
                }
                if (isResolve(locals) && self === undefined && (self = parent, parent = locals, 
                locals = null), locals) {
                    if (!isObject(locals)) throw new Error("'locals' must be an object");
                } else locals = NO_LOCALS;
                if (parent) {
                    if (!isResolve(parent)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else parent = NO_PARENT;
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = !1;
                if (isDefined(parent.$$failure)) return fail(parent.$$failure), result;
                parent.$$values ? (merged = merge(values, parent.$$values), done()) : (extend(promises, parent.$$promises), 
                parent.then(done, fail));
                for (var i = 0, ii = plan.length; ii > i; i += 3) locals.hasOwnProperty(plan[i]) ? done() : invoke(plan[i], plan[i + 1], plan[i + 2]);
                return result;
            };
        }, this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        }, this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        }, this.fromUrl = function(url, params) {
            return isFunction(url) && (url = url(params)), null == url ? null : $http.get(url, {
                cache: $templateCache
            }).then(function(response) {
                return response.data;
            });
        }, this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    function UrlMatcher(pattern) {
        function addParameter(id) {
            if (!/^\w+(-+\w+)*$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (names[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            names[id] = !0, params.push(id);
        }
        function quoteRegExp(string) {
            return string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
        }
        var m, placeholder = /([:*])(\w+)|\{(\w+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, names = {}, compiled = "^", last = 0, segments = this.segments = [], params = this.params = [];
        this.source = pattern;
        for (var id, regexp, segment; (m = placeholder.exec(pattern)) && (id = m[2] || m[3], 
        regexp = m[4] || ("*" == m[1] ? ".*" : "[^/]*"), segment = pattern.substring(last, m.index), 
        !(segment.indexOf("?") >= 0)); ) compiled += quoteRegExp(segment) + "(" + regexp + ")", 
        addParameter(id), segments.push(segment), last = placeholder.lastIndex;
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i), this.sourcePath = pattern.substring(0, last + i), 
            forEach(search.substring(1).split(/[&?]/), addParameter);
        } else this.sourcePath = pattern, this.sourceSearch = "";
        compiled += quoteRegExp(segment) + "$", segments.push(segment), this.regexp = new RegExp(compiled), 
        this.prefix = segments[0];
    }
    function $UrlMatcherFactory() {
        this.compile = function(pattern) {
            return new UrlMatcher(pattern);
        }, this.isMatcher = function(o) {
            return isObject(o) && isFunction(o.exec) && isFunction(o.format) && isFunction(o.concat);
        }, this.$get = function() {
            return this;
        };
    }
    function $UrlRouterProvider($urlMatcherFactory) {
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return null != prefix ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match["$" === what ? 0 : Number(what)];
            });
        }
        function handleIfMatch($injector, handler, match) {
            if (!match) return !1;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : !0;
        }
        var rules = [], otherwise = null;
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return rules.push(rule), this;
        }, this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return otherwise = rule, this;
        }, this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what) && (what = $urlMatcherFactory.compile(what)), !handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    return handlerIsString && (redirect = $urlMatcherFactory.compile(handler), handler = [ "$match", function($match) {
                        return redirect.format($match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return handlerIsString && (redirect = handler, handler = [ "$match", function($match) {
                        return interpolate(redirect, $match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            }, check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) if (check[n]) return this.rule(strategies[n](what, handler));
            throw new Error("invalid 'what' in when()");
        }, this.$get = [ "$location", "$rootScope", "$injector", function($location, $rootScope, $injector) {
            function update(evt) {
                function check(rule) {
                    var handled = rule($injector, $location);
                    return handled ? (isString(handled) && $location.replace().url(handled), !0) : !1;
                }
                if (!evt || !evt.defaultPrevented) {
                    var i, n = rules.length;
                    for (i = 0; n > i; i++) if (check(rules[i])) return;
                    otherwise && check(otherwise);
                }
            }
            return $rootScope.$on("$locationChangeSuccess", update), {
                sync: function() {
                    update();
                }
            };
        } ];
    }
    function $StateProvider($urlRouterProvider, $urlMatcherFactory, $locationProvider) {
        function isRelative(stateName) {
            return 0 === stateName.indexOf(".") || 0 === stateName.indexOf("^");
        }
        function findState(stateOrName, base) {
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                for (var rel = name.split("."), i = 0, pathLength = rel.length, current = base; pathLength > i; i++) if ("" !== rel[i] || 0 !== i) {
                    if ("^" !== rel[i]) break;
                    if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                    current = current.parent;
                } else current = base;
                rel = rel.slice(i).join("."), name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            return !state || !isStr && (isStr || state !== stateOrName && state.self !== stateOrName) ? undefined : state;
        }
        function queueState(parentName, state) {
            queue[parentName] || (queue[parentName] = []), queue[parentName].push(state);
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = -1 !== name.indexOf(".") ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : "";
            if (parentName && !states[parentName]) return queueState(parentName, state.self);
            for (var key in stateBuilder) isFunction(stateBuilder[key]) && (state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]));
            if (states[name] = state, !state[abstractKey] && state.url && $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                $state.$current.navigable == state && equalForKeys($match, $stateParams) || $state.transitionTo(state, $match, {
                    location: !1
                });
            } ]), queue[name]) for (var i = 0; i < queue[name].length; i++) registerState(queue[name][i]);
            return state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".");
            if ("**" === globSegments[0] && (segments = segments.slice(segments.indexOf(globSegments[1])), 
            segments.unshift("**")), "**" === globSegments[globSegments.length - 1] && (segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE), 
            segments.push("**")), globSegments.length != segments.length) return !1;
            for (var i = 0, l = globSegments.length; l > i; i++) "*" === globSegments[i] && (segments[i] = "*");
            return segments.join("") === globSegments.join("");
        }
        function decorator(name, func) {
            return isString(name) && !isDefined(func) ? stateBuilder[name] : isFunction(func) && isString(name) ? (stateBuilder[name] && !stateBuilder.$delegates[name] && (stateBuilder.$delegates[name] = stateBuilder[name]), 
            stateBuilder[name] = func, this) : this;
        }
        function state(name, definition) {
            return isObject(name) ? definition = name : definition.name = name, registerState(definition), 
            this;
        }
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $location, $urlRouter, $browser) {
            function syncUrl() {
                $location.url() !== currentLocation && ($location.url(currentLocation), $location.replace());
            }
            function resolveState(state, params, paramsAreFiltered, inherited, dst) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params, params), locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                return inherited && promises.push(inherited), forEach(state.views, function(view, name) {
                    var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                    injectables.$template = [ function() {
                        return $view.load(name, {
                            view: view,
                            locals: locals,
                            params: $stateParams,
                            notify: !1
                        }) || "";
                    } ], promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                            var injectLocals = angular.extend({}, injectables, locals);
                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                        } else result.$$controller = view.controller;
                        result.$$state = state, result.$$controllerAs = view.controllerAs, dst[name] = result;
                    }));
                }), $q.all(promises).then(function() {
                    return dst;
                });
            }
            var TransitionSuperseded = $q.reject(new Error("transition superseded")), TransitionPrevented = $q.reject(new Error("transition prevented")), TransitionAborted = $q.reject(new Error("transition aborted")), TransitionFailed = $q.reject(new Error("transition failed")), currentLocation = $location.url(), baseHref = $browser.baseHref();
            return root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            }, $state.reload = function() {
                $state.transitionTo($state.current, $stateParams, {
                    reload: !0,
                    inherit: !1,
                    notify: !1
                });
            }, $state.go = function(to, params, options) {
                return this.transitionTo(to, params, extend({
                    inherit: !0,
                    relative: $state.$current
                }, options));
            }, $state.transitionTo = function(to, toParams, options) {
                toParams = toParams || {}, options = extend({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, options || {});
                var evt, from = $state.$current, fromParams = $state.params, fromPath = from.path, toState = findState(to, options.relative);
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    };
                    if (evt = $rootScope.$broadcast("$stateNotFound", redirect, from.self, fromParams), 
                    evt.defaultPrevented) return syncUrl(), TransitionAborted;
                    if (evt.retry) {
                        if (options.$retry) return syncUrl(), TransitionFailed;
                        var retryTransition = $state.transition = $q.when(evt.retry);
                        return retryTransition.then(function() {
                            return retryTransition !== $state.transition ? TransitionSuperseded : (redirect.options.$retry = !0, 
                            $state.transitionTo(redirect.to, redirect.toParams, redirect.options));
                        }, function() {
                            return TransitionAborted;
                        }), syncUrl(), retryTransition;
                    }
                    if (to = redirect.to, toParams = redirect.toParams, options = redirect.options, 
                    toState = findState(to, options.relative), !isDefined(toState)) {
                        if (options.relative) throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                        throw new Error("No such state '" + to + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                options.inherit && (toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)), 
                to = toState;
                var keep, state, toPath = to.path, locals = root.locals, toLocals = [];
                for (keep = 0, state = toPath[keep]; state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams) && !options.reload; keep++, 
                state = toPath[keep]) locals = toLocals[keep] = state.locals;
                if (shouldTriggerReload(to, from, locals, options)) return to.self.reloadOnSearch !== !1 && syncUrl(), 
                $state.transition = null, $q.when($state.current);
                if (toParams = normalize(to.params, toParams || {}), options.notify && (evt = $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams), 
                evt.defaultPrevented)) return syncUrl(), TransitionPrevented;
                for (var resolved = $q.when(locals), l = keep; l < toPath.length; l++, state = toPath[l]) locals = toLocals[l] = inherit(locals), 
                resolved = resolveState(state, toParams, state === to, resolved, locals);
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) exiting = fromPath[l], exiting.self.onExit && $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals), 
                    exiting.locals = null;
                    for (l = keep; l < toPath.length; l++) entering = toPath[l], entering.locals = toLocals[l], 
                    entering.self.onEnter && $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.$current = to, $state.current = to.self, $state.params = toParams, copy($state.params, $stateParams), 
                    $state.transition = null;
                    var toNav = to.navigable;
                    return options.location && toNav && ($location.url(toNav.url.format(toNav.locals.globals.$stateParams)), 
                    "replace" === options.location && $location.replace()), options.notify && $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams), 
                    currentLocation = $location.url(), $state.current;
                }, function(error) {
                    return $state.transition !== transition ? TransitionSuperseded : ($state.transition = null, 
                    $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error), 
                    syncUrl(), $q.reject(error));
                });
                return transition;
            }, $state.is = function(stateOrName, params) {
                var state = findState(stateOrName);
                return isDefined(state) ? $state.$current !== state ? !1 : isDefined(params) && null !== params ? angular.equals($stateParams, params) : !0 : undefined;
            }, $state.includes = function(stateOrName, params) {
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) return !1;
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName);
                if (!isDefined(state)) return undefined;
                if (!isDefined($state.$current.includes[state.name])) return !1;
                var validParams = !0;
                return angular.forEach(params, function(value, key) {
                    isDefined($stateParams[key]) && $stateParams[key] === value || (validParams = !1);
                }), validParams;
            }, $state.href = function(stateOrName, params, options) {
                options = extend({
                    lossy: !0,
                    inherit: !1,
                    absolute: !1,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                params = inheritParams($stateParams, params || {}, $state.$current, state);
                var nav = state && options.lossy ? state.navigable : state, url = nav && nav.url ? nav.url.format(normalize(state.params, params || {})) : null;
                return !$locationProvider.html5Mode() && url && (url = "#" + $locationProvider.hashPrefix() + url), 
                "/" !== baseHref && ($locationProvider.html5Mode() ? url = baseHref.slice(0, -1) + url : options.absolute && (url = baseHref.slice(1) + url)), 
                options.absolute && url && (url = $location.protocol() + "://" + $location.host() + (80 == $location.port() || 443 == $location.port() ? "" : ":" + $location.port()) + (!$locationProvider.html5Mode() && url ? "/" : "") + url), 
                url;
            }, $state.get = function(stateOrName, context) {
                if (!isDefined(stateOrName)) {
                    var list = [];
                    return forEach(states, function(state) {
                        list.push(state.self);
                    }), list;
                }
                var state = findState(stateOrName, context);
                return state && state.self ? state.self : null;
            }, $state;
        }
        function shouldTriggerReload(to, from, locals, options) {
            return to !== from || (locals !== from.locals || options.reload) && to.self.reloadOnSearch !== !1 ? void 0 : !0;
        }
        var root, $state, states = {}, queue = {}, abstractKey = "abstract", stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                return state.parent && state.parent.data && (state.data = state.self.data = extend({}, state.parent.data, state.data)), 
                state.data;
            },
            url: function(state) {
                var url = state.url;
                if (isString(url)) return "^" == url.charAt(0) ? $urlMatcherFactory.compile(url.substring(1)) : (state.parent.navigable || root).url.concat(url);
                if ($urlMatcherFactory.isMatcher(url) || null == url) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            params: function(state) {
                if (!state.params) return state.url ? state.url.parameters() : state.parent.params;
                if (!isArray(state.params)) throw new Error("Invalid params in state '" + state + "'");
                if (state.url) throw new Error("Both params and url specicified in state '" + state + "'");
                return state.params;
            },
            views: function(state) {
                var views = {};
                return forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    name.indexOf("@") < 0 && (name += "@" + state.parent.name), views[name] = view;
                }), views;
            },
            ownParams: function(state) {
                if (!state.parent) return state.params;
                var paramNames = {};
                forEach(state.params, function(p) {
                    paramNames[p] = !0;
                }), forEach(state.parent.params, function(p) {
                    if (!paramNames[p]) throw new Error("Missing required parameter '" + p + "' in state '" + state.name + "'");
                    paramNames[p] = !1;
                });
                var ownParams = [];
                return forEach(paramNames, function(own, p) {
                    own && ownParams.push(p);
                }), ownParams;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                return includes[state.name] = !0, includes;
            },
            $delegates: {}
        };
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": !0
        }), root.navigable = null, this.decorator = decorator, this.state = state, this.$get = $get, 
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$location", "$urlRouter", "$browser" ];
    }
    function $ViewProvider() {
        function $get($rootScope, $templateFactory) {
            return {
                load: function(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return options = extend(defaults, options), options.view && (result = $templateFactory.fromConfig(options.view, options.params, options.locals)), 
                    result && options.notify && $rootScope.$broadcast("$viewContentLoading", options), 
                    result;
                }
            };
        }
        this.$get = $get, $get.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function $ViewScrollProvider() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function $ViewDirective($state, $injector, $uiViewScroll) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element), cb();
                    },
                    leave: function(element, cb) {
                        element.remove(), cb();
                    }
                };
            };
            if ($animate) return {
                enter: function(element, target, cb) {
                    $animate.enter(element, null, target, cb);
                },
                leave: function(element, cb) {
                    $animate.leave(element, cb);
                }
            };
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target), cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element), cb();
                    }
                };
            }
            return statics();
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate"), directive = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    function cleanupLastView() {
                        previousEl && (previousEl.remove(), previousEl = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentEl && (renderer.leave(currentEl, function() {
                            previousEl = null;
                        }), previousEl = currentEl, currentEl = null);
                    }
                    function updateView(firstTime) {
                        var newScope = scope.$new(), name = currentEl && currentEl.data("$uiViewName"), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (firstTime || previousLocals !== latestLocals) {
                            var clone = $transclude(newScope, function(clone) {
                                renderer.enter(clone, $element, function() {
                                    (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone);
                                }), cleanupLastView();
                            });
                            latestLocals = $state.$current.locals[clone.data("$uiViewName")], currentEl = clone, 
                            currentScope = newScope, currentScope.$emit("$viewContentLoaded"), currentScope.$eval(onloadExp);
                        }
                    }
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(!1);
                    }), scope.$on("$viewContentLoading", function() {
                        updateView(!1);
                    }), updateView(!0);
                };
            }
        };
        return directive;
    }
    function $ViewDirectiveFill($compile, $controller, $state) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var name = attrs.uiView || attrs.name || "", inherited = $element.inheritedData("$uiView");
                    name.indexOf("@") < 0 && (name = name + "@" + (inherited ? inherited.state.name : "")), 
                    $element.data("$uiViewName", name);
                    var current = $state.$current, locals = current && current.locals[name];
                    if (locals) {
                        $element.data("$uiView", {
                            name: name,
                            state: locals.$$state
                        }), $element.html(locals.$template ? locals.$template : initial);
                        var link = $compile($element.contents());
                        if (locals.$$controller) {
                            locals.$scope = scope;
                            var controller = $controller(locals.$$controller, locals);
                            locals.$$controllerAs && (scope[locals.$$controllerAs] = controller), $element.data("$ngControllerController", controller), 
                            $element.children().data("$ngControllerController", controller);
                        }
                        link(scope);
                    }
                };
            }
        };
    }
    function parseStateRef(ref) {
        var parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        return stateData && stateData.state && stateData.state.name ? stateData.state : void 0;
    }
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = [ "location", "inherit", "reload" ];
        return {
            restrict: "A",
            require: "?^uiSrefActive",
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref), params = null, base = stateContext(element) || $state.$current, isForm = "FORM" === element[0].nodeName, attr = isForm ? "action" : "href", nav = !0, options = {
                    relative: base
                }, optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    option in optionsOverride && (options[option] = optionsOverride[option]);
                });
                var update = function(newVal) {
                    if (newVal && (params = newVal), nav) {
                        var newHref = $state.href(ref.state, params, options);
                        return uiSrefActive && uiSrefActive.$$setStateInfo(ref.state, params), newHref ? void (element[0][attr] = newHref) : (nav = !1, 
                        !1);
                    }
                };
                ref.paramExpr && (scope.$watch(ref.paramExpr, function(newVal) {
                    newVal !== params && update(newVal);
                }, !0), params = scope.$eval(ref.paramExpr)), update(), isForm || element.bind("click", function(e) {
                    var button = e.which || e.button;
                    button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target") || ($timeout(function() {
                        $state.go(ref.state, params, options);
                    }), e.preventDefault());
                });
            }
        };
    }
    function $StateActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                function update() {
                    $state.$current.self === state && matchesParams() ? $element.addClass(activeClass) : $element.removeClass(activeClass);
                }
                function matchesParams() {
                    return !params || equalForKeys(params, $stateParams);
                }
                var state, params, activeClass;
                activeClass = $interpolate($attrs.uiSrefActive || "", !1)($scope), this.$$setStateInfo = function(newState, newParams) {
                    state = $state.get(newState, stateContext($element)), params = newParams, update();
                }, $scope.$on("$stateChangeSuccess", update);
            } ]
        };
    }
    function $IsStateFilter($state) {
        return function(state) {
            return $state.is(state);
        };
    }
    function $IncludedByStateFilter($state) {
        return function(state) {
            return $state.includes(state);
        };
    }
    function $RouteProvider($stateProvider, $urlRouterProvider) {
        function onEnterRoute($$state) {
            this.locals = $$state.locals.globals, this.params = this.locals.$stateParams;
        }
        function onExitRoute() {
            this.locals = null, this.params = null;
        }
        function when(url, route) {
            if (null != route.redirectTo) {
                var handler, redirect = route.redirectTo;
                if (isString(redirect)) handler = redirect; else {
                    if (!isFunction(redirect)) throw new Error("Invalid 'redirectTo' in when()");
                    handler = function(params, $location) {
                        return redirect(params, $location.path(), $location.search());
                    };
                }
                $urlRouterProvider.when(url, handler);
            } else $stateProvider.state(inherit(route, {
                parent: null,
                name: "route:" + encodeURIComponent(url),
                url: url,
                onEnter: onEnterRoute,
                onExit: onExitRoute
            }));
            return routes.push(route), this;
        }
        function $get($state, $rootScope, $routeParams) {
            function stateAsRoute(state) {
                return "" !== state.name ? state : undefined;
            }
            var $route = {
                routes: routes,
                params: $routeParams,
                current: undefined
            };
            return $rootScope.$on("$stateChangeStart", function(ev, to, toParams, from) {
                $rootScope.$broadcast("$routeChangeStart", stateAsRoute(to), stateAsRoute(from));
            }), $rootScope.$on("$stateChangeSuccess", function(ev, to, toParams, from) {
                $route.current = stateAsRoute(to), $rootScope.$broadcast("$routeChangeSuccess", stateAsRoute(to), stateAsRoute(from)), 
                copy(toParams, $route.params);
            }), $rootScope.$on("$stateChangeError", function(ev, to, toParams, from, fromParams, error) {
                $rootScope.$broadcast("$routeChangeError", stateAsRoute(to), stateAsRoute(from), error);
            }), $route;
        }
        var routes = [];
        onEnterRoute.$inject = [ "$$state" ], this.when = when, this.$get = $get, $get.$inject = [ "$state", "$rootScope", "$routeParams" ];
    }
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
    angular.module("ui.router.util", [ "ng" ]), angular.module("ui.router.router", [ "ui.router.util" ]), 
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), angular.module("ui.router", [ "ui.router.state" ]), 
    angular.module("ui.router.compat", [ "ui.router" ]), $Resolve.$inject = [ "$q", "$injector" ], 
    angular.module("ui.router.util").service("$resolve", $Resolve), $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ], 
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory), 
    UrlMatcher.prototype.concat = function(pattern) {
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch);
    }, UrlMatcher.prototype.toString = function() {
        return this.source;
    }, UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        var i, params = this.params, nTotal = params.length, nPath = this.segments.length - 1, values = {};
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        for (i = 0; nPath > i; i++) values[params[i]] = m[i + 1];
        for (;nTotal > i; i++) values[params[i]] = searchParams[params[i]];
        return values;
    }, UrlMatcher.prototype.parameters = function() {
        return this.params;
    }, UrlMatcher.prototype.format = function(values) {
        var segments = this.segments, params = this.params;
        if (!values) return segments.join("");
        var i, search, value, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        for (i = 0; nPath > i; i++) value = values[params[i]], null != value && (result += encodeURIComponent(value)), 
        result += segments[i + 1];
        for (;nTotal > i; i++) value = values[params[i]], null != value && (result += (search ? "&" : "?") + params[i] + "=" + encodeURIComponent(value), 
        search = !0);
        return result;
    }, angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory), 
    $UrlRouterProvider.$inject = [ "$urlMatcherFactoryProvider" ], angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider), 
    $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider", "$locationProvider" ], 
    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider), 
    $ViewProvider.$inject = [], angular.module("ui.router.state").provider("$view", $ViewProvider), 
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider), 
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll" ], $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state" ], 
    angular.module("ui.router.state").directive("uiView", $ViewDirective), angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill), 
    $StateRefDirective.$inject = [ "$state", "$timeout" ], $StateActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateActiveDirective), 
    $IsStateFilter.$inject = [ "$state" ], $IncludedByStateFilter.$inject = [ "$state" ], 
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter), 
    $RouteProvider.$inject = [ "$stateProvider", "$urlRouterProvider" ], angular.module("ui.router.compat").provider("$route", $RouteProvider).directive("ngView", $ViewDirective);
}(window, window.angular);

var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;

(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
    "use strict";
    _gsScope._gsDefine("plugins.CSSPlugin", [ "plugins.TweenPlugin", "TweenLite" ], function(TweenPlugin, TweenLite) {
        var _hasPriority, _suffixMap, _cs, _overwriteProps, CSSPlugin = function() {
            TweenPlugin.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = CSSPlugin.prototype.setRatio;
        }, _specialProps = {}, p = CSSPlugin.prototype = new TweenPlugin("css");
        p.constructor = CSSPlugin, CSSPlugin.version = "1.13.0", CSSPlugin.API = 2, CSSPlugin.defaultTransformPerspective = 0, 
        CSSPlugin.defaultSkewType = "compensated", p = "px", CSSPlugin.suffixMap = {
            top: p,
            right: p,
            bottom: p,
            left: p,
            width: p,
            height: p,
            fontSize: p,
            padding: p,
            margin: p,
            perspective: p,
            lineHeight: ""
        };
        var _autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g, _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, _NaNExp = /[^\d\-\.]/g, _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g, _opacityExp = /opacity *= *([^)]*)/i, _opacityValExp = /opacity:([^;]*)/i, _alphaFilterExp = /alpha\(opacity *=.+?\)/i, _rgbhslExp = /^(rgb|hsl)/, _capsExp = /([A-Z])/g, _camelExp = /-([a-z])/gi, _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, _camelFunc = function(s, g) {
            return g.toUpperCase();
        }, _horizExp = /(?:Left|Right|Width)/i, _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, _DEG2RAD = Math.PI / 180, _RAD2DEG = 180 / Math.PI, _forcePT = {}, _doc = document, _tempDiv = _doc.createElement("div"), _tempImg = _doc.createElement("img"), _internals = CSSPlugin._internals = {
            _specialProps: _specialProps
        }, _agent = navigator.userAgent, _supportsOpacity = function() {
            var a, i = _agent.indexOf("Android"), d = _doc.createElement("div");
            return _isSafari = -1 !== _agent.indexOf("Safari") && -1 === _agent.indexOf("Chrome") && (-1 === i || Number(_agent.substr(i + 8, 1)) > 3), 
            _isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6, 
            _isFirefox = -1 !== _agent.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) && (_ieVers = parseFloat(RegExp.$1)), 
            d.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", a = d.getElementsByTagName("a")[0], 
            a ? /^0.55/.test(a.style.opacity) : !1;
        }(), _getIEOpacity = function(v) {
            return _opacityExp.test("string" == typeof v ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
        }, _log = function(s) {
            window.console && console.log(s);
        }, _prefixCSS = "", _prefix = "", _checkPropPrefix = function(p, e) {
            e = e || _tempDiv;
            var a, i, s = e.style;
            if (void 0 !== s[p]) return p;
            for (p = p.charAt(0).toUpperCase() + p.substr(1), a = [ "O", "Moz", "ms", "Ms", "Webkit" ], 
            i = 5; --i > -1 && void 0 === s[a[i] + p]; ) ;
            return i >= 0 ? (_prefix = 3 === i ? "ms" : a[i], _prefixCSS = "-" + _prefix.toLowerCase() + "-", 
            _prefix + p) : null;
        }, _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {}, _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
            var rv;
            return _supportsOpacity || "opacity" !== p ? (!calc && t.style[p] ? rv = t.style[p] : (cs = cs || _getComputedStyle(t)) ? rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase()) : t.currentStyle && (rv = t.currentStyle[p]), 
            null == dflt || rv && "none" !== rv && "auto" !== rv && "auto auto" !== rv ? rv : dflt) : _getIEOpacity(t);
        }, _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
            if ("px" === sfx || !sfx) return v;
            if ("auto" === sfx || !v) return 0;
            var pix, cache, time, horiz = _horizExp.test(p), node = t, style = _tempDiv.style, neg = 0 > v;
            if (neg && (v = -v), "%" === sfx && -1 !== p.indexOf("border")) pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight); else {
                if (style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;", 
                "%" !== sfx && node.appendChild) style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx; else {
                    if (node = t.parentNode || _doc.body, cache = node._gsCache, time = TweenLite.ticker.frame, 
                    cache && horiz && cache.time === time) return cache.width * v / 100;
                    style[horiz ? "width" : "height"] = v + sfx;
                }
                node.appendChild(_tempDiv), pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]), 
                node.removeChild(_tempDiv), horiz && "%" === sfx && CSSPlugin.cacheWidths !== !1 && (cache = node._gsCache = node._gsCache || {}, 
                cache.time = time, cache.width = pix / v * 100), 0 !== pix || recurse || (pix = _convertToPixels(t, p, v, sfx, !0));
            }
            return neg ? -pix : pix;
        }, _calculateOffset = _internals.calculateOffset = function(t, p, cs) {
            if ("absolute" !== _getStyle(t, "position", cs)) return 0;
            var dim = "left" === p ? "Left" : "Top", v = _getStyle(t, "margin" + dim, cs);
            return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
        }, _getAllStyles = function(t, cs) {
            var i, tr, s = {};
            if (cs = cs || _getComputedStyle(t, null)) if (i = cs.length) for (;--i > -1; ) s[cs[i].replace(_camelExp, _camelFunc)] = cs.getPropertyValue(cs[i]); else for (i in cs) s[i] = cs[i]; else if (cs = t.currentStyle || t.style) for (i in cs) "string" == typeof i && void 0 === s[i] && (s[i.replace(_camelExp, _camelFunc)] = cs[i]);
            return _supportsOpacity || (s.opacity = _getIEOpacity(t)), tr = _getTransform(t, cs, !1), 
            s.rotation = tr.rotation, s.skewX = tr.skewX, s.scaleX = tr.scaleX, s.scaleY = tr.scaleY, 
            s.x = tr.x, s.y = tr.y, _supports3D && (s.z = tr.z, s.rotationX = tr.rotationX, 
            s.rotationY = tr.rotationY, s.scaleZ = tr.scaleZ), s.filters && delete s.filters, 
            s;
        }, _cssDif = function(t, s1, s2, vars, forceLookup) {
            var val, p, mpt, difs = {}, style = t.style;
            for (p in s2) "cssText" !== p && "length" !== p && isNaN(p) && (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) && -1 === p.indexOf("Origin") && ("number" == typeof val || "string" == typeof val) && (difs[p] = "auto" !== val || "left" !== p && "top" !== p ? "" !== val && "auto" !== val && "none" !== val || "string" != typeof s1[p] || "" === s1[p].replace(_NaNExp, "") ? val : 0 : _calculateOffset(t, p), 
            void 0 !== style[p] && (mpt = new MiniPropTween(style, p, style[p], mpt)));
            if (vars) for (p in vars) "className" !== p && (difs[p] = vars[p]);
            return {
                difs: difs,
                firstMPT: mpt
            };
        }, _dimensions = {
            width: [ "Left", "Right" ],
            height: [ "Top", "Bottom" ]
        }, _margins = [ "marginLeft", "marginRight", "marginTop", "marginBottom" ], _getDimension = function(t, p, cs) {
            var v = parseFloat("width" === p ? t.offsetWidth : t.offsetHeight), a = _dimensions[p], i = a.length;
            for (cs = cs || _getComputedStyle(t, null); --i > -1; ) v -= parseFloat(_getStyle(t, "padding" + a[i], cs, !0)) || 0, 
            v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, !0)) || 0;
            return v;
        }, _parsePosition = function(v, recObj) {
            (null == v || "" === v || "auto" === v || "auto auto" === v) && (v = "0 0");
            var a = v.split(" "), x = -1 !== v.indexOf("left") ? "0%" : -1 !== v.indexOf("right") ? "100%" : a[0], y = -1 !== v.indexOf("top") ? "0%" : -1 !== v.indexOf("bottom") ? "100%" : a[1];
            return null == y ? y = "0" : "center" === y && (y = "50%"), ("center" === x || isNaN(parseFloat(x)) && -1 === (x + "").indexOf("=")) && (x = "50%"), 
            recObj && (recObj.oxp = -1 !== x.indexOf("%"), recObj.oyp = -1 !== y.indexOf("%"), 
            recObj.oxr = "=" === x.charAt(1), recObj.oyr = "=" === y.charAt(1), recObj.ox = parseFloat(x.replace(_NaNExp, "")), 
            recObj.oy = parseFloat(y.replace(_NaNExp, ""))), x + " " + y + (a.length > 2 ? " " + a[2] : "");
        }, _parseChange = function(e, b) {
            return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
        }, _parseVal = function(v, d) {
            return null == v ? d : "string" == typeof v && "=" === v.charAt(1) ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) + d : parseFloat(v);
        }, _parseAngle = function(v, d, p, directionalEnd) {
            var cap, split, dif, result, min = 1e-6;
            return null == v ? result = d : "number" == typeof v ? result = v : (cap = 360, 
            split = v.split("_"), dif = Number(split[0].replace(_NaNExp, "")) * (-1 === v.indexOf("rad") ? 1 : _RAD2DEG) - ("=" === v.charAt(1) ? 0 : d), 
            split.length && (directionalEnd && (directionalEnd[p] = d + dif), -1 !== v.indexOf("short") && (dif %= cap, 
            dif !== dif % (cap / 2) && (dif = 0 > dif ? dif + cap : dif - cap)), -1 !== v.indexOf("_cw") && 0 > dif ? dif = (dif + 9999999999 * cap) % cap - (dif / cap | 0) * cap : -1 !== v.indexOf("ccw") && dif > 0 && (dif = (dif - 9999999999 * cap) % cap - (dif / cap | 0) * cap)), 
            result = d + dif), min > result && result > -min && (result = 0), result;
        }, _colorLookup = {
            aqua: [ 0, 255, 255 ],
            lime: [ 0, 255, 0 ],
            silver: [ 192, 192, 192 ],
            black: [ 0, 0, 0 ],
            maroon: [ 128, 0, 0 ],
            teal: [ 0, 128, 128 ],
            blue: [ 0, 0, 255 ],
            navy: [ 0, 0, 128 ],
            white: [ 255, 255, 255 ],
            fuchsia: [ 255, 0, 255 ],
            olive: [ 128, 128, 0 ],
            yellow: [ 255, 255, 0 ],
            orange: [ 255, 165, 0 ],
            gray: [ 128, 128, 128 ],
            purple: [ 128, 0, 128 ],
            green: [ 0, 128, 0 ],
            red: [ 255, 0, 0 ],
            pink: [ 255, 192, 203 ],
            cyan: [ 0, 255, 255 ],
            transparent: [ 255, 255, 255, 0 ]
        }, _hue = function(h, m1, m2) {
            return h = 0 > h ? h + 1 : h > 1 ? h - 1 : h, 255 * (1 > 6 * h ? m1 + (m2 - m1) * h * 6 : .5 > h ? m2 : 2 > 3 * h ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) + .5 | 0;
        }, _parseColor = function(v) {
            var c1, c2, c3, h, s, l;
            return v && "" !== v ? "number" == typeof v ? [ v >> 16, v >> 8 & 255, 255 & v ] : ("," === v.charAt(v.length - 1) && (v = v.substr(0, v.length - 1)), 
            _colorLookup[v] ? _colorLookup[v] : "#" === v.charAt(0) ? (4 === v.length && (c1 = v.charAt(1), 
            c2 = v.charAt(2), c3 = v.charAt(3), v = "#" + c1 + c1 + c2 + c2 + c3 + c3), v = parseInt(v.substr(1), 16), 
            [ v >> 16, v >> 8 & 255, 255 & v ]) : "hsl" === v.substr(0, 3) ? (v = v.match(_numExp), 
            h = Number(v[0]) % 360 / 360, s = Number(v[1]) / 100, l = Number(v[2]) / 100, c2 = .5 >= l ? l * (s + 1) : l + s - l * s, 
            c1 = 2 * l - c2, v.length > 3 && (v[3] = Number(v[3])), v[0] = _hue(h + 1 / 3, c1, c2), 
            v[1] = _hue(h, c1, c2), v[2] = _hue(h - 1 / 3, c1, c2), v) : (v = v.match(_numExp) || _colorLookup.transparent, 
            v[0] = Number(v[0]), v[1] = Number(v[1]), v[2] = Number(v[2]), v.length > 3 && (v[3] = Number(v[3])), 
            v)) : _colorLookup.black;
        }, _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
        for (p in _colorLookup) _colorExp += "|" + p + "\\b";
        _colorExp = new RegExp(_colorExp + ")", "gi");
        var _getFormatter = function(dflt, clr, collapsible, multi) {
            if (null == dflt) return function(v) {
                return v;
            };
            var formatter, dColor = clr ? (dflt.match(_colorExp) || [ "" ])[0] : "", dVals = dflt.split(dColor).join("").match(_valuesExp) || [], pfx = dflt.substr(0, dflt.indexOf(dVals[0])), sfx = ")" === dflt.charAt(dflt.length - 1) ? ")" : "", delim = -1 !== dflt.indexOf(" ") ? " " : ",", numVals = dVals.length, dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "";
            return numVals ? formatter = clr ? function(v) {
                var color, vals, i, a;
                if ("number" == typeof v) v += dSfx; else if (multi && _commasOutsideParenExp.test(v)) {
                    for (a = v.replace(_commasOutsideParenExp, "|").split("|"), i = 0; i < a.length; i++) a[i] = formatter(a[i]);
                    return a.join(",");
                }
                if (color = (v.match(_colorExp) || [ dColor ])[0], vals = v.split(color).join("").match(_valuesExp) || [], 
                i = vals.length, numVals > i--) for (;++i < numVals; ) vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
                return pfx + vals.join(delim) + delim + color + sfx + (-1 !== v.indexOf("inset") ? " inset" : "");
            } : function(v) {
                var vals, a, i;
                if ("number" == typeof v) v += dSfx; else if (multi && _commasOutsideParenExp.test(v)) {
                    for (a = v.replace(_commasOutsideParenExp, "|").split("|"), i = 0; i < a.length; i++) a[i] = formatter(a[i]);
                    return a.join(",");
                }
                if (vals = v.match(_valuesExp) || [], i = vals.length, numVals > i--) for (;++i < numVals; ) vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
                return pfx + vals.join(delim) + sfx;
            } : function(v) {
                return v;
            };
        }, _getEdgeParser = function(props) {
            return props = props.split(","), function(t, e, p, cssp, pt, plugin, vars) {
                var i, a = (e + "").split(" ");
                for (vars = {}, i = 0; 4 > i; i++) vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
                return cssp.parse(t, vars, pt, plugin);
            };
        }, MiniPropTween = (_internals._setPluginRatio = function(v) {
            this.plugin.setRatio(v);
            for (var val, pt, i, str, d = this.data, proxy = d.proxy, mpt = d.firstMPT, min = 1e-6; mpt; ) val = proxy[mpt.v], 
            mpt.r ? val = Math.round(val) : min > val && val > -min && (val = 0), mpt.t[mpt.p] = val, 
            mpt = mpt._next;
            if (d.autoRotate && (d.autoRotate.rotation = proxy.rotation), 1 === v) for (mpt = d.firstMPT; mpt; ) {
                if (pt = mpt.t, pt.type) {
                    if (1 === pt.type) {
                        for (str = pt.xs0 + pt.s + pt.xs1, i = 1; i < pt.l; i++) str += pt["xn" + i] + pt["xs" + (i + 1)];
                        pt.e = str;
                    }
                } else pt.e = pt.s + pt.xs0;
                mpt = mpt._next;
            }
        }, function(t, p, v, next, r) {
            this.t = t, this.p = p, this.v = v, this.r = r, next && (next._prev = this, this._next = next);
        }), CSSPropTween = (_internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
            var i, p, xp, mpt, firstPT, bpt = pt, start = {}, end = {}, transform = cssp._transform, oldForce = _forcePT;
            for (cssp._transform = null, _forcePT = vars, pt = firstPT = cssp.parse(t, vars, pt, plugin), 
            _forcePT = oldForce, shallow && (cssp._transform = transform, bpt && (bpt._prev = null, 
            bpt._prev && (bpt._prev._next = null))); pt && pt !== bpt; ) {
                if (pt.type <= 1 && (p = pt.p, end[p] = pt.s + pt.c, start[p] = pt.s, shallow || (mpt = new MiniPropTween(pt, "s", p, mpt, pt.r), 
                pt.c = 0), 1 === pt.type)) for (i = pt.l; --i > 0; ) xp = "xn" + i, p = pt.p + "_" + xp, 
                end[p] = pt.data[xp], start[p] = pt[xp], shallow || (mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]));
                pt = pt._next;
            }
            return {
                proxy: start,
                end: end,
                firstMPT: mpt,
                pt: firstPT
            };
        }, _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
            this.t = t, this.p = p, this.s = s, this.c = c, this.n = n || p, t instanceof CSSPropTween || _overwriteProps.push(this.n), 
            this.r = r, this.type = type || 0, pr && (this.pr = pr, _hasPriority = !0), this.b = void 0 === b ? s : b, 
            this.e = void 0 === e ? s + c : e, next && (this._next = next, next._prev = this);
        }), _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
            b = b || dflt || "", pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, !1, pr, b, e), 
            e += "";
            var i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str, ba = b.split(", ").join(",").split(" "), ea = e.split(", ").join(",").split(" "), l = ba.length, autoRound = _autoRound !== !1;
            for ((-1 !== e.indexOf(",") || -1 !== b.indexOf(",")) && (ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" "), 
            ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" "), l = ba.length), 
            l !== ea.length && (ba = (dflt || "").split(" "), l = ba.length), pt.plugin = plugin, 
            pt.setRatio = setRatio, i = 0; l > i; i++) if (bv = ba[i], ev = ea[i], bn = parseFloat(bv), 
            bn || 0 === bn) pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && -1 !== ev.indexOf("px"), !0); else if (clrs && ("#" === bv.charAt(0) || _colorLookup[bv] || _rgbhslExp.test(bv))) str = "," === ev.charAt(ev.length - 1) ? ")," : ")", 
            bv = _parseColor(bv), ev = _parseColor(ev), rgba = bv.length + ev.length > 6, rgba && !_supportsOpacity && 0 === ev[3] ? (pt["xs" + pt.l] += pt.l ? " transparent" : "transparent", 
            pt.e = pt.e.split(ea[i]).join("transparent")) : (_supportsOpacity || (rgba = !1), 
            pt.appendXtra(rgba ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", !0, !0).appendXtra("", bv[1], ev[1] - bv[1], ",", !0).appendXtra("", bv[2], ev[2] - bv[2], rgba ? "," : str, !0), 
            rgba && (bv = bv.length < 4 ? 1 : bv[3], pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, !1))); else if (bnums = bv.match(_numExp)) {
                if (enums = ev.match(_relNumExp), !enums || enums.length !== bnums.length) return pt;
                for (ni = 0, xi = 0; xi < bnums.length; xi++) cv = bnums[xi], temp = bv.indexOf(cv, ni), 
                pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && "px" === bv.substr(temp + cv.length, 2), 0 === xi), 
                ni = temp + cv.length;
                pt["xs" + pt.l] += bv.substr(ni);
            } else pt["xs" + pt.l] += pt.l ? " " + bv : bv;
            if (-1 !== e.indexOf("=") && pt.data) {
                for (str = pt.xs0 + pt.data.s, i = 1; i < pt.l; i++) str += pt["xs" + i] + pt.data["xn" + i];
                pt.e = str + pt["xs" + i];
            }
            return pt.l || (pt.type = -1, pt.xs0 = pt.e), pt.xfirst || pt;
        }, i = 9;
        for (p = CSSPropTween.prototype, p.l = p.pr = 0; --i > 0; ) p["xn" + i] = 0, p["xs" + i] = "";
        p.xs0 = "", p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null, 
        p.appendXtra = function(pfx, s, c, sfx, r, pad) {
            var pt = this, l = pt.l;
            return pt["xs" + l] += pad && l ? " " + pfx : pfx || "", c || 0 === l || pt.plugin ? (pt.l++, 
            pt.type = pt.setRatio ? 2 : 1, pt["xs" + pt.l] = sfx || "", l > 0 ? (pt.data["xn" + l] = s + c, 
            pt.rxp["xn" + l] = r, pt["xn" + l] = s, pt.plugin || (pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr), 
            pt.xfirst.xs0 = 0), pt) : (pt.data = {
                s: s + c
            }, pt.rxp = {}, pt.s = s, pt.c = c, pt.r = r, pt)) : (pt["xs" + l] += s + (sfx || ""), 
            pt);
        };
        var SpecialProp = function(p, options) {
            options = options || {}, this.p = options.prefix ? _checkPropPrefix(p) || p : p, 
            _specialProps[p] = _specialProps[this.p] = this, this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi), 
            options.parser && (this.parse = options.parser), this.clrs = options.color, this.multi = options.multi, 
            this.keyword = options.keyword, this.dflt = options.defaultValue, this.pr = options.priority || 0;
        }, _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
            "object" != typeof options && (options = {
                parser: defaults
            });
            var i, temp, a = p.split(","), d = options.defaultValue;
            for (defaults = defaults || [ d ], i = 0; i < a.length; i++) options.prefix = 0 === i && options.prefix, 
            options.defaultValue = defaults[i] || d, temp = new SpecialProp(a[i], options);
        }, _registerPluginProp = function(p) {
            if (!_specialProps[p]) {
                var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
                _registerComplexSpecialProp(p, {
                    parser: function(t, e, p, cssp, pt, plugin, vars) {
                        var pluginClass = (_gsScope.GreenSockGlobals || _gsScope).com.greensock.plugins[pluginName];
                        return pluginClass ? (pluginClass._cssRegister(), _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars)) : (_log("Error: " + pluginName + " js file not loaded."), 
                        pt);
                    }
                });
            }
        };
        p = SpecialProp.prototype, p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
            var i, ba, ea, l, bi, ei, kwd = this.keyword;
            if (this.multi && (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b) ? (ba = b.replace(_commasOutsideParenExp, "|").split("|"), 
            ea = e.replace(_commasOutsideParenExp, "|").split("|")) : kwd && (ba = [ b ], ea = [ e ])), 
            ea) {
                for (l = ea.length > ba.length ? ea.length : ba.length, i = 0; l > i; i++) b = ba[i] = ba[i] || this.dflt, 
                e = ea[i] = ea[i] || this.dflt, kwd && (bi = b.indexOf(kwd), ei = e.indexOf(kwd), 
                bi !== ei && (e = -1 === ei ? ea : ba, e[i] += " " + kwd));
                b = ba.join(", "), e = ea.join(", ");
            }
            return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
        }, p.parse = function(t, e, p, cssp, pt, plugin) {
            return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, !1, this.dflt)), this.format(e), pt, plugin);
        }, CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
            _registerComplexSpecialProp(name, {
                parser: function(t, e, p, cssp, pt, plugin) {
                    var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, !1, priority);
                    return rv.plugin = plugin, rv.setRatio = onInitTween(t, e, cssp._tween, p), rv;
                },
                priority: priority
            });
        };
        var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), _transformProp = _checkPropPrefix("transform"), _transformPropCSS = _prefixCSS + "transform", _transformOriginProp = _checkPropPrefix("transformOrigin"), _supports3D = null !== _checkPropPrefix("perspective"), Transform = _internals.Transform = function() {
            this.skewY = 0;
        }, _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
            if (t._gsTransform && rec && !parse) return t._gsTransform;
            var s, m, i, n, dec, scaleX, scaleY, rotation, skewX, difX, difY, difR, difS, tm = rec ? t._gsTransform || new Transform() : new Transform(), invX = tm.scaleX < 0, min = 2e-5, rnd = 1e5, minAngle = 179.99, minPI = minAngle * _DEG2RAD, zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, !1, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0;
            if (_transformProp ? s = _getStyle(t, _transformPropCSS, cs, !0) : t.currentStyle && (s = t.currentStyle.filter.match(_ieGetMatrixExp), 
            s = s && 4 === s.length ? [ s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0 ].join(",") : ""), 
            s && "none" !== s && "matrix(1, 0, 0, 1, 0, 0)" !== s) {
                for (m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], i = m.length; --i > -1; ) n = Number(m[i]), 
                m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (0 > dec ? -.5 : .5) | 0) / rnd + n : n;
                if (16 === m.length) {
                    var a13 = m[8], a23 = m[9], a33 = m[10], a14 = m[12], a24 = m[13], a34 = m[14];
                    if (tm.zOrigin && (a34 = -tm.zOrigin, a14 = a13 * a34 - m[12], a24 = a23 * a34 - m[13], 
                    a34 = a33 * a34 + tm.zOrigin - m[14]), !rec || parse || null == tm.rotationX) {
                        var t1, t2, t3, cos, sin, yFlip, zFlip, a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3], a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7], a43 = m[11], angle = Math.atan2(a32, a33), xFlip = -minPI > angle || angle > minPI;
                        tm.rotationX = angle * _RAD2DEG, angle && (cos = Math.cos(-angle), sin = Math.sin(-angle), 
                        t1 = a12 * cos + a13 * sin, t2 = a22 * cos + a23 * sin, t3 = a32 * cos + a33 * sin, 
                        a13 = a12 * -sin + a13 * cos, a23 = a22 * -sin + a23 * cos, a33 = a32 * -sin + a33 * cos, 
                        a43 = a42 * -sin + a43 * cos, a12 = t1, a22 = t2, a32 = t3), angle = Math.atan2(a13, a11), 
                        tm.rotationY = angle * _RAD2DEG, angle && (yFlip = -minPI > angle || angle > minPI, 
                        cos = Math.cos(-angle), sin = Math.sin(-angle), t1 = a11 * cos - a13 * sin, t2 = a21 * cos - a23 * sin, 
                        t3 = a31 * cos - a33 * sin, a23 = a21 * sin + a23 * cos, a33 = a31 * sin + a33 * cos, 
                        a43 = a41 * sin + a43 * cos, a11 = t1, a21 = t2, a31 = t3), angle = Math.atan2(a21, a22), 
                        tm.rotation = angle * _RAD2DEG, angle && (zFlip = -minPI > angle || angle > minPI, 
                        cos = Math.cos(-angle), sin = Math.sin(-angle), a11 = a11 * cos + a12 * sin, t2 = a21 * cos + a22 * sin, 
                        a22 = a21 * -sin + a22 * cos, a32 = a31 * -sin + a32 * cos, a21 = t2), zFlip && xFlip ? tm.rotation = tm.rotationX = 0 : zFlip && yFlip ? tm.rotation = tm.rotationY = 0 : yFlip && xFlip && (tm.rotationY = tm.rotationX = 0), 
                        tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + .5 | 0) / rnd, tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + .5 | 0) / rnd, 
                        tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + .5 | 0) / rnd, tm.skewX = 0, 
                        tm.perspective = a43 ? 1 / (0 > a43 ? -a43 : a43) : 0, tm.x = a14, tm.y = a24, tm.z = a34;
                    }
                } else if (!(_supports3D && !parse && m.length && tm.x === m[4] && tm.y === m[5] && (tm.rotationX || tm.rotationY) || void 0 !== tm.x && "none" === _getStyle(t, "display", cs))) {
                    var k = m.length >= 6, a = k ? m[0] : 1, b = m[1] || 0, c = m[2] || 0, d = k ? m[3] : 1;
                    tm.x = m[4] || 0, tm.y = m[5] || 0, scaleX = Math.sqrt(a * a + b * b), scaleY = Math.sqrt(d * d + c * c), 
                    rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0, skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0, 
                    difX = scaleX - Math.abs(tm.scaleX || 0), difY = scaleY - Math.abs(tm.scaleY || 0), 
                    Math.abs(skewX) > 90 && Math.abs(skewX) < 270 && (invX ? (scaleX *= -1, skewX += 0 >= rotation ? 180 : -180, 
                    rotation += 0 >= rotation ? 180 : -180) : (scaleY *= -1, skewX += 0 >= skewX ? 180 : -180)), 
                    difR = (rotation - tm.rotation) % 180, difS = (skewX - tm.skewX) % 180, (void 0 === tm.skewX || difX > min || -min > difX || difY > min || -min > difY || difR > -minAngle && minAngle > difR && difR * rnd | !1 || difS > -minAngle && minAngle > difS && difS * rnd | !1) && (tm.scaleX = scaleX, 
                    tm.scaleY = scaleY, tm.rotation = rotation, tm.skewX = skewX), _supports3D && (tm.rotationX = tm.rotationY = tm.z = 0, 
                    tm.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0, tm.scaleZ = 1);
                }
                tm.zOrigin = zOrigin;
                for (i in tm) tm[i] < min && tm[i] > -min && (tm[i] = 0);
            } else tm = {
                x: 0,
                y: 0,
                z: 0,
                scaleX: 1,
                scaleY: 1,
                scaleZ: 1,
                skewX: 0,
                perspective: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                zOrigin: 0
            };
            return rec && (t._gsTransform = tm), tm.xPercent = tm.yPercent = 0, tm;
        }, _setIETransformRatio = function(v) {
            var filters, val, t = this.data, ang = -t.rotation * _DEG2RAD, skew = ang + t.skewX * _DEG2RAD, rnd = 1e5, a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd, b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd, c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd, d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd, style = this.t.style, cs = this.t.currentStyle;
            if (cs) {
                val = b, b = -c, c = -val, filters = cs.filter, style.filter = "";
                var dx, dy, w = this.t.offsetWidth, h = this.t.offsetHeight, clip = "absolute" !== cs.position, m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d, ox = t.x + w * t.xPercent / 100, oy = t.y + h * t.yPercent / 100;
                if (null != t.ox && (dx = (t.oxp ? w * t.ox * .01 : t.ox) - w / 2, dy = (t.oyp ? h * t.oy * .01 : t.oy) - h / 2, 
                ox += dx - (dx * a + dy * b), oy += dy - (dx * c + dy * d)), clip ? (dx = w / 2, 
                dy = h / 2, m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")") : m += ", sizingMethod='auto expand')", 
                style.filter = -1 !== filters.indexOf("DXImageTransform.Microsoft.Matrix(") ? filters.replace(_ieSetMatrixExp, m) : m + " " + filters, 
                (0 === v || 1 === v) && 1 === a && 0 === b && 0 === c && 1 === d && (clip && -1 === m.indexOf("Dx=0, Dy=0") || _opacityExp.test(filters) && 100 !== parseFloat(RegExp.$1) || -1 === filters.indexOf("gradient(" && filters.indexOf("Alpha")) && style.removeAttribute("filter")), 
                !clip) {
                    var marg, prop, dif, mult = 8 > _ieVers ? 1 : -1;
                    for (dx = t.ieOffsetX || 0, dy = t.ieOffsetY || 0, t.ieOffsetX = Math.round((w - ((0 > a ? -a : a) * w + (0 > b ? -b : b) * h)) / 2 + ox), 
                    t.ieOffsetY = Math.round((h - ((0 > d ? -d : d) * h + (0 > c ? -c : c) * w)) / 2 + oy), 
                    i = 0; 4 > i; i++) prop = _margins[i], marg = cs[prop], val = -1 !== marg.indexOf("px") ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0, 
                    dif = val !== t[prop] ? 2 > i ? -t.ieOffsetX : -t.ieOffsetY : 2 > i ? dx - t.ieOffsetX : dy - t.ieOffsetY, 
                    style[prop] = (t[prop] = Math.round(val - dif * (0 === i || 2 === i ? 1 : mult))) + "px";
                }
            }
        }, _set3DTransformRatio = _internals.set3DTransformRatio = function(v) {
            var a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, zOrigin, rnd, cos, sin, t1, t2, t3, t4, t = this.data, style = this.t.style, angle = t.rotation * _DEG2RAD, sx = t.scaleX, sy = t.scaleY, sz = t.scaleZ, x = t.x, y = t.y, z = t.z, perspective = t.perspective;
            if ((1 === v || 0 === v) && "auto" === t.force3D && !(t.rotationY || t.rotationX || 1 !== sz || perspective || z)) return void _set2DTransformRatio.call(this, v);
            if (_isFirefox) {
                var n = 1e-4;
                n > sx && sx > -n && (sx = sz = 2e-5), n > sy && sy > -n && (sy = sz = 2e-5), !perspective || t.z || t.rotationX || t.rotationY || (perspective = 0);
            }
            if (angle || t.skewX) cos = Math.cos(angle), sin = Math.sin(angle), a11 = cos, a21 = sin, 
            t.skewX && (angle -= t.skewX * _DEG2RAD, cos = Math.cos(angle), sin = Math.sin(angle), 
            "simple" === t.skewType && (t1 = Math.tan(t.skewX * _DEG2RAD), t1 = Math.sqrt(1 + t1 * t1), 
            cos *= t1, sin *= t1)), a12 = -sin, a22 = cos; else {
                if (!(t.rotationY || t.rotationX || 1 !== sz || perspective)) return void (style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (1 !== sx || 1 !== sy ? " scale(" + sx + "," + sy + ")" : ""));
                a11 = a22 = 1, a12 = a21 = 0;
            }
            a33 = 1, a13 = a14 = a23 = a24 = a31 = a32 = a34 = a41 = a42 = 0, a43 = perspective ? -1 / perspective : 0, 
            zOrigin = t.zOrigin, rnd = 1e5, angle = t.rotationY * _DEG2RAD, angle && (cos = Math.cos(angle), 
            sin = Math.sin(angle), a31 = a33 * -sin, a41 = a43 * -sin, a13 = a11 * sin, a23 = a21 * sin, 
            a33 *= cos, a43 *= cos, a11 *= cos, a21 *= cos), angle = t.rotationX * _DEG2RAD, 
            angle && (cos = Math.cos(angle), sin = Math.sin(angle), t1 = a12 * cos + a13 * sin, 
            t2 = a22 * cos + a23 * sin, t3 = a32 * cos + a33 * sin, t4 = a42 * cos + a43 * sin, 
            a13 = a12 * -sin + a13 * cos, a23 = a22 * -sin + a23 * cos, a33 = a32 * -sin + a33 * cos, 
            a43 = a42 * -sin + a43 * cos, a12 = t1, a22 = t2, a32 = t3, a42 = t4), 1 !== sz && (a13 *= sz, 
            a23 *= sz, a33 *= sz, a43 *= sz), 1 !== sy && (a12 *= sy, a22 *= sy, a32 *= sy, 
            a42 *= sy), 1 !== sx && (a11 *= sx, a21 *= sx, a31 *= sx, a41 *= sx), zOrigin && (a34 -= zOrigin, 
            a14 = a13 * a34, a24 = a23 * a34, a34 = a33 * a34 + zOrigin), a14 = (t1 = (a14 += x) - (a14 |= 0)) ? (t1 * rnd + (0 > t1 ? -.5 : .5) | 0) / rnd + a14 : a14, 
            a24 = (t1 = (a24 += y) - (a24 |= 0)) ? (t1 * rnd + (0 > t1 ? -.5 : .5) | 0) / rnd + a24 : a24, 
            a34 = (t1 = (a34 += z) - (a34 |= 0)) ? (t1 * rnd + (0 > t1 ? -.5 : .5) | 0) / rnd + a34 : a34, 
            style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(") + [ (a11 * rnd | 0) / rnd, (a21 * rnd | 0) / rnd, (a31 * rnd | 0) / rnd, (a41 * rnd | 0) / rnd, (a12 * rnd | 0) / rnd, (a22 * rnd | 0) / rnd, (a32 * rnd | 0) / rnd, (a42 * rnd | 0) / rnd, (a13 * rnd | 0) / rnd, (a23 * rnd | 0) / rnd, (a33 * rnd | 0) / rnd, (a43 * rnd | 0) / rnd, a14, a24, a34, perspective ? 1 + -a34 / perspective : 1 ].join(",") + ")";
        }, _set2DTransformRatio = _internals.set2DTransformRatio = function(v) {
            var ang, skew, rnd, sx, sy, t = this.data, targ = this.t, style = targ.style, x = t.x, y = t.y;
            return t.rotationX || t.rotationY || t.z || t.force3D === !0 || "auto" === t.force3D && 1 !== v && 0 !== v ? (this.setRatio = _set3DTransformRatio, 
            void _set3DTransformRatio.call(this, v)) : void (t.rotation || t.skewX ? (ang = t.rotation * _DEG2RAD, 
            skew = ang - t.skewX * _DEG2RAD, rnd = 1e5, sx = t.scaleX * rnd, sy = t.scaleY * rnd, 
            style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + (Math.cos(ang) * sx | 0) / rnd + "," + (Math.sin(ang) * sx | 0) / rnd + "," + (Math.sin(skew) * -sy | 0) / rnd + "," + (Math.cos(skew) * sy | 0) / rnd + "," + x + "," + y + ")") : style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + t.scaleX + ",0,0," + t.scaleY + "," + x + "," + y + ")");
        };
        _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
                if (cssp._transform) return pt;
                var m2, skewY, copy, orig, has3D, hasChange, dr, m1 = cssp._transform = _getTransform(t, _cs, !0, vars.parseTransform), style = t.style, min = 1e-6, i = _transformProps.length, v = vars, endRotations = {};
                if ("string" == typeof v.transform && _transformProp) copy = _tempDiv.style, copy[_transformProp] = v.transform, 
                copy.display = "block", copy.position = "absolute", _doc.body.appendChild(_tempDiv), 
                m2 = _getTransform(_tempDiv, null, !1), _doc.body.removeChild(_tempDiv); else if ("object" == typeof v) {
                    if (m2 = {
                        scaleX: _parseVal(null != v.scaleX ? v.scaleX : v.scale, m1.scaleX),
                        scaleY: _parseVal(null != v.scaleY ? v.scaleY : v.scale, m1.scaleY),
                        scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                        x: _parseVal(v.x, m1.x),
                        y: _parseVal(v.y, m1.y),
                        z: _parseVal(v.z, m1.z),
                        xPercent: _parseVal(v.xPercent, m1.xPercent),
                        yPercent: _parseVal(v.yPercent, m1.yPercent),
                        perspective: _parseVal(v.transformPerspective, m1.perspective)
                    }, dr = v.directionalRotation, null != dr) if ("object" == typeof dr) for (copy in dr) v[copy] = dr[copy]; else v.rotation = dr;
                    "string" == typeof v.x && -1 !== v.x.indexOf("%") && (m2.x = 0, m2.xPercent = _parseVal(v.x, m1.xPercent)), 
                    "string" == typeof v.y && -1 !== v.y.indexOf("%") && (m2.y = 0, m2.yPercent = _parseVal(v.y, m1.yPercent)), 
                    m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations), 
                    _supports3D && (m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations), 
                    m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations)), 
                    m2.skewX = null == v.skewX ? m1.skewX : _parseAngle(v.skewX, m1.skewX), m2.skewY = null == v.skewY ? m1.skewY : _parseAngle(v.skewY, m1.skewY), 
                    (skewY = m2.skewY - m1.skewY) && (m2.skewX += skewY, m2.rotation += skewY);
                }
                for (_supports3D && null != v.force3D && (m1.force3D = v.force3D, hasChange = !0), 
                m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType, has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective, 
                has3D || null == v.scale || (m2.scaleZ = 1); --i > -1; ) p = _transformProps[i], 
                orig = m2[p] - m1[p], (orig > min || -min > orig || null != _forcePT[p]) && (hasChange = !0, 
                pt = new CSSPropTween(m1, p, m1[p], orig, pt), p in endRotations && (pt.e = endRotations[p]), 
                pt.xs0 = 0, pt.plugin = plugin, cssp._overwriteProps.push(pt.n));
                return orig = v.transformOrigin, (orig || _supports3D && has3D && m1.zOrigin) && (_transformProp ? (hasChange = !0, 
                p = _transformOriginProp, orig = (orig || _getStyle(t, p, _cs, !1, "50% 50%")) + "", 
                pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin"), pt.b = style[p], 
                pt.plugin = plugin, _supports3D ? (copy = m1.zOrigin, orig = orig.split(" "), m1.zOrigin = (orig.length > 2 && (0 === copy || "0px" !== orig[2]) ? parseFloat(orig[2]) : copy) || 0, 
                pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px", pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n), 
                pt.b = copy, pt.xs0 = pt.e = m1.zOrigin) : pt.xs0 = pt.e = orig) : _parsePosition(orig + "", m1)), 
                hasChange && (cssp._transformType = has3D || 3 === this._transformType ? 3 : 2), 
                pt;
            },
            prefix: !0
        }), _registerComplexSpecialProp("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: !0,
            color: !0,
            multi: !0,
            keyword: "inset"
        }), _registerComplexSpecialProp("borderRadius", {
            defaultValue: "0px",
            parser: function(t, e, p, cssp, pt) {
                e = this.format(e);
                var ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em, props = [ "borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius" ], style = t.style;
                for (w = parseFloat(t.offsetWidth), h = parseFloat(t.offsetHeight), ea1 = e.split(" "), 
                i = 0; i < props.length; i++) this.p.indexOf("border") && (props[i] = _checkPropPrefix(props[i])), 
                bs = bs2 = _getStyle(t, props[i], _cs, !1, "0px"), -1 !== bs.indexOf(" ") && (bs2 = bs.split(" "), 
                bs = bs2[0], bs2 = bs2[1]), es = es2 = ea1[i], bn = parseFloat(bs), bsfx = bs.substr((bn + "").length), 
                rel = "=" === es.charAt(1), rel ? (en = parseInt(es.charAt(0) + "1", 10), es = es.substr(2), 
                en *= parseFloat(es), esfx = es.substr((en + "").length - (0 > en ? 1 : 0)) || "") : (en = parseFloat(es), 
                esfx = es.substr((en + "").length)), "" === esfx && (esfx = _suffixMap[p] || bsfx), 
                esfx !== bsfx && (hn = _convertToPixels(t, "borderLeft", bn, bsfx), vn = _convertToPixels(t, "borderTop", bn, bsfx), 
                "%" === esfx ? (bs = hn / w * 100 + "%", bs2 = vn / h * 100 + "%") : "em" === esfx ? (em = _convertToPixels(t, "borderLeft", 1, "em"), 
                bs = hn / em + "em", bs2 = vn / em + "em") : (bs = hn + "px", bs2 = vn + "px"), 
                rel && (es = parseFloat(bs) + en + esfx, es2 = parseFloat(bs2) + en + esfx)), pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, !1, "0px", pt);
                return pt;
            },
            prefix: !0,
            formatter: _getFormatter("0px 0px 0px 0px", !1, !0)
        }), _registerComplexSpecialProp("backgroundPosition", {
            defaultValue: "0 0",
            parser: function(t, e, p, cssp, pt, plugin) {
                var ba, ea, i, pct, overlap, src, bp = "background-position", cs = _cs || _getComputedStyle(t, null), bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), es = this.format(e);
                if (-1 !== bs.indexOf("%") != (-1 !== es.indexOf("%")) && (src = _getStyle(t, "backgroundImage").replace(_urlExp, ""), 
                src && "none" !== src)) {
                    for (ba = bs.split(" "), ea = es.split(" "), _tempImg.setAttribute("src", src), 
                    i = 2; --i > -1; ) bs = ba[i], pct = -1 !== bs.indexOf("%"), pct !== (-1 !== ea[i].indexOf("%")) && (overlap = 0 === i ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height, 
                    ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%");
                    bs = ba.join(" ");
                }
                return this.parseComplex(t.style, bs, es, pt, plugin);
            },
            formatter: _parsePosition
        }), _registerComplexSpecialProp("backgroundSize", {
            defaultValue: "0 0",
            formatter: _parsePosition
        }), _registerComplexSpecialProp("perspective", {
            defaultValue: "0px",
            prefix: !0
        }), _registerComplexSpecialProp("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: !0
        }), _registerComplexSpecialProp("transformStyle", {
            prefix: !0
        }), _registerComplexSpecialProp("backfaceVisibility", {
            prefix: !0
        }), _registerComplexSpecialProp("userSelect", {
            prefix: !0
        }), _registerComplexSpecialProp("margin", {
            parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
        }), _registerComplexSpecialProp("padding", {
            parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
        }), _registerComplexSpecialProp("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function(t, e, p, cssp, pt, plugin) {
                var b, cs, delim;
                return 9 > _ieVers ? (cs = t.currentStyle, delim = 8 > _ieVers ? " " : ",", b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")", 
                e = this.format(e).split(",").join(delim)) : (b = this.format(_getStyle(t, this.p, _cs, !1, this.dflt)), 
                e = this.format(e)), this.parseComplex(t.style, b, e, pt, plugin);
            }
        }), _registerComplexSpecialProp("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0
        }), _registerComplexSpecialProp("autoRound,strictUnits", {
            parser: function(t, e, p, cssp, pt) {
                return pt;
            }
        }), _registerComplexSpecialProp("border", {
            defaultValue: "0px solid #000",
            parser: function(t, e, p, cssp, pt, plugin) {
                return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, !1, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, !1, "solid") + " " + _getStyle(t, "borderTopColor", _cs, !1, "#000")), this.format(e), pt, plugin);
            },
            color: !0,
            formatter: function(v) {
                var a = v.split(" ");
                return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || [ "#000" ])[0];
            }
        }), _registerComplexSpecialProp("borderWidth", {
            parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        }), _registerComplexSpecialProp("float,cssFloat,styleFloat", {
            parser: function(t, e, p, cssp, pt) {
                var s = t.style, prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
                return new CSSPropTween(s, prop, 0, 0, pt, -1, p, !1, 0, s[prop], e);
            }
        });
        var _setIEOpacityRatio = function(v) {
            var skip, t = this.t, filters = t.filter || _getStyle(this.data, "filter"), val = this.s + this.c * v | 0;
            100 === val && (-1 === filters.indexOf("atrix(") && -1 === filters.indexOf("radient(") && -1 === filters.indexOf("oader(") ? (t.removeAttribute("filter"), 
            skip = !_getStyle(this.data, "filter")) : (t.filter = filters.replace(_alphaFilterExp, ""), 
            skip = !0)), skip || (this.xn1 && (t.filter = filters = filters || "alpha(opacity=" + val + ")"), 
            -1 === filters.indexOf("pacity") ? 0 === val && this.xn1 || (t.filter = filters + " alpha(opacity=" + val + ")") : t.filter = filters.replace(_opacityExp, "opacity=" + val));
        };
        _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
            defaultValue: "1",
            parser: function(t, e, p, cssp, pt, plugin) {
                var b = parseFloat(_getStyle(t, "opacity", _cs, !1, "1")), style = t.style, isAutoAlpha = "autoAlpha" === p;
                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + b), 
                isAutoAlpha && 1 === b && "hidden" === _getStyle(t, "visibility", _cs) && 0 !== e && (b = 0), 
                _supportsOpacity ? pt = new CSSPropTween(style, "opacity", b, e - b, pt) : (pt = new CSSPropTween(style, "opacity", 100 * b, 100 * (e - b), pt), 
                pt.xn1 = isAutoAlpha ? 1 : 0, style.zoom = 1, pt.type = 2, pt.b = "alpha(opacity=" + pt.s + ")", 
                pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")", pt.data = t, pt.plugin = plugin, 
                pt.setRatio = _setIEOpacityRatio), isAutoAlpha && (pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, !1, 0, 0 !== b ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), 
                pt.xs0 = "inherit", cssp._overwriteProps.push(pt.n), cssp._overwriteProps.push(p)), 
                pt;
            }
        });
        var _removeProp = function(s, p) {
            p && (s.removeProperty ? ("ms" === p.substr(0, 2) && (p = "M" + p.substr(1)), s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())) : s.removeAttribute(p));
        }, _setClassNameRatio = function(v) {
            if (this.t._gsClassPT = this, 1 === v || 0 === v) {
                this.t.setAttribute("class", 0 === v ? this.b : this.e);
                for (var mpt = this.data, s = this.t.style; mpt; ) mpt.v ? s[mpt.p] = mpt.v : _removeProp(s, mpt.p), 
                mpt = mpt._next;
                1 === v && this.t._gsClassPT === this && (this.t._gsClassPT = null);
            } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
        };
        _registerComplexSpecialProp("className", {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
                var difData, bs, cnpt, cnptLookup, mpt, b = t.getAttribute("class") || "", cssText = t.style.cssText;
                if (pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2), pt.setRatio = _setClassNameRatio, 
                pt.pr = -11, _hasPriority = !0, pt.b = b, bs = _getAllStyles(t, _cs), cnpt = t._gsClassPT) {
                    for (cnptLookup = {}, mpt = cnpt.data; mpt; ) cnptLookup[mpt.p] = 1, mpt = mpt._next;
                    cnpt.setRatio(1);
                }
                return t._gsClassPT = pt, pt.e = "=" !== e.charAt(1) ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), 
                cssp._tween._duration && (t.setAttribute("class", pt.e), difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup), 
                t.setAttribute("class", b), pt.data = difData.firstMPT, t.style.cssText = cssText, 
                pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin)), pt;
            }
        });
        var _setClearPropsRatio = function(v) {
            if ((1 === v || 0 === v) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var a, p, i, clearTransform, s = this.t.style, transformParse = _specialProps.transform.parse;
                if ("all" === this.e) s.cssText = "", clearTransform = !0; else for (a = this.e.split(","), 
                i = a.length; --i > -1; ) p = a[i], _specialProps[p] && (_specialProps[p].parse === transformParse ? clearTransform = !0 : p = "transformOrigin" === p ? _transformOriginProp : _specialProps[p].p), 
                _removeProp(s, p);
                clearTransform && (_removeProp(s, _transformProp), this.t._gsTransform && delete this.t._gsTransform);
            }
        };
        for (_registerComplexSpecialProp("clearProps", {
            parser: function(t, e, p, cssp, pt) {
                return pt = new CSSPropTween(t, p, 0, 0, pt, 2), pt.setRatio = _setClearPropsRatio, 
                pt.e = e, pt.pr = -10, pt.data = cssp._tween, _hasPriority = !0, pt;
            }
        }), p = "bezier,throwProps,physicsProps,physics2D".split(","), i = p.length; i--; ) _registerPluginProp(p[i]);
        p = CSSPlugin.prototype, p._firstPT = null, p._onInitTween = function(target, vars, tween) {
            if (!target.nodeType) return !1;
            this._target = target, this._tween = tween, this._vars = vars, _autoRound = vars.autoRound, 
            _hasPriority = !1, _suffixMap = vars.suffixMap || CSSPlugin.suffixMap, _cs = _getComputedStyle(target, ""), 
            _overwriteProps = this._overwriteProps;
            var v, pt, pt2, first, last, next, zIndex, tpt, threeD, style = target.style;
            if (_reqSafariFix && "" === style.zIndex && (v = _getStyle(target, "zIndex", _cs), 
            ("auto" === v || "" === v) && this._addLazySet(style, "zIndex", 0)), "string" == typeof vars && (first = style.cssText, 
            v = _getAllStyles(target, _cs), style.cssText = first + ";" + vars, v = _cssDif(target, v, _getAllStyles(target)).difs, 
            !_supportsOpacity && _opacityValExp.test(vars) && (v.opacity = parseFloat(RegExp.$1)), 
            vars = v, style.cssText = first), this._firstPT = pt = this.parse(target, vars, null), 
            this._transformType) {
                for (threeD = 3 === this._transformType, _transformProp ? _isSafari && (_reqSafariFix = !0, 
                "" === style.zIndex && (zIndex = _getStyle(target, "zIndex", _cs), ("auto" === zIndex || "" === zIndex) && this._addLazySet(style, "zIndex", 0)), 
                _isSafariLT6 && this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"))) : style.zoom = 1, 
                pt2 = pt; pt2 && pt2._next; ) pt2 = pt2._next;
                tpt = new CSSPropTween(target, "transform", 0, 0, null, 2), this._linkCSSP(tpt, null, pt2), 
                tpt.setRatio = threeD && _supports3D ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio, 
                tpt.data = this._transform || _getTransform(target, _cs, !0), _overwriteProps.pop();
            }
            if (_hasPriority) {
                for (;pt; ) {
                    for (next = pt._next, pt2 = first; pt2 && pt2.pr > pt.pr; ) pt2 = pt2._next;
                    (pt._prev = pt2 ? pt2._prev : last) ? pt._prev._next = pt : first = pt, (pt._next = pt2) ? pt2._prev = pt : last = pt, 
                    pt = next;
                }
                this._firstPT = first;
            }
            return !0;
        }, p.parse = function(target, vars, pt, plugin) {
            var p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel, style = target.style;
            for (p in vars) es = vars[p], sp = _specialProps[p], sp ? pt = sp.parse(target, es, p, this, pt, plugin, vars) : (bs = _getStyle(target, p, _cs) + "", 
            isStr = "string" == typeof es, "color" === p || "fill" === p || "stroke" === p || -1 !== p.indexOf("Color") || isStr && _rgbhslExp.test(es) ? (isStr || (es = _parseColor(es), 
            es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")"), pt = _parseComplex(style, p, bs, es, !0, "transparent", pt, 0, plugin)) : !isStr || -1 === es.indexOf(" ") && -1 === es.indexOf(",") ? (bn = parseFloat(bs), 
            bsfx = bn || 0 === bn ? bs.substr((bn + "").length) : "", ("" === bs || "auto" === bs) && ("width" === p || "height" === p ? (bn = _getDimension(target, p, _cs), 
            bsfx = "px") : "left" === p || "top" === p ? (bn = _calculateOffset(target, p, _cs), 
            bsfx = "px") : (bn = "opacity" !== p ? 0 : 1, bsfx = "")), rel = isStr && "=" === es.charAt(1), 
            rel ? (en = parseInt(es.charAt(0) + "1", 10), es = es.substr(2), en *= parseFloat(es), 
            esfx = es.replace(_suffixExp, "")) : (en = parseFloat(es), esfx = isStr ? es.substr((en + "").length) || "" : ""), 
            "" === esfx && (esfx = p in _suffixMap ? _suffixMap[p] : bsfx), es = en || 0 === en ? (rel ? en + bn : en) + esfx : vars[p], 
            bsfx !== esfx && "" !== esfx && (en || 0 === en) && bn && (bn = _convertToPixels(target, p, bn, bsfx), 
            "%" === esfx ? (bn /= _convertToPixels(target, p, 100, "%") / 100, vars.strictUnits !== !0 && (bs = bn + "%")) : "em" === esfx ? bn /= _convertToPixels(target, p, 1, "em") : "px" !== esfx && (en = _convertToPixels(target, p, en, esfx), 
            esfx = "px"), rel && (en || 0 === en) && (es = en + bn + esfx)), rel && (en += bn), 
            !bn && 0 !== bn || !en && 0 !== en ? void 0 !== style[p] && (es || es + "" != "NaN" && null != es) ? (pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, !1, 0, bs, es), 
            pt.xs0 = "none" !== es || "display" !== p && -1 === p.indexOf("Style") ? es : bs) : _log("invalid " + p + " tween value: " + vars[p]) : (pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== !1 && ("px" === esfx || "zIndex" === p), 0, bs, es), 
            pt.xs0 = esfx)) : pt = _parseComplex(style, p, bs, es, !0, null, pt, 0, plugin)), 
            plugin && pt && !pt.plugin && (pt.plugin = plugin);
            return pt;
        }, p.setRatio = function(v) {
            var val, str, i, pt = this._firstPT, min = 1e-6;
            if (1 !== v || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (v || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (;pt; ) {
                if (val = pt.c * v + pt.s, pt.r ? val = Math.round(val) : min > val && val > -min && (val = 0), 
                pt.type) if (1 === pt.type) if (i = pt.l, 2 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2; else if (3 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3; else if (4 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4; else if (5 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5; else {
                    for (str = pt.xs0 + val + pt.xs1, i = 1; i < pt.l; i++) str += pt["xn" + i] + pt["xs" + (i + 1)];
                    pt.t[pt.p] = str;
                } else -1 === pt.type ? pt.t[pt.p] = pt.xs0 : pt.setRatio && pt.setRatio(v); else pt.t[pt.p] = val + pt.xs0;
                pt = pt._next;
            } else for (;pt; ) 2 !== pt.type ? pt.t[pt.p] = pt.b : pt.setRatio(v), pt = pt._next; else for (;pt; ) 2 !== pt.type ? pt.t[pt.p] = pt.e : pt.setRatio(v), 
            pt = pt._next;
        }, p._enableTransforms = function(threeD) {
            this._transformType = threeD || 3 === this._transformType ? 3 : 2, this._transform = this._transform || _getTransform(this._target, _cs, !0);
        };
        var lazySet = function() {
            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
        };
        p._addLazySet = function(t, p, v) {
            var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
            pt.e = v, pt.setRatio = lazySet, pt.data = this;
        }, p._linkCSSP = function(pt, next, prev, remove) {
            return pt && (next && (next._prev = pt), pt._next && (pt._next._prev = pt._prev), 
            pt._prev ? pt._prev._next = pt._next : this._firstPT === pt && (this._firstPT = pt._next, 
            remove = !0), prev ? prev._next = pt : remove || null !== this._firstPT || (this._firstPT = pt), 
            pt._next = next, pt._prev = prev), pt;
        }, p._kill = function(lookup) {
            var pt, p, xfirst, copy = lookup;
            if (lookup.autoAlpha || lookup.alpha) {
                copy = {};
                for (p in lookup) copy[p] = lookup[p];
                copy.opacity = 1, copy.autoAlpha && (copy.visibility = 1);
            }
            return lookup.className && (pt = this._classNamePT) && (xfirst = pt.xfirst, xfirst && xfirst._prev ? this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev) : xfirst === this._firstPT && (this._firstPT = pt._next), 
            pt._next && this._linkCSSP(pt._next, pt._next._next, xfirst._prev), this._classNamePT = null), 
            TweenPlugin.prototype._kill.call(this, copy);
        };
        var _getChildStyles = function(e, props, targets) {
            var children, i, child, type;
            if (e.slice) for (i = e.length; --i > -1; ) _getChildStyles(e[i], props, targets); else for (children = e.childNodes, 
            i = children.length; --i > -1; ) child = children[i], type = child.type, child.style && (props.push(_getAllStyles(child)), 
            targets && targets.push(child)), 1 !== type && 9 !== type && 11 !== type || !child.childNodes.length || _getChildStyles(child, props, targets);
        };
        return CSSPlugin.cascadeTo = function(target, duration, vars) {
            var i, difs, p, tween = TweenLite.to(target, duration, vars), results = [ tween ], b = [], e = [], targets = [], _reservedProps = TweenLite._internals.reservedProps;
            for (target = tween._targets || tween.target, _getChildStyles(target, b, targets), 
            tween.render(duration, !0), _getChildStyles(target, e), tween.render(0, !0), tween._enabled(!0), 
            i = targets.length; --i > -1; ) if (difs = _cssDif(targets[i], b[i], e[i]), difs.firstMPT) {
                difs = difs.difs;
                for (p in vars) _reservedProps[p] && (difs[p] = vars[p]);
                results.push(TweenLite.to(targets[i], duration, difs));
            }
            return results;
        }, TweenPlugin.activate([ CSSPlugin ]), CSSPlugin;
    }, !0);
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function(name) {
    "use strict";
    var getGlobal = function() {
        return (_gsScope.GreenSockGlobals || _gsScope)[name];
    };
    "function" == typeof define && define.amd ? define([ "TweenLite" ], getGlobal) : "undefined" != typeof module && module.exports && (require("../TweenLite.js"), 
    module.exports = getGlobal());
}("CSSPlugin");

var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;

(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
    "use strict";
    _gsScope._gsDefine("TweenMax", [ "core.Animation", "core.SimpleTimeline", "TweenLite" ], function(Animation, SimpleTimeline, TweenLite) {
        var _slice = function(a) {
            var i, b = [], l = a.length;
            for (i = 0; i !== l; b.push(a[i++])) ;
            return b;
        }, TweenMax = function(target, duration, vars) {
            TweenLite.call(this, target, duration, vars), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, 
            this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, 
            this._dirty = !0, this.render = TweenMax.prototype.render;
        }, _tinyNum = 1e-10, TweenLiteInternals = TweenLite._internals, _isSelector = TweenLiteInternals.isSelector, _isArray = TweenLiteInternals.isArray, p = TweenMax.prototype = TweenLite.to({}, .1, {}), _blankArray = [];
        TweenMax.version = "1.13.1", p.constructor = TweenMax, p.kill()._gc = !1, TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf, 
        TweenMax.getTweensOf = TweenLite.getTweensOf, TweenMax.lagSmoothing = TweenLite.lagSmoothing, 
        TweenMax.ticker = TweenLite.ticker, TweenMax.render = TweenLite.render, p.invalidate = function() {
            return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, 
            this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), TweenLite.prototype.invalidate.call(this);
        }, p.updateTo = function(vars, resetDuration) {
            var p, curRatio = this.ratio;
            resetDuration && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, 
            this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
            for (p in vars) this.vars[p] = vars[p];
            if (this._initted) if (resetDuration) this._initted = !1; else if (this._gc && this._enabled(!0, !1), 
            this._notifyPluginsOfEnabled && this._firstPT && TweenLite._onPluginEvent("_onDisable", this), 
            this._time / this._duration > .998) {
                var prevTime = this._time;
                this.render(0, !0, !1), this._initted = !1, this.render(prevTime, !0, !1);
            } else if (this._time > 0) {
                this._initted = !1, this._init();
                for (var endValue, inv = 1 / (1 - curRatio), pt = this._firstPT; pt; ) endValue = pt.s + pt.c, 
                pt.c *= inv, pt.s = endValue - pt.c, pt = pt._next;
            }
            return this;
        }, p.render = function(time, suppressEvents, force) {
            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
            var isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, totalDur = this._dirty ? this.totalDuration() : this._totalDuration, prevTime = this._time, prevTotalTime = this._totalTime, prevCycle = this._cycle, duration = this._duration, prevRawPrevTime = this._rawPrevTime;
            if (time >= totalDur ? (this._totalTime = totalDur, this._cycle = this._repeat, 
            this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = duration, 
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (isComplete = !0, 
            callback = "onComplete"), 0 === duration && (this._initted || !this.vars.lazy || force) && (this._startTime === this._timeline._duration && (time = 0), 
            (0 === time || 0 > prevRawPrevTime || prevRawPrevTime === _tinyNum) && prevRawPrevTime !== time && (force = !0, 
            prevRawPrevTime > _tinyNum && (callback = "onReverseComplete")), this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum)) : 1e-7 > time ? (this._totalTime = this._time = this._cycle = 0, 
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== prevTotalTime || 0 === duration && prevRawPrevTime > 0 && prevRawPrevTime !== _tinyNum) && (callback = "onReverseComplete", 
            isComplete = this._reversed), 0 > time ? (this._active = !1, 0 === duration && (this._initted || !this.vars.lazy || force) && (prevRawPrevTime >= 0 && (force = !0), 
            this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum)) : this._initted || (force = !0)) : (this._totalTime = this._time = time, 
            0 !== this._repeat && (cycleDuration = duration + this._repeatDelay, this._cycle = this._totalTime / cycleDuration >> 0, 
            0 !== this._cycle && this._cycle === this._totalTime / cycleDuration && this._cycle--, 
            this._time = this._totalTime - this._cycle * cycleDuration, this._yoyo && 0 !== (1 & this._cycle) && (this._time = duration - this._time), 
            this._time > duration ? this._time = duration : this._time < 0 && (this._time = 0)), 
            this._easeType ? (r = this._time / duration, type = this._easeType, pow = this._easePower, 
            (1 === type || 3 === type && r >= .5) && (r = 1 - r), 3 === type && (r *= 2), 1 === pow ? r *= r : 2 === pow ? r *= r * r : 3 === pow ? r *= r * r * r : 4 === pow && (r *= r * r * r * r), 
            this.ratio = 1 === type ? 1 - r : 2 === type ? r : this._time / duration < .5 ? r / 2 : 1 - r / 2) : this.ratio = this._ease.getRatio(this._time / duration)), 
            prevTime === this._time && !force && prevCycle === this._cycle) return void (prevTotalTime !== this._totalTime && this._onUpdate && (suppressEvents || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)));
            if (!this._initted) {
                if (this._init(), !this._initted || this._gc) return;
                if (!force && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = prevTime, 
                this._totalTime = prevTotalTime, this._rawPrevTime = prevRawPrevTime, this._cycle = prevCycle, 
                TweenLiteInternals.lazyTweens.push(this), void (this._lazy = time);
                this._time && !isComplete ? this.ratio = this._ease.getRatio(this._time / duration) : isComplete && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
            }
            for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== prevTime && time >= 0 && (this._active = !0), 
            0 === prevTotalTime && (2 === this._initted && time > 0 && this._init(), this._startAt && (time >= 0 ? this._startAt.render(time, suppressEvents, force) : callback || (callback = "_dummyGS")), 
            this.vars.onStart && (0 !== this._totalTime || 0 === duration) && (suppressEvents || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray))), 
            pt = this._firstPT; pt; ) pt.f ? pt.t[pt.p](pt.c * this.ratio + pt.s) : pt.t[pt.p] = pt.c * this.ratio + pt.s, 
            pt = pt._next;
            this._onUpdate && (0 > time && this._startAt && this._startTime && this._startAt.render(time, suppressEvents, force), 
            suppressEvents || (this._totalTime !== prevTotalTime || isComplete) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)), 
            this._cycle !== prevCycle && (suppressEvents || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray)), 
            callback && (!this._gc || force) && (0 > time && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(time, suppressEvents, force), 
            isComplete && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), 
            !suppressEvents && this.vars[callback] && this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray), 
            0 === duration && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum && (this._rawPrevTime = 0));
        }, TweenMax.to = function(target, duration, vars) {
            return new TweenMax(target, duration, vars);
        }, TweenMax.from = function(target, duration, vars) {
            return vars.runBackwards = !0, vars.immediateRender = 0 != vars.immediateRender, 
            new TweenMax(target, duration, vars);
        }, TweenMax.fromTo = function(target, duration, fromVars, toVars) {
            return toVars.startAt = fromVars, toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender, 
            new TweenMax(target, duration, toVars);
        }, TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            stagger = stagger || 0;
            var l, copy, i, p, delay = vars.delay || 0, a = [], finalComplete = function() {
                vars.onComplete && vars.onComplete.apply(vars.onCompleteScope || this, arguments), 
                onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray);
            };
            for (_isArray(targets) || ("string" == typeof targets && (targets = TweenLite.selector(targets) || targets), 
            _isSelector(targets) && (targets = _slice(targets))), l = targets.length, i = 0; l > i; i++) {
                copy = {};
                for (p in vars) copy[p] = vars[p];
                copy.delay = delay, i === l - 1 && onCompleteAll && (copy.onComplete = finalComplete), 
                a[i] = new TweenMax(targets[i], duration, copy), delay += stagger;
            }
            return a;
        }, TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            return vars.runBackwards = !0, vars.immediateRender = 0 != vars.immediateRender, 
            TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        }, TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            return toVars.startAt = fromVars, toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender, 
            TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        }, TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
            return new TweenMax(callback, 0, {
                delay: delay,
                onComplete: callback,
                onCompleteParams: params,
                onCompleteScope: scope,
                onReverseComplete: callback,
                onReverseCompleteParams: params,
                onReverseCompleteScope: scope,
                immediateRender: !1,
                useFrames: useFrames,
                overwrite: 0
            });
        }, TweenMax.set = function(target, vars) {
            return new TweenMax(target, 0, vars);
        }, TweenMax.isTweening = function(target) {
            return TweenLite.getTweensOf(target, !0).length > 0;
        };
        var _getChildrenOf = function(timeline, includeTimelines) {
            for (var a = [], cnt = 0, tween = timeline._first; tween; ) tween instanceof TweenLite ? a[cnt++] = tween : (includeTimelines && (a[cnt++] = tween), 
            a = a.concat(_getChildrenOf(tween, includeTimelines)), cnt = a.length), tween = tween._next;
            return a;
        }, getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
            return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
        };
        TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
            null == tweens && (tweens = !0), null == delayedCalls && (delayedCalls = !0);
            var isDC, tween, i, a = getAllTweens(0 != timelines), l = a.length, allTrue = tweens && delayedCalls && timelines;
            for (i = 0; l > i; i++) tween = a[i], (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) && (complete ? tween.totalTime(tween._reversed ? 0 : tween.totalDuration()) : tween._enabled(!1, !1));
        }, TweenMax.killChildTweensOf = function(parent, complete) {
            if (null != parent) {
                var a, curParent, p, i, l, tl = TweenLiteInternals.tweenLookup;
                if ("string" == typeof parent && (parent = TweenLite.selector(parent) || parent), 
                _isSelector(parent) && (parent = _slice(parent)), _isArray(parent)) for (i = parent.length; --i > -1; ) TweenMax.killChildTweensOf(parent[i], complete); else {
                    a = [];
                    for (p in tl) for (curParent = tl[p].target.parentNode; curParent; ) curParent === parent && (a = a.concat(tl[p].tweens)), 
                    curParent = curParent.parentNode;
                    for (l = a.length, i = 0; l > i; i++) complete && a[i].totalTime(a[i].totalDuration()), 
                    a[i]._enabled(!1, !1);
                }
            }
        };
        var _changePause = function(pause, tweens, delayedCalls, timelines) {
            tweens = tweens !== !1, delayedCalls = delayedCalls !== !1, timelines = timelines !== !1;
            for (var isDC, tween, a = getAllTweens(timelines), allTrue = tweens && delayedCalls && timelines, i = a.length; --i > -1; ) tween = a[i], 
            (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) && tween.paused(pause);
        };
        return TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
            _changePause(!0, tweens, delayedCalls, timelines);
        }, TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
            _changePause(!1, tweens, delayedCalls, timelines);
        }, TweenMax.globalTimeScale = function(value) {
            var tl = Animation._rootTimeline, t = TweenLite.ticker.time;
            return arguments.length ? (value = value || _tinyNum, tl._startTime = t - (t - tl._startTime) * tl._timeScale / value, 
            tl = Animation._rootFramesTimeline, t = TweenLite.ticker.frame, tl._startTime = t - (t - tl._startTime) * tl._timeScale / value, 
            tl._timeScale = Animation._rootTimeline._timeScale = value, value) : tl._timeScale;
        }, p.progress = function(value) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration();
        }, p.totalProgress = function(value) {
            return arguments.length ? this.totalTime(this.totalDuration() * value, !1) : this._totalTime / this.totalDuration();
        }, p.time = function(value, suppressEvents) {
            return arguments.length ? (this._dirty && this.totalDuration(), value > this._duration && (value = this._duration), 
            this._yoyo && 0 !== (1 & this._cycle) ? value = this._duration - value + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (value += this._cycle * (this._duration + this._repeatDelay)), 
            this.totalTime(value, suppressEvents)) : this._time;
        }, p.duration = function(value) {
            return arguments.length ? Animation.prototype.duration.call(this, value) : this._duration;
        }, p.totalDuration = function(value) {
            return arguments.length ? -1 === this._repeat ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, 
            this._dirty = !1), this._totalDuration);
        }, p.repeat = function(value) {
            return arguments.length ? (this._repeat = value, this._uncache(!0)) : this._repeat;
        }, p.repeatDelay = function(value) {
            return arguments.length ? (this._repeatDelay = value, this._uncache(!0)) : this._repeatDelay;
        }, p.yoyo = function(value) {
            return arguments.length ? (this._yoyo = value, this) : this._yoyo;
        }, TweenMax;
    }, !0), _gsScope._gsDefine("TimelineLite", [ "core.Animation", "core.SimpleTimeline", "TweenLite" ], function(Animation, SimpleTimeline, TweenLite) {
        var TimelineLite = function(vars) {
            SimpleTimeline.call(this, vars), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, 
            this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, 
            this._onUpdate = this.vars.onUpdate;
            var val, p, v = this.vars;
            for (p in v) val = v[p], _isArray(val) && -1 !== val.join("").indexOf("{self}") && (v[p] = this._swapSelfInParams(val));
            _isArray(v.tweens) && this.add(v.tweens, 0, v.align, v.stagger);
        }, _tinyNum = 1e-10, TweenLiteInternals = TweenLite._internals, _isSelector = TweenLiteInternals.isSelector, _isArray = TweenLiteInternals.isArray, _lazyTweens = TweenLiteInternals.lazyTweens, _lazyRender = TweenLiteInternals.lazyRender, _blankArray = [], _globals = _gsScope._gsDefine.globals, _copy = function(vars) {
            var p, copy = {};
            for (p in vars) copy[p] = vars[p];
            return copy;
        }, _pauseCallback = function(tween, callback, params, scope) {
            tween._timeline.pause(tween._startTime), callback && callback.apply(scope || tween._timeline, params || _blankArray);
        }, _slice = function(a) {
            var i, b = [], l = a.length;
            for (i = 0; i !== l; b.push(a[i++])) ;
            return b;
        }, p = TimelineLite.prototype = new SimpleTimeline();
        return TimelineLite.version = "1.13.1", p.constructor = TimelineLite, p.kill()._gc = !1, 
        p.to = function(target, duration, vars, position) {
            var Engine = vars.repeat && _globals.TweenMax || TweenLite;
            return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
        }, p.from = function(target, duration, vars, position) {
            return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
        }, p.fromTo = function(target, duration, fromVars, toVars, position) {
            var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
            return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
        }, p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            var i, tl = new TimelineLite({
                onComplete: onCompleteAll,
                onCompleteParams: onCompleteAllParams,
                onCompleteScope: onCompleteAllScope,
                smoothChildTiming: this.smoothChildTiming
            });
            for ("string" == typeof targets && (targets = TweenLite.selector(targets) || targets), 
            _isSelector(targets) && (targets = _slice(targets)), stagger = stagger || 0, i = 0; i < targets.length; i++) vars.startAt && (vars.startAt = _copy(vars.startAt)), 
            tl.to(targets[i], duration, _copy(vars), i * stagger);
            return this.add(tl, position);
        }, p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            return vars.immediateRender = 0 != vars.immediateRender, vars.runBackwards = !0, 
            this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        }, p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            return toVars.startAt = fromVars, toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender, 
            this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        }, p.call = function(callback, params, scope, position) {
            return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
        }, p.set = function(target, vars, position) {
            return position = this._parseTimeOrLabel(position, 0, !0), null == vars.immediateRender && (vars.immediateRender = position === this._time && !this._paused), 
            this.add(new TweenLite(target, 0, vars), position);
        }, TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
            vars = vars || {}, null == vars.smoothChildTiming && (vars.smoothChildTiming = !0);
            var tween, next, tl = new TimelineLite(vars), root = tl._timeline;
            for (null == ignoreDelayedCalls && (ignoreDelayedCalls = !0), root._remove(tl, !0), 
            tl._startTime = 0, tl._rawPrevTime = tl._time = tl._totalTime = root._time, tween = root._first; tween; ) next = tween._next, 
            ignoreDelayedCalls && tween instanceof TweenLite && tween.target === tween.vars.onComplete || tl.add(tween, tween._startTime - tween._delay), 
            tween = next;
            return root.add(tl, 0), tl;
        }, p.add = function(value, position, align, stagger) {
            var curTime, l, i, child, tl, beforeRawTime;
            if ("number" != typeof position && (position = this._parseTimeOrLabel(position, 0, !0, value)), 
            !(value instanceof Animation)) {
                if (value instanceof Array || value && value.push && _isArray(value)) {
                    for (align = align || "normal", stagger = stagger || 0, curTime = position, l = value.length, 
                    i = 0; l > i; i++) _isArray(child = value[i]) && (child = new TimelineLite({
                        tweens: child
                    })), this.add(child, curTime), "string" != typeof child && "function" != typeof child && ("sequence" === align ? curTime = child._startTime + child.totalDuration() / child._timeScale : "start" === align && (child._startTime -= child.delay())), 
                    curTime += stagger;
                    return this._uncache(!0);
                }
                if ("string" == typeof value) return this.addLabel(value, position);
                if ("function" != typeof value) throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
                value = TweenLite.delayedCall(0, value);
            }
            if (SimpleTimeline.prototype.add.call(this, value, position), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (tl = this, 
            beforeRawTime = tl.rawTime() > value._startTime; tl._timeline; ) beforeRawTime && tl._timeline.smoothChildTiming ? tl.totalTime(tl._totalTime, !0) : tl._gc && tl._enabled(!0, !1), 
            tl = tl._timeline;
            return this;
        }, p.remove = function(value) {
            if (value instanceof Animation) return this._remove(value, !1);
            if (value instanceof Array || value && value.push && _isArray(value)) {
                for (var i = value.length; --i > -1; ) this.remove(value[i]);
                return this;
            }
            return "string" == typeof value ? this.removeLabel(value) : this.kill(null, value);
        }, p._remove = function(tween, skipDisable) {
            SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
            var last = this._last;
            return last ? this._time > last._startTime + last._totalDuration / last._timeScale && (this._time = this.duration(), 
            this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, 
            this;
        }, p.append = function(value, offsetOrLabel) {
            return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, !0, value));
        }, p.insert = p.insertMultiple = function(value, position, align, stagger) {
            return this.add(value, position || 0, align, stagger);
        }, p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
            return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, !0, tweens), align, stagger);
        }, p.addLabel = function(label, position) {
            return this._labels[label] = this._parseTimeOrLabel(position), this;
        }, p.addPause = function(position, callback, params, scope) {
            return this.call(_pauseCallback, [ "{self}", callback, params, scope ], this, position);
        }, p.removeLabel = function(label) {
            return delete this._labels[label], this;
        }, p.getLabelTime = function(label) {
            return null != this._labels[label] ? this._labels[label] : -1;
        }, p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
            var i;
            if (ignore instanceof Animation && ignore.timeline === this) this.remove(ignore); else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) for (i = ignore.length; --i > -1; ) ignore[i] instanceof Animation && ignore[i].timeline === this && this.remove(ignore[i]);
            if ("string" == typeof offsetOrLabel) return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && "number" == typeof timeOrLabel && null == this._labels[offsetOrLabel] ? timeOrLabel - this.duration() : 0, appendIfAbsent);
            if (offsetOrLabel = offsetOrLabel || 0, "string" != typeof timeOrLabel || !isNaN(timeOrLabel) && null == this._labels[timeOrLabel]) null == timeOrLabel && (timeOrLabel = this.duration()); else {
                if (i = timeOrLabel.indexOf("="), -1 === i) return null == this._labels[timeOrLabel] ? appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel : this._labels[timeOrLabel] + offsetOrLabel;
                offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1)), 
                timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
            }
            return Number(timeOrLabel) + offsetOrLabel;
        }, p.seek = function(position, suppressEvents) {
            return this.totalTime("number" == typeof position ? position : this._parseTimeOrLabel(position), suppressEvents !== !1);
        }, p.stop = function() {
            return this.paused(!0);
        }, p.gotoAndPlay = function(position, suppressEvents) {
            return this.play(position, suppressEvents);
        }, p.gotoAndStop = function(position, suppressEvents) {
            return this.pause(position, suppressEvents);
        }, p.render = function(time, suppressEvents, force) {
            this._gc && this._enabled(!0, !1);
            var tween, isComplete, next, callback, internalForce, totalDur = this._dirty ? this.totalDuration() : this._totalDuration, prevTime = this._time, prevStart = this._startTime, prevTimeScale = this._timeScale, prevPaused = this._paused;
            if (time >= totalDur ? (this._totalTime = this._time = totalDur, this._reversed || this._hasPausedChild() || (isComplete = !0, 
            callback = "onComplete", 0 === this._duration && (0 === time || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) && this._rawPrevTime !== time && this._first && (internalForce = !0, 
            this._rawPrevTime > _tinyNum && (callback = "onReverseComplete"))), this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum, 
            time = totalDur + 1e-4) : 1e-7 > time ? (this._totalTime = this._time = 0, (0 !== prevTime || 0 === this._duration && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || 0 > time && this._rawPrevTime >= 0)) && (callback = "onReverseComplete", 
            isComplete = this._reversed), 0 > time ? (this._active = !1, this._rawPrevTime >= 0 && this._first && (internalForce = !0), 
            this._rawPrevTime = time) : (this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum, 
            time = 0, this._initted || (internalForce = !0))) : this._totalTime = this._time = this._rawPrevTime = time, 
            this._time !== prevTime && this._first || force || internalForce) {
                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== prevTime && time > 0 && (this._active = !0), 
                0 === prevTime && this.vars.onStart && 0 !== this._time && (suppressEvents || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray)), 
                this._time >= prevTime) for (tween = this._first; tween && (next = tween._next, 
                !this._paused || prevPaused); ) (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) && (tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)), 
                tween = next; else for (tween = this._last; tween && (next = tween._prev, !this._paused || prevPaused); ) (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) && (tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)), 
                tween = next;
                this._onUpdate && (suppressEvents || (_lazyTweens.length && _lazyRender(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray))), 
                callback && (this._gc || (prevStart === this._startTime || prevTimeScale !== this._timeScale) && (0 === this._time || totalDur >= this.totalDuration()) && (isComplete && (_lazyTweens.length && _lazyRender(), 
                this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), 
                !suppressEvents && this.vars[callback] && this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray)));
            }
        }, p._hasPausedChild = function() {
            for (var tween = this._first; tween; ) {
                if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) return !0;
                tween = tween._next;
            }
            return !1;
        }, p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
            ignoreBeforeTime = ignoreBeforeTime || -9999999999;
            for (var a = [], tween = this._first, cnt = 0; tween; ) tween._startTime < ignoreBeforeTime || (tween instanceof TweenLite ? tweens !== !1 && (a[cnt++] = tween) : (timelines !== !1 && (a[cnt++] = tween), 
            nested !== !1 && (a = a.concat(tween.getChildren(!0, tweens, timelines)), cnt = a.length))), 
            tween = tween._next;
            return a;
        }, p.getTweensOf = function(target, nested) {
            var tweens, i, disabled = this._gc, a = [], cnt = 0;
            for (disabled && this._enabled(!0, !0), tweens = TweenLite.getTweensOf(target), 
            i = tweens.length; --i > -1; ) (tweens[i].timeline === this || nested && this._contains(tweens[i])) && (a[cnt++] = tweens[i]);
            return disabled && this._enabled(!1, !0), a;
        }, p._contains = function(tween) {
            for (var tl = tween.timeline; tl; ) {
                if (tl === this) return !0;
                tl = tl.timeline;
            }
            return !1;
        }, p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
            ignoreBeforeTime = ignoreBeforeTime || 0;
            for (var p, tween = this._first, labels = this._labels; tween; ) tween._startTime >= ignoreBeforeTime && (tween._startTime += amount), 
            tween = tween._next;
            if (adjustLabels) for (p in labels) labels[p] >= ignoreBeforeTime && (labels[p] += amount);
            return this._uncache(!0);
        }, p._kill = function(vars, target) {
            if (!vars && !target) return this._enabled(!1, !1);
            for (var tweens = target ? this.getTweensOf(target) : this.getChildren(!0, !0, !1), i = tweens.length, changed = !1; --i > -1; ) tweens[i]._kill(vars, target) && (changed = !0);
            return changed;
        }, p.clear = function(labels) {
            var tweens = this.getChildren(!1, !0, !0), i = tweens.length;
            for (this._time = this._totalTime = 0; --i > -1; ) tweens[i]._enabled(!1, !1);
            return labels !== !1 && (this._labels = {}), this._uncache(!0);
        }, p.invalidate = function() {
            for (var tween = this._first; tween; ) tween.invalidate(), tween = tween._next;
            return this;
        }, p._enabled = function(enabled, ignoreTimeline) {
            if (enabled === this._gc) for (var tween = this._first; tween; ) tween._enabled(enabled, !0), 
            tween = tween._next;
            return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
        }, p.duration = function(value) {
            return arguments.length ? (0 !== this.duration() && 0 !== value && this.timeScale(this._duration / value), 
            this) : (this._dirty && this.totalDuration(), this._duration);
        }, p.totalDuration = function(value) {
            if (!arguments.length) {
                if (this._dirty) {
                    for (var prev, end, max = 0, tween = this._last, prevStart = 999999999999; tween; ) prev = tween._prev, 
                    tween._dirty && tween.totalDuration(), tween._startTime > prevStart && this._sortChildren && !tween._paused ? this.add(tween, tween._startTime - tween._delay) : prevStart = tween._startTime, 
                    tween._startTime < 0 && !tween._paused && (max -= tween._startTime, this._timeline.smoothChildTiming && (this._startTime += tween._startTime / this._timeScale), 
                    this.shiftChildren(-tween._startTime, !1, -9999999999), prevStart = 0), end = tween._startTime + tween._totalDuration / tween._timeScale, 
                    end > max && (max = end), tween = prev;
                    this._duration = this._totalDuration = max, this._dirty = !1;
                }
                return this._totalDuration;
            }
            return 0 !== this.totalDuration() && 0 !== value && this.timeScale(this._totalDuration / value), 
            this;
        }, p.usesFrames = function() {
            for (var tl = this._timeline; tl._timeline; ) tl = tl._timeline;
            return tl === Animation._rootFramesTimeline;
        }, p.rawTime = function() {
            return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
        }, TimelineLite;
    }, !0), _gsScope._gsDefine("TimelineMax", [ "TimelineLite", "TweenLite", "easing.Ease" ], function(TimelineLite, TweenLite, Ease) {
        var TimelineMax = function(vars) {
            TimelineLite.call(this, vars), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, 
            this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0;
        }, _tinyNum = 1e-10, _blankArray = [], TweenLiteInternals = TweenLite._internals, _lazyTweens = TweenLiteInternals.lazyTweens, _lazyRender = TweenLiteInternals.lazyRender, _easeNone = new Ease(null, null, 1, 0), p = TimelineMax.prototype = new TimelineLite();
        return p.constructor = TimelineMax, p.kill()._gc = !1, TimelineMax.version = "1.13.1", 
        p.invalidate = function() {
            return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, 
            this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), TimelineLite.prototype.invalidate.call(this);
        }, p.addCallback = function(callback, position, params, scope) {
            return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
        }, p.removeCallback = function(callback, position) {
            if (callback) if (null == position) this._kill(null, callback); else for (var a = this.getTweensOf(callback, !1), i = a.length, time = this._parseTimeOrLabel(position); --i > -1; ) a[i]._startTime === time && a[i]._enabled(!1, !1);
            return this;
        }, p.tweenTo = function(position, vars) {
            vars = vars || {};
            var duration, p, t, copy = {
                ease: _easeNone,
                overwrite: vars.delay ? 2 : 1,
                useFrames: this.usesFrames(),
                immediateRender: !1
            };
            for (p in vars) copy[p] = vars[p];
            return copy.time = this._parseTimeOrLabel(position), duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || .001, 
            t = new TweenLite(this, duration, copy), copy.onStart = function() {
                t.target.paused(!0), t.vars.time !== t.target.time() && duration === t.duration() && t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale), 
                vars.onStart && vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray);
            }, t;
        }, p.tweenFromTo = function(fromPosition, toPosition, vars) {
            vars = vars || {}, fromPosition = this._parseTimeOrLabel(fromPosition), vars.startAt = {
                onComplete: this.seek,
                onCompleteParams: [ fromPosition ],
                onCompleteScope: this
            }, vars.immediateRender = vars.immediateRender !== !1;
            var t = this.tweenTo(toPosition, vars);
            return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || .001);
        }, p.render = function(time, suppressEvents, force) {
            this._gc && this._enabled(!0, !1);
            var tween, isComplete, next, callback, internalForce, cycleDuration, totalDur = this._dirty ? this.totalDuration() : this._totalDuration, dur = this._duration, prevTime = this._time, prevTotalTime = this._totalTime, prevStart = this._startTime, prevTimeScale = this._timeScale, prevRawPrevTime = this._rawPrevTime, prevPaused = this._paused, prevCycle = this._cycle;
            if (time >= totalDur ? (this._locked || (this._totalTime = totalDur, this._cycle = this._repeat), 
            this._reversed || this._hasPausedChild() || (isComplete = !0, callback = "onComplete", 
            0 === this._duration && (0 === time || 0 > prevRawPrevTime || prevRawPrevTime === _tinyNum) && prevRawPrevTime !== time && this._first && (internalForce = !0, 
            prevRawPrevTime > _tinyNum && (callback = "onReverseComplete"))), this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum, 
            this._yoyo && 0 !== (1 & this._cycle) ? this._time = time = 0 : (this._time = dur, 
            time = dur + 1e-4)) : 1e-7 > time ? (this._locked || (this._totalTime = this._cycle = 0), 
            this._time = 0, (0 !== prevTime || 0 === dur && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || 0 > time && prevRawPrevTime >= 0) && !this._locked) && (callback = "onReverseComplete", 
            isComplete = this._reversed), 0 > time ? (this._active = !1, prevRawPrevTime >= 0 && this._first && (internalForce = !0), 
            this._rawPrevTime = time) : (this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum, 
            time = 0, this._initted || (internalForce = !0))) : (0 === dur && 0 > prevRawPrevTime && (internalForce = !0), 
            this._time = this._rawPrevTime = time, this._locked || (this._totalTime = time, 
            0 !== this._repeat && (cycleDuration = dur + this._repeatDelay, this._cycle = this._totalTime / cycleDuration >> 0, 
            0 !== this._cycle && this._cycle === this._totalTime / cycleDuration && this._cycle--, 
            this._time = this._totalTime - this._cycle * cycleDuration, this._yoyo && 0 !== (1 & this._cycle) && (this._time = dur - this._time), 
            this._time > dur ? (this._time = dur, time = dur + 1e-4) : this._time < 0 ? this._time = time = 0 : time = this._time))), 
            this._cycle !== prevCycle && !this._locked) {
                var backwards = this._yoyo && 0 !== (1 & prevCycle), wrap = backwards === (this._yoyo && 0 !== (1 & this._cycle)), recTotalTime = this._totalTime, recCycle = this._cycle, recRawPrevTime = this._rawPrevTime, recTime = this._time;
                if (this._totalTime = prevCycle * dur, this._cycle < prevCycle ? backwards = !backwards : this._totalTime += dur, 
                this._time = prevTime, this._rawPrevTime = 0 === dur ? prevRawPrevTime - 1e-4 : prevRawPrevTime, 
                this._cycle = prevCycle, this._locked = !0, prevTime = backwards ? 0 : dur, this.render(prevTime, suppressEvents, 0 === dur), 
                suppressEvents || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray), 
                wrap && (prevTime = backwards ? dur + 1e-4 : -1e-4, this.render(prevTime, !0, !1)), 
                this._locked = !1, this._paused && !prevPaused) return;
                this._time = recTime, this._totalTime = recTotalTime, this._cycle = recCycle, this._rawPrevTime = recRawPrevTime;
            }
            if (!(this._time !== prevTime && this._first || force || internalForce)) return void (prevTotalTime !== this._totalTime && this._onUpdate && (suppressEvents || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)));
            if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== prevTotalTime && time > 0 && (this._active = !0), 
            0 === prevTotalTime && this.vars.onStart && 0 !== this._totalTime && (suppressEvents || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray)), 
            this._time >= prevTime) for (tween = this._first; tween && (next = tween._next, 
            !this._paused || prevPaused); ) (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) && (tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)), 
            tween = next; else for (tween = this._last; tween && (next = tween._prev, !this._paused || prevPaused); ) (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) && (tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)), 
            tween = next;
            this._onUpdate && (suppressEvents || (_lazyTweens.length && _lazyRender(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray))), 
            callback && (this._locked || this._gc || (prevStart === this._startTime || prevTimeScale !== this._timeScale) && (0 === this._time || totalDur >= this.totalDuration()) && (isComplete && (_lazyTweens.length && _lazyRender(), 
            this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), 
            !suppressEvents && this.vars[callback] && this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray)));
        }, p.getActive = function(nested, tweens, timelines) {
            null == nested && (nested = !0), null == tweens && (tweens = !0), null == timelines && (timelines = !1);
            var i, tween, a = [], all = this.getChildren(nested, tweens, timelines), cnt = 0, l = all.length;
            for (i = 0; l > i; i++) tween = all[i], tween.isActive() && (a[cnt++] = tween);
            return a;
        }, p.getLabelAfter = function(time) {
            time || 0 !== time && (time = this._time);
            var i, labels = this.getLabelsArray(), l = labels.length;
            for (i = 0; l > i; i++) if (labels[i].time > time) return labels[i].name;
            return null;
        }, p.getLabelBefore = function(time) {
            null == time && (time = this._time);
            for (var labels = this.getLabelsArray(), i = labels.length; --i > -1; ) if (labels[i].time < time) return labels[i].name;
            return null;
        }, p.getLabelsArray = function() {
            var p, a = [], cnt = 0;
            for (p in this._labels) a[cnt++] = {
                time: this._labels[p],
                name: p
            };
            return a.sort(function(a, b) {
                return a.time - b.time;
            }), a;
        }, p.progress = function(value) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration();
        }, p.totalProgress = function(value) {
            return arguments.length ? this.totalTime(this.totalDuration() * value, !1) : this._totalTime / this.totalDuration();
        }, p.totalDuration = function(value) {
            return arguments.length ? -1 === this._repeat ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (TimelineLite.prototype.totalDuration.call(this), 
            this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), 
            this._totalDuration);
        }, p.time = function(value, suppressEvents) {
            return arguments.length ? (this._dirty && this.totalDuration(), value > this._duration && (value = this._duration), 
            this._yoyo && 0 !== (1 & this._cycle) ? value = this._duration - value + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (value += this._cycle * (this._duration + this._repeatDelay)), 
            this.totalTime(value, suppressEvents)) : this._time;
        }, p.repeat = function(value) {
            return arguments.length ? (this._repeat = value, this._uncache(!0)) : this._repeat;
        }, p.repeatDelay = function(value) {
            return arguments.length ? (this._repeatDelay = value, this._uncache(!0)) : this._repeatDelay;
        }, p.yoyo = function(value) {
            return arguments.length ? (this._yoyo = value, this) : this._yoyo;
        }, p.currentLabel = function(value) {
            return arguments.length ? this.seek(value, !0) : this.getLabelBefore(this._time + 1e-8);
        }, TimelineMax;
    }, !0), function() {
        var _RAD2DEG = 180 / Math.PI, _r1 = [], _r2 = [], _r3 = [], _corProps = {}, Segment = function(a, b, c, d) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.da = d - a, this.ca = c - a, 
            this.ba = b - a;
        }, _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", cubicToQuadratic = function(a, b, c, d) {
            var q1 = {
                a: a
            }, q2 = {}, q3 = {}, q4 = {
                c: d
            }, mab = (a + b) / 2, mbc = (b + c) / 2, mcd = (c + d) / 2, mabc = (mab + mbc) / 2, mbcd = (mbc + mcd) / 2, m8 = (mbcd - mabc) / 8;
            return q1.b = mab + (a - mab) / 4, q2.b = mabc + m8, q1.c = q2.a = (q1.b + q2.b) / 2, 
            q2.c = q3.a = (mabc + mbcd) / 2, q3.b = mbcd - m8, q4.b = mcd + (d - mcd) / 4, q3.c = q4.a = (q3.b + q4.b) / 2, 
            [ q1, q2, q3, q4 ];
        }, _calculateControlPoints = function(a, curviness, quad, basic, correlate) {
            var i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl, l = a.length - 1, ii = 0, cp1 = a[0].a;
            for (i = 0; l > i; i++) seg = a[ii], p1 = seg.a, p2 = seg.d, p3 = a[ii + 1].d, correlate ? (r1 = _r1[i], 
            r2 = _r2[i], tl = (r2 + r1) * curviness * .25 / (basic ? .5 : _r3[i] || .5), m1 = p2 - (p2 - p1) * (basic ? .5 * curviness : 0 !== r1 ? tl / r1 : 0), 
            m2 = p2 + (p3 - p2) * (basic ? .5 * curviness : 0 !== r2 ? tl / r2 : 0), mm = p2 - (m1 + ((m2 - m1) * (3 * r1 / (r1 + r2) + .5) / 4 || 0))) : (m1 = p2 - (p2 - p1) * curviness * .5, 
            m2 = p2 + (p3 - p2) * curviness * .5, mm = p2 - (m1 + m2) / 2), m1 += mm, m2 += mm, 
            seg.c = cp2 = m1, seg.b = 0 !== i ? cp1 : cp1 = seg.a + .6 * (seg.c - seg.a), seg.da = p2 - p1, 
            seg.ca = cp2 - p1, seg.ba = cp1 - p1, quad ? (qb = cubicToQuadratic(p1, cp1, cp2, p2), 
            a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]), ii += 4) : ii++, cp1 = m2;
            seg = a[ii], seg.b = cp1, seg.c = cp1 + .4 * (seg.d - cp1), seg.da = seg.d - seg.a, 
            seg.ca = seg.c - seg.a, seg.ba = cp1 - seg.a, quad && (qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d), 
            a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]));
        }, _parseAnchors = function(values, p, correlate, prepend) {
            var l, i, p1, p2, p3, tmp, a = [];
            if (prepend) for (values = [ prepend ].concat(values), i = values.length; --i > -1; ) "string" == typeof (tmp = values[i][p]) && "=" === tmp.charAt(1) && (values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)));
            if (l = values.length - 2, 0 > l) return a[0] = new Segment(values[0][p], 0, 0, values[-1 > l ? 0 : 1][p]), 
            a;
            for (i = 0; l > i; i++) p1 = values[i][p], p2 = values[i + 1][p], a[i] = new Segment(p1, 0, 0, p2), 
            correlate && (p3 = values[i + 2][p], _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1), 
            _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2));
            return a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]), a;
        }, bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
            var i, p, a, j, r, l, seamless, last, obj = {}, props = [], first = prepend || values[0];
            correlate = "string" == typeof correlate ? "," + correlate + "," : _correlate, null == curviness && (curviness = 1);
            for (p in values[0]) props.push(p);
            if (values.length > 1) {
                for (last = values[values.length - 1], seamless = !0, i = props.length; --i > -1; ) if (p = props[i], 
                Math.abs(first[p] - last[p]) > .05) {
                    seamless = !1;
                    break;
                }
                seamless && (values = values.concat(), prepend && values.unshift(prepend), values.push(values[1]), 
                prepend = values[values.length - 3]);
            }
            for (_r1.length = _r2.length = _r3.length = 0, i = props.length; --i > -1; ) p = props[i], 
            _corProps[p] = -1 !== correlate.indexOf("," + p + ","), obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
            for (i = _r1.length; --i > -1; ) _r1[i] = Math.sqrt(_r1[i]), _r2[i] = Math.sqrt(_r2[i]);
            if (!basic) {
                for (i = props.length; --i > -1; ) if (_corProps[p]) for (a = obj[props[i]], l = a.length - 1, 
                j = 0; l > j; j++) r = a[j + 1].da / _r2[j] + a[j].da / _r1[j], _r3[j] = (_r3[j] || 0) + r * r;
                for (i = _r3.length; --i > -1; ) _r3[i] = Math.sqrt(_r3[i]);
            }
            for (i = props.length, j = quadratic ? 4 : 1; --i > -1; ) p = props[i], a = obj[p], 
            _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]), seamless && (a.splice(0, j), 
            a.splice(a.length - j, j));
            return obj;
        }, _parseBezierData = function(values, type, prepend) {
            type = type || "soft";
            var a, b, c, d, cur, i, j, l, p, cnt, tmp, obj = {}, inc = "cubic" === type ? 3 : 2, soft = "soft" === type, props = [];
            if (soft && prepend && (values = [ prepend ].concat(values)), null == values || values.length < inc + 1) throw "invalid Bezier data";
            for (p in values[0]) props.push(p);
            for (i = props.length; --i > -1; ) {
                for (p = props[i], obj[p] = cur = [], cnt = 0, l = values.length, j = 0; l > j; j++) a = null == prepend ? values[j][p] : "string" == typeof (tmp = values[j][p]) && "=" === tmp.charAt(1) ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp), 
                soft && j > 1 && l - 1 > j && (cur[cnt++] = (a + cur[cnt - 2]) / 2), cur[cnt++] = a;
                for (l = cnt - inc + 1, cnt = 0, j = 0; l > j; j += inc) a = cur[j], b = cur[j + 1], 
                c = cur[j + 2], d = 2 === inc ? 0 : cur[j + 3], cur[cnt++] = tmp = 3 === inc ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
                cur.length = cnt;
            }
            return obj;
        }, _addCubicLengths = function(a, steps, resolution) {
            for (var d, d1, s, da, ca, ba, p, i, inv, bez, index, inc = 1 / resolution, j = a.length; --j > -1; ) for (bez = a[j], 
            s = bez.a, da = bez.d - s, ca = bez.c - s, ba = bez.b - s, d = d1 = 0, i = 1; resolution >= i; i++) p = inc * i, 
            inv = 1 - p, d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p), index = j * resolution + i - 1, 
            steps[index] = (steps[index] || 0) + d * d;
        }, _parseLengthData = function(obj, resolution) {
            resolution = resolution >> 0 || 6;
            var p, i, l, index, a = [], lengths = [], d = 0, total = 0, threshold = resolution - 1, segments = [], curLS = [];
            for (p in obj) _addCubicLengths(obj[p], a, resolution);
            for (l = a.length, i = 0; l > i; i++) d += Math.sqrt(a[i]), index = i % resolution, 
            curLS[index] = d, index === threshold && (total += d, index = i / resolution >> 0, 
            segments[index] = curLS, lengths[index] = total, d = 0, curLS = []);
            return {
                length: total,
                lengths: lengths,
                segments: segments
            };
        }, BezierPlugin = _gsScope._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.3",
            API: 2,
            global: !0,
            init: function(target, vars, tween) {
                this._target = target, vars instanceof Array && (vars = {
                    values: vars
                }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == vars.timeResolution ? 6 : parseInt(vars.timeResolution, 10);
                var p, isFunc, i, j, prepend, values = vars.values || [], first = {}, second = values[0], autoRotate = vars.autoRotate || tween.vars.orientToBezier;
                this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [ [ "x", "y", "rotation", autoRotate === !0 ? 0 : Number(autoRotate) || 0 ] ] : null;
                for (p in second) this._props.push(p);
                for (i = this._props.length; --i > -1; ) p = this._props[i], this._overwriteProps.push(p), 
                isFunc = this._func[p] = "function" == typeof target[p], first[p] = isFunc ? target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)]() : parseFloat(target[p]), 
                prepend || first[p] !== values[0][p] && (prepend = first);
                if (this._beziers = "cubic" !== vars.type && "quadratic" !== vars.type && "soft" !== vars.type ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, !1, "thruBasic" === vars.type, vars.correlate, prepend) : _parseBezierData(values, vars.type, first), 
                this._segCount = this._beziers[p].length, this._timeRes) {
                    var ld = _parseLengthData(this._beziers, this._timeRes);
                    this._length = ld.length, this._lengths = ld.lengths, this._segments = ld.segments, 
                    this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], 
                    this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length;
                }
                if (autoRotate = this._autoRotate) for (this._initialRotations = [], autoRotate[0] instanceof Array || (this._autoRotate = autoRotate = [ autoRotate ]), 
                i = autoRotate.length; --i > -1; ) {
                    for (j = 0; 3 > j; j++) p = autoRotate[i][j], this._func[p] = "function" == typeof target[p] ? target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)] : !1;
                    p = autoRotate[i][2], this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
                }
                return this._startRatio = tween.vars.runBackwards ? 1 : 0, !0;
            },
            set: function(v) {
                var curIndex, inv, i, p, b, t, val, l, lengths, curSeg, segments = this._segCount, func = this._func, target = this._target, notStart = v !== this._startRatio;
                if (this._timeRes) {
                    if (lengths = this._lengths, curSeg = this._curSeg, v *= this._length, i = this._li, 
                    v > this._l2 && segments - 1 > i) {
                        for (l = segments - 1; l > i && (this._l2 = lengths[++i]) <= v; ) ;
                        this._l1 = lengths[i - 1], this._li = i, this._curSeg = curSeg = this._segments[i], 
                        this._s2 = curSeg[this._s1 = this._si = 0];
                    } else if (v < this._l1 && i > 0) {
                        for (;i > 0 && (this._l1 = lengths[--i]) >= v; ) ;
                        0 === i && v < this._l1 ? this._l1 = 0 : i++, this._l2 = lengths[i], this._li = i, 
                        this._curSeg = curSeg = this._segments[i], this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0, 
                        this._s2 = curSeg[this._si];
                    }
                    if (curIndex = i, v -= this._l1, i = this._si, v > this._s2 && i < curSeg.length - 1) {
                        for (l = curSeg.length - 1; l > i && (this._s2 = curSeg[++i]) <= v; ) ;
                        this._s1 = curSeg[i - 1], this._si = i;
                    } else if (v < this._s1 && i > 0) {
                        for (;i > 0 && (this._s1 = curSeg[--i]) >= v; ) ;
                        0 === i && v < this._s1 ? this._s1 = 0 : i++, this._s2 = curSeg[i], this._si = i;
                    }
                    t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
                } else curIndex = 0 > v ? 0 : v >= 1 ? segments - 1 : segments * v >> 0, t = (v - curIndex * (1 / segments)) * segments;
                for (inv = 1 - t, i = this._props.length; --i > -1; ) p = this._props[i], b = this._beziers[p][curIndex], 
                val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a, this._round[p] && (val = Math.round(val)), 
                func[p] ? target[p](val) : target[p] = val;
                if (this._autoRotate) {
                    var b2, x1, y1, x2, y2, add, conv, ar = this._autoRotate;
                    for (i = ar.length; --i > -1; ) p = ar[i][2], add = ar[i][3] || 0, conv = ar[i][4] === !0 ? 1 : _RAD2DEG, 
                    b = this._beziers[ar[i][0]], b2 = this._beziers[ar[i][1]], b && b2 && (b = b[curIndex], 
                    b2 = b2[curIndex], x1 = b.a + (b.b - b.a) * t, x2 = b.b + (b.c - b.b) * t, x1 += (x2 - x1) * t, 
                    x2 += (b.c + (b.d - b.c) * t - x2) * t, y1 = b2.a + (b2.b - b2.a) * t, y2 = b2.b + (b2.c - b2.b) * t, 
                    y1 += (y2 - y1) * t, y2 += (b2.c + (b2.d - b2.c) * t - y2) * t, val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i], 
                    func[p] ? target[p](val) : target[p] = val);
                }
            }
        }), p = BezierPlugin.prototype;
        BezierPlugin.bezierThrough = bezierThrough, BezierPlugin.cubicToQuadratic = cubicToQuadratic, 
        BezierPlugin._autoCSS = !0, BezierPlugin.quadraticToCubic = function(a, b, c) {
            return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
        }, BezierPlugin._cssRegister = function() {
            var CSSPlugin = _gsScope._gsDefine.globals.CSSPlugin;
            if (CSSPlugin) {
                var _internals = CSSPlugin._internals, _parseToProxy = _internals._parseToProxy, _setPluginRatio = _internals._setPluginRatio, CSSPropTween = _internals.CSSPropTween;
                _internals._registerComplexSpecialProp("bezier", {
                    parser: function(t, e, prop, cssp, pt, plugin) {
                        e instanceof Array && (e = {
                            values: e
                        }), plugin = new BezierPlugin();
                        var i, p, data, values = e.values, l = values.length - 1, pluginValues = [], v = {};
                        if (0 > l) return pt;
                        for (i = 0; l >= i; i++) data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i), 
                        pluginValues[i] = data.end;
                        for (p in e) v[p] = e[p];
                        return v.values = pluginValues, pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2), 
                        pt.data = data, pt.plugin = plugin, pt.setRatio = _setPluginRatio, 0 === v.autoRotate && (v.autoRotate = !0), 
                        !v.autoRotate || v.autoRotate instanceof Array || (i = v.autoRotate === !0 ? 0 : Number(v.autoRotate), 
                        v.autoRotate = null != data.end.left ? [ [ "left", "top", "rotation", i, !1 ] ] : null != data.end.x ? [ [ "x", "y", "rotation", i, !1 ] ] : !1), 
                        v.autoRotate && (cssp._transform || cssp._enableTransforms(!1), data.autoRotate = cssp._target._gsTransform), 
                        plugin._onInitTween(data.proxy, v, cssp._tween), pt;
                    }
                });
            }
        }, p._roundProps = function(lookup, value) {
            for (var op = this._overwriteProps, i = op.length; --i > -1; ) (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) && (this._round[op[i]] = value);
        }, p._kill = function(lookup) {
            var p, i, a = this._props;
            for (p in this._beziers) if (p in lookup) for (delete this._beziers[p], delete this._func[p], 
            i = a.length; --i > -1; ) a[i] === p && a.splice(i, 1);
            return this._super._kill.call(this, lookup);
        };
    }(), _gsScope._gsDefine("plugins.CSSPlugin", [ "plugins.TweenPlugin", "TweenLite" ], function(TweenPlugin, TweenLite) {
        var _hasPriority, _suffixMap, _cs, _overwriteProps, CSSPlugin = function() {
            TweenPlugin.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = CSSPlugin.prototype.setRatio;
        }, _specialProps = {}, p = CSSPlugin.prototype = new TweenPlugin("css");
        p.constructor = CSSPlugin, CSSPlugin.version = "1.13.1", CSSPlugin.API = 2, CSSPlugin.defaultTransformPerspective = 0, 
        CSSPlugin.defaultSkewType = "compensated", p = "px", CSSPlugin.suffixMap = {
            top: p,
            right: p,
            bottom: p,
            left: p,
            width: p,
            height: p,
            fontSize: p,
            padding: p,
            margin: p,
            perspective: p,
            lineHeight: ""
        };
        var _autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g, _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, _NaNExp = /[^\d\-\.]/g, _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g, _opacityExp = /opacity *= *([^)]*)/i, _opacityValExp = /opacity:([^;]*)/i, _alphaFilterExp = /alpha\(opacity *=.+?\)/i, _rgbhslExp = /^(rgb|hsl)/, _capsExp = /([A-Z])/g, _camelExp = /-([a-z])/gi, _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, _camelFunc = function(s, g) {
            return g.toUpperCase();
        }, _horizExp = /(?:Left|Right|Width)/i, _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, _DEG2RAD = Math.PI / 180, _RAD2DEG = 180 / Math.PI, _forcePT = {}, _doc = document, _tempDiv = _doc.createElement("div"), _tempImg = _doc.createElement("img"), _internals = CSSPlugin._internals = {
            _specialProps: _specialProps
        }, _agent = navigator.userAgent, _supportsOpacity = function() {
            var a, i = _agent.indexOf("Android"), d = _doc.createElement("div");
            return _isSafari = -1 !== _agent.indexOf("Safari") && -1 === _agent.indexOf("Chrome") && (-1 === i || Number(_agent.substr(i + 8, 1)) > 3), 
            _isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6, 
            _isFirefox = -1 !== _agent.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) && (_ieVers = parseFloat(RegExp.$1)), 
            d.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", a = d.getElementsByTagName("a")[0], 
            a ? /^0.55/.test(a.style.opacity) : !1;
        }(), _getIEOpacity = function(v) {
            return _opacityExp.test("string" == typeof v ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
        }, _log = function(s) {
            window.console && console.log(s);
        }, _prefixCSS = "", _prefix = "", _checkPropPrefix = function(p, e) {
            e = e || _tempDiv;
            var a, i, s = e.style;
            if (void 0 !== s[p]) return p;
            for (p = p.charAt(0).toUpperCase() + p.substr(1), a = [ "O", "Moz", "ms", "Ms", "Webkit" ], 
            i = 5; --i > -1 && void 0 === s[a[i] + p]; ) ;
            return i >= 0 ? (_prefix = 3 === i ? "ms" : a[i], _prefixCSS = "-" + _prefix.toLowerCase() + "-", 
            _prefix + p) : null;
        }, _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {}, _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
            var rv;
            return _supportsOpacity || "opacity" !== p ? (!calc && t.style[p] ? rv = t.style[p] : (cs = cs || _getComputedStyle(t)) ? rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase()) : t.currentStyle && (rv = t.currentStyle[p]), 
            null == dflt || rv && "none" !== rv && "auto" !== rv && "auto auto" !== rv ? rv : dflt) : _getIEOpacity(t);
        }, _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
            if ("px" === sfx || !sfx) return v;
            if ("auto" === sfx || !v) return 0;
            var pix, cache, time, horiz = _horizExp.test(p), node = t, style = _tempDiv.style, neg = 0 > v;
            if (neg && (v = -v), "%" === sfx && -1 !== p.indexOf("border")) pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight); else {
                if (style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;", 
                "%" !== sfx && node.appendChild) style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx; else {
                    if (node = t.parentNode || _doc.body, cache = node._gsCache, time = TweenLite.ticker.frame, 
                    cache && horiz && cache.time === time) return cache.width * v / 100;
                    style[horiz ? "width" : "height"] = v + sfx;
                }
                node.appendChild(_tempDiv), pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]), 
                node.removeChild(_tempDiv), horiz && "%" === sfx && CSSPlugin.cacheWidths !== !1 && (cache = node._gsCache = node._gsCache || {}, 
                cache.time = time, cache.width = pix / v * 100), 0 !== pix || recurse || (pix = _convertToPixels(t, p, v, sfx, !0));
            }
            return neg ? -pix : pix;
        }, _calculateOffset = _internals.calculateOffset = function(t, p, cs) {
            if ("absolute" !== _getStyle(t, "position", cs)) return 0;
            var dim = "left" === p ? "Left" : "Top", v = _getStyle(t, "margin" + dim, cs);
            return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
        }, _getAllStyles = function(t, cs) {
            var i, tr, s = {};
            if (cs = cs || _getComputedStyle(t, null)) if (i = cs.length) for (;--i > -1; ) s[cs[i].replace(_camelExp, _camelFunc)] = cs.getPropertyValue(cs[i]); else for (i in cs) s[i] = cs[i]; else if (cs = t.currentStyle || t.style) for (i in cs) "string" == typeof i && void 0 === s[i] && (s[i.replace(_camelExp, _camelFunc)] = cs[i]);
            return _supportsOpacity || (s.opacity = _getIEOpacity(t)), tr = _getTransform(t, cs, !1), 
            s.rotation = tr.rotation, s.skewX = tr.skewX, s.scaleX = tr.scaleX, s.scaleY = tr.scaleY, 
            s.x = tr.x, s.y = tr.y, _supports3D && (s.z = tr.z, s.rotationX = tr.rotationX, 
            s.rotationY = tr.rotationY, s.scaleZ = tr.scaleZ), s.filters && delete s.filters, 
            s;
        }, _cssDif = function(t, s1, s2, vars, forceLookup) {
            var val, p, mpt, difs = {}, style = t.style;
            for (p in s2) "cssText" !== p && "length" !== p && isNaN(p) && (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) && -1 === p.indexOf("Origin") && ("number" == typeof val || "string" == typeof val) && (difs[p] = "auto" !== val || "left" !== p && "top" !== p ? "" !== val && "auto" !== val && "none" !== val || "string" != typeof s1[p] || "" === s1[p].replace(_NaNExp, "") ? val : 0 : _calculateOffset(t, p), 
            void 0 !== style[p] && (mpt = new MiniPropTween(style, p, style[p], mpt)));
            if (vars) for (p in vars) "className" !== p && (difs[p] = vars[p]);
            return {
                difs: difs,
                firstMPT: mpt
            };
        }, _dimensions = {
            width: [ "Left", "Right" ],
            height: [ "Top", "Bottom" ]
        }, _margins = [ "marginLeft", "marginRight", "marginTop", "marginBottom" ], _getDimension = function(t, p, cs) {
            var v = parseFloat("width" === p ? t.offsetWidth : t.offsetHeight), a = _dimensions[p], i = a.length;
            for (cs = cs || _getComputedStyle(t, null); --i > -1; ) v -= parseFloat(_getStyle(t, "padding" + a[i], cs, !0)) || 0, 
            v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, !0)) || 0;
            return v;
        }, _parsePosition = function(v, recObj) {
            (null == v || "" === v || "auto" === v || "auto auto" === v) && (v = "0 0");
            var a = v.split(" "), x = -1 !== v.indexOf("left") ? "0%" : -1 !== v.indexOf("right") ? "100%" : a[0], y = -1 !== v.indexOf("top") ? "0%" : -1 !== v.indexOf("bottom") ? "100%" : a[1];
            return null == y ? y = "0" : "center" === y && (y = "50%"), ("center" === x || isNaN(parseFloat(x)) && -1 === (x + "").indexOf("=")) && (x = "50%"), 
            recObj && (recObj.oxp = -1 !== x.indexOf("%"), recObj.oyp = -1 !== y.indexOf("%"), 
            recObj.oxr = "=" === x.charAt(1), recObj.oyr = "=" === y.charAt(1), recObj.ox = parseFloat(x.replace(_NaNExp, "")), 
            recObj.oy = parseFloat(y.replace(_NaNExp, ""))), x + " " + y + (a.length > 2 ? " " + a[2] : "");
        }, _parseChange = function(e, b) {
            return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
        }, _parseVal = function(v, d) {
            return null == v ? d : "string" == typeof v && "=" === v.charAt(1) ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) + d : parseFloat(v);
        }, _parseAngle = function(v, d, p, directionalEnd) {
            var cap, split, dif, result, min = 1e-6;
            return null == v ? result = d : "number" == typeof v ? result = v : (cap = 360, 
            split = v.split("_"), dif = Number(split[0].replace(_NaNExp, "")) * (-1 === v.indexOf("rad") ? 1 : _RAD2DEG) - ("=" === v.charAt(1) ? 0 : d), 
            split.length && (directionalEnd && (directionalEnd[p] = d + dif), -1 !== v.indexOf("short") && (dif %= cap, 
            dif !== dif % (cap / 2) && (dif = 0 > dif ? dif + cap : dif - cap)), -1 !== v.indexOf("_cw") && 0 > dif ? dif = (dif + 9999999999 * cap) % cap - (dif / cap | 0) * cap : -1 !== v.indexOf("ccw") && dif > 0 && (dif = (dif - 9999999999 * cap) % cap - (dif / cap | 0) * cap)), 
            result = d + dif), min > result && result > -min && (result = 0), result;
        }, _colorLookup = {
            aqua: [ 0, 255, 255 ],
            lime: [ 0, 255, 0 ],
            silver: [ 192, 192, 192 ],
            black: [ 0, 0, 0 ],
            maroon: [ 128, 0, 0 ],
            teal: [ 0, 128, 128 ],
            blue: [ 0, 0, 255 ],
            navy: [ 0, 0, 128 ],
            white: [ 255, 255, 255 ],
            fuchsia: [ 255, 0, 255 ],
            olive: [ 128, 128, 0 ],
            yellow: [ 255, 255, 0 ],
            orange: [ 255, 165, 0 ],
            gray: [ 128, 128, 128 ],
            purple: [ 128, 0, 128 ],
            green: [ 0, 128, 0 ],
            red: [ 255, 0, 0 ],
            pink: [ 255, 192, 203 ],
            cyan: [ 0, 255, 255 ],
            transparent: [ 255, 255, 255, 0 ]
        }, _hue = function(h, m1, m2) {
            return h = 0 > h ? h + 1 : h > 1 ? h - 1 : h, 255 * (1 > 6 * h ? m1 + (m2 - m1) * h * 6 : .5 > h ? m2 : 2 > 3 * h ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) + .5 | 0;
        }, _parseColor = function(v) {
            var c1, c2, c3, h, s, l;
            return v && "" !== v ? "number" == typeof v ? [ v >> 16, v >> 8 & 255, 255 & v ] : ("," === v.charAt(v.length - 1) && (v = v.substr(0, v.length - 1)), 
            _colorLookup[v] ? _colorLookup[v] : "#" === v.charAt(0) ? (4 === v.length && (c1 = v.charAt(1), 
            c2 = v.charAt(2), c3 = v.charAt(3), v = "#" + c1 + c1 + c2 + c2 + c3 + c3), v = parseInt(v.substr(1), 16), 
            [ v >> 16, v >> 8 & 255, 255 & v ]) : "hsl" === v.substr(0, 3) ? (v = v.match(_numExp), 
            h = Number(v[0]) % 360 / 360, s = Number(v[1]) / 100, l = Number(v[2]) / 100, c2 = .5 >= l ? l * (s + 1) : l + s - l * s, 
            c1 = 2 * l - c2, v.length > 3 && (v[3] = Number(v[3])), v[0] = _hue(h + 1 / 3, c1, c2), 
            v[1] = _hue(h, c1, c2), v[2] = _hue(h - 1 / 3, c1, c2), v) : (v = v.match(_numExp) || _colorLookup.transparent, 
            v[0] = Number(v[0]), v[1] = Number(v[1]), v[2] = Number(v[2]), v.length > 3 && (v[3] = Number(v[3])), 
            v)) : _colorLookup.black;
        }, _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
        for (p in _colorLookup) _colorExp += "|" + p + "\\b";
        _colorExp = new RegExp(_colorExp + ")", "gi");
        var _getFormatter = function(dflt, clr, collapsible, multi) {
            if (null == dflt) return function(v) {
                return v;
            };
            var formatter, dColor = clr ? (dflt.match(_colorExp) || [ "" ])[0] : "", dVals = dflt.split(dColor).join("").match(_valuesExp) || [], pfx = dflt.substr(0, dflt.indexOf(dVals[0])), sfx = ")" === dflt.charAt(dflt.length - 1) ? ")" : "", delim = -1 !== dflt.indexOf(" ") ? " " : ",", numVals = dVals.length, dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "";
            return numVals ? formatter = clr ? function(v) {
                var color, vals, i, a;
                if ("number" == typeof v) v += dSfx; else if (multi && _commasOutsideParenExp.test(v)) {
                    for (a = v.replace(_commasOutsideParenExp, "|").split("|"), i = 0; i < a.length; i++) a[i] = formatter(a[i]);
                    return a.join(",");
                }
                if (color = (v.match(_colorExp) || [ dColor ])[0], vals = v.split(color).join("").match(_valuesExp) || [], 
                i = vals.length, numVals > i--) for (;++i < numVals; ) vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
                return pfx + vals.join(delim) + delim + color + sfx + (-1 !== v.indexOf("inset") ? " inset" : "");
            } : function(v) {
                var vals, a, i;
                if ("number" == typeof v) v += dSfx; else if (multi && _commasOutsideParenExp.test(v)) {
                    for (a = v.replace(_commasOutsideParenExp, "|").split("|"), i = 0; i < a.length; i++) a[i] = formatter(a[i]);
                    return a.join(",");
                }
                if (vals = v.match(_valuesExp) || [], i = vals.length, numVals > i--) for (;++i < numVals; ) vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
                return pfx + vals.join(delim) + sfx;
            } : function(v) {
                return v;
            };
        }, _getEdgeParser = function(props) {
            return props = props.split(","), function(t, e, p, cssp, pt, plugin, vars) {
                var i, a = (e + "").split(" ");
                for (vars = {}, i = 0; 4 > i; i++) vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
                return cssp.parse(t, vars, pt, plugin);
            };
        }, MiniPropTween = (_internals._setPluginRatio = function(v) {
            this.plugin.setRatio(v);
            for (var val, pt, i, str, d = this.data, proxy = d.proxy, mpt = d.firstMPT, min = 1e-6; mpt; ) val = proxy[mpt.v], 
            mpt.r ? val = Math.round(val) : min > val && val > -min && (val = 0), mpt.t[mpt.p] = val, 
            mpt = mpt._next;
            if (d.autoRotate && (d.autoRotate.rotation = proxy.rotation), 1 === v) for (mpt = d.firstMPT; mpt; ) {
                if (pt = mpt.t, pt.type) {
                    if (1 === pt.type) {
                        for (str = pt.xs0 + pt.s + pt.xs1, i = 1; i < pt.l; i++) str += pt["xn" + i] + pt["xs" + (i + 1)];
                        pt.e = str;
                    }
                } else pt.e = pt.s + pt.xs0;
                mpt = mpt._next;
            }
        }, function(t, p, v, next, r) {
            this.t = t, this.p = p, this.v = v, this.r = r, next && (next._prev = this, this._next = next);
        }), CSSPropTween = (_internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
            var i, p, xp, mpt, firstPT, bpt = pt, start = {}, end = {}, transform = cssp._transform, oldForce = _forcePT;
            for (cssp._transform = null, _forcePT = vars, pt = firstPT = cssp.parse(t, vars, pt, plugin), 
            _forcePT = oldForce, shallow && (cssp._transform = transform, bpt && (bpt._prev = null, 
            bpt._prev && (bpt._prev._next = null))); pt && pt !== bpt; ) {
                if (pt.type <= 1 && (p = pt.p, end[p] = pt.s + pt.c, start[p] = pt.s, shallow || (mpt = new MiniPropTween(pt, "s", p, mpt, pt.r), 
                pt.c = 0), 1 === pt.type)) for (i = pt.l; --i > 0; ) xp = "xn" + i, p = pt.p + "_" + xp, 
                end[p] = pt.data[xp], start[p] = pt[xp], shallow || (mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]));
                pt = pt._next;
            }
            return {
                proxy: start,
                end: end,
                firstMPT: mpt,
                pt: firstPT
            };
        }, _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
            this.t = t, this.p = p, this.s = s, this.c = c, this.n = n || p, t instanceof CSSPropTween || _overwriteProps.push(this.n), 
            this.r = r, this.type = type || 0, pr && (this.pr = pr, _hasPriority = !0), this.b = void 0 === b ? s : b, 
            this.e = void 0 === e ? s + c : e, next && (this._next = next, next._prev = this);
        }), _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
            b = b || dflt || "", pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, !1, pr, b, e), 
            e += "";
            var i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str, ba = b.split(", ").join(",").split(" "), ea = e.split(", ").join(",").split(" "), l = ba.length, autoRound = _autoRound !== !1;
            for ((-1 !== e.indexOf(",") || -1 !== b.indexOf(",")) && (ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" "), 
            ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" "), l = ba.length), 
            l !== ea.length && (ba = (dflt || "").split(" "), l = ba.length), pt.plugin = plugin, 
            pt.setRatio = setRatio, i = 0; l > i; i++) if (bv = ba[i], ev = ea[i], bn = parseFloat(bv), 
            bn || 0 === bn) pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && -1 !== ev.indexOf("px"), !0); else if (clrs && ("#" === bv.charAt(0) || _colorLookup[bv] || _rgbhslExp.test(bv))) str = "," === ev.charAt(ev.length - 1) ? ")," : ")", 
            bv = _parseColor(bv), ev = _parseColor(ev), rgba = bv.length + ev.length > 6, rgba && !_supportsOpacity && 0 === ev[3] ? (pt["xs" + pt.l] += pt.l ? " transparent" : "transparent", 
            pt.e = pt.e.split(ea[i]).join("transparent")) : (_supportsOpacity || (rgba = !1), 
            pt.appendXtra(rgba ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", !0, !0).appendXtra("", bv[1], ev[1] - bv[1], ",", !0).appendXtra("", bv[2], ev[2] - bv[2], rgba ? "," : str, !0), 
            rgba && (bv = bv.length < 4 ? 1 : bv[3], pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, !1))); else if (bnums = bv.match(_numExp)) {
                if (enums = ev.match(_relNumExp), !enums || enums.length !== bnums.length) return pt;
                for (ni = 0, xi = 0; xi < bnums.length; xi++) cv = bnums[xi], temp = bv.indexOf(cv, ni), 
                pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && "px" === bv.substr(temp + cv.length, 2), 0 === xi), 
                ni = temp + cv.length;
                pt["xs" + pt.l] += bv.substr(ni);
            } else pt["xs" + pt.l] += pt.l ? " " + bv : bv;
            if (-1 !== e.indexOf("=") && pt.data) {
                for (str = pt.xs0 + pt.data.s, i = 1; i < pt.l; i++) str += pt["xs" + i] + pt.data["xn" + i];
                pt.e = str + pt["xs" + i];
            }
            return pt.l || (pt.type = -1, pt.xs0 = pt.e), pt.xfirst || pt;
        }, i = 9;
        for (p = CSSPropTween.prototype, p.l = p.pr = 0; --i > 0; ) p["xn" + i] = 0, p["xs" + i] = "";
        p.xs0 = "", p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null, 
        p.appendXtra = function(pfx, s, c, sfx, r, pad) {
            var pt = this, l = pt.l;
            return pt["xs" + l] += pad && l ? " " + pfx : pfx || "", c || 0 === l || pt.plugin ? (pt.l++, 
            pt.type = pt.setRatio ? 2 : 1, pt["xs" + pt.l] = sfx || "", l > 0 ? (pt.data["xn" + l] = s + c, 
            pt.rxp["xn" + l] = r, pt["xn" + l] = s, pt.plugin || (pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr), 
            pt.xfirst.xs0 = 0), pt) : (pt.data = {
                s: s + c
            }, pt.rxp = {}, pt.s = s, pt.c = c, pt.r = r, pt)) : (pt["xs" + l] += s + (sfx || ""), 
            pt);
        };
        var SpecialProp = function(p, options) {
            options = options || {}, this.p = options.prefix ? _checkPropPrefix(p) || p : p, 
            _specialProps[p] = _specialProps[this.p] = this, this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi), 
            options.parser && (this.parse = options.parser), this.clrs = options.color, this.multi = options.multi, 
            this.keyword = options.keyword, this.dflt = options.defaultValue, this.pr = options.priority || 0;
        }, _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
            "object" != typeof options && (options = {
                parser: defaults
            });
            var i, temp, a = p.split(","), d = options.defaultValue;
            for (defaults = defaults || [ d ], i = 0; i < a.length; i++) options.prefix = 0 === i && options.prefix, 
            options.defaultValue = defaults[i] || d, temp = new SpecialProp(a[i], options);
        }, _registerPluginProp = function(p) {
            if (!_specialProps[p]) {
                var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
                _registerComplexSpecialProp(p, {
                    parser: function(t, e, p, cssp, pt, plugin, vars) {
                        var pluginClass = (_gsScope.GreenSockGlobals || _gsScope).com.greensock.plugins[pluginName];
                        return pluginClass ? (pluginClass._cssRegister(), _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars)) : (_log("Error: " + pluginName + " js file not loaded."), 
                        pt);
                    }
                });
            }
        };
        p = SpecialProp.prototype, p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
            var i, ba, ea, l, bi, ei, kwd = this.keyword;
            if (this.multi && (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b) ? (ba = b.replace(_commasOutsideParenExp, "|").split("|"), 
            ea = e.replace(_commasOutsideParenExp, "|").split("|")) : kwd && (ba = [ b ], ea = [ e ])), 
            ea) {
                for (l = ea.length > ba.length ? ea.length : ba.length, i = 0; l > i; i++) b = ba[i] = ba[i] || this.dflt, 
                e = ea[i] = ea[i] || this.dflt, kwd && (bi = b.indexOf(kwd), ei = e.indexOf(kwd), 
                bi !== ei && (e = -1 === ei ? ea : ba, e[i] += " " + kwd));
                b = ba.join(", "), e = ea.join(", ");
            }
            return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
        }, p.parse = function(t, e, p, cssp, pt, plugin) {
            return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, !1, this.dflt)), this.format(e), pt, plugin);
        }, CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
            _registerComplexSpecialProp(name, {
                parser: function(t, e, p, cssp, pt, plugin) {
                    var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, !1, priority);
                    return rv.plugin = plugin, rv.setRatio = onInitTween(t, e, cssp._tween, p), rv;
                },
                priority: priority
            });
        };
        var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), _transformProp = _checkPropPrefix("transform"), _transformPropCSS = _prefixCSS + "transform", _transformOriginProp = _checkPropPrefix("transformOrigin"), _supports3D = null !== _checkPropPrefix("perspective"), Transform = _internals.Transform = function() {
            this.skewY = 0;
        }, _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
            if (t._gsTransform && rec && !parse) return t._gsTransform;
            var s, m, i, n, dec, scaleX, scaleY, rotation, skewX, difX, difY, difR, difS, tm = rec ? t._gsTransform || new Transform() : new Transform(), invX = tm.scaleX < 0, min = 2e-5, rnd = 1e5, minAngle = 179.99, minPI = minAngle * _DEG2RAD, zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, !1, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0;
            if (_transformProp ? s = _getStyle(t, _transformPropCSS, cs, !0) : t.currentStyle && (s = t.currentStyle.filter.match(_ieGetMatrixExp), 
            s = s && 4 === s.length ? [ s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0 ].join(",") : ""), 
            s && "none" !== s && "matrix(1, 0, 0, 1, 0, 0)" !== s) {
                for (m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], i = m.length; --i > -1; ) n = Number(m[i]), 
                m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (0 > dec ? -.5 : .5) | 0) / rnd + n : n;
                if (16 === m.length) {
                    var a13 = m[8], a23 = m[9], a33 = m[10], a14 = m[12], a24 = m[13], a34 = m[14];
                    if (tm.zOrigin && (a34 = -tm.zOrigin, a14 = a13 * a34 - m[12], a24 = a23 * a34 - m[13], 
                    a34 = a33 * a34 + tm.zOrigin - m[14]), !rec || parse || null == tm.rotationX) {
                        var t1, t2, t3, cos, sin, yFlip, zFlip, a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3], a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7], a43 = m[11], angle = Math.atan2(a32, a33), xFlip = -minPI > angle || angle > minPI;
                        tm.rotationX = angle * _RAD2DEG, angle && (cos = Math.cos(-angle), sin = Math.sin(-angle), 
                        t1 = a12 * cos + a13 * sin, t2 = a22 * cos + a23 * sin, t3 = a32 * cos + a33 * sin, 
                        a13 = a12 * -sin + a13 * cos, a23 = a22 * -sin + a23 * cos, a33 = a32 * -sin + a33 * cos, 
                        a43 = a42 * -sin + a43 * cos, a12 = t1, a22 = t2, a32 = t3), angle = Math.atan2(a13, a11), 
                        tm.rotationY = angle * _RAD2DEG, angle && (yFlip = -minPI > angle || angle > minPI, 
                        cos = Math.cos(-angle), sin = Math.sin(-angle), t1 = a11 * cos - a13 * sin, t2 = a21 * cos - a23 * sin, 
                        t3 = a31 * cos - a33 * sin, a23 = a21 * sin + a23 * cos, a33 = a31 * sin + a33 * cos, 
                        a43 = a41 * sin + a43 * cos, a11 = t1, a21 = t2, a31 = t3), angle = Math.atan2(a21, a22), 
                        tm.rotation = angle * _RAD2DEG, angle && (zFlip = -minPI > angle || angle > minPI, 
                        cos = Math.cos(-angle), sin = Math.sin(-angle), a11 = a11 * cos + a12 * sin, t2 = a21 * cos + a22 * sin, 
                        a22 = a21 * -sin + a22 * cos, a32 = a31 * -sin + a32 * cos, a21 = t2), zFlip && xFlip ? tm.rotation = tm.rotationX = 0 : zFlip && yFlip ? tm.rotation = tm.rotationY = 0 : yFlip && xFlip && (tm.rotationY = tm.rotationX = 0), 
                        tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + .5 | 0) / rnd, tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + .5 | 0) / rnd, 
                        tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + .5 | 0) / rnd, tm.skewX = 0, 
                        tm.perspective = a43 ? 1 / (0 > a43 ? -a43 : a43) : 0, tm.x = a14, tm.y = a24, tm.z = a34;
                    }
                } else if (!(_supports3D && !parse && m.length && tm.x === m[4] && tm.y === m[5] && (tm.rotationX || tm.rotationY) || void 0 !== tm.x && "none" === _getStyle(t, "display", cs))) {
                    var k = m.length >= 6, a = k ? m[0] : 1, b = m[1] || 0, c = m[2] || 0, d = k ? m[3] : 1;
                    tm.x = m[4] || 0, tm.y = m[5] || 0, scaleX = Math.sqrt(a * a + b * b), scaleY = Math.sqrt(d * d + c * c), 
                    rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0, skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0, 
                    difX = scaleX - Math.abs(tm.scaleX || 0), difY = scaleY - Math.abs(tm.scaleY || 0), 
                    Math.abs(skewX) > 90 && Math.abs(skewX) < 270 && (invX ? (scaleX *= -1, skewX += 0 >= rotation ? 180 : -180, 
                    rotation += 0 >= rotation ? 180 : -180) : (scaleY *= -1, skewX += 0 >= skewX ? 180 : -180)), 
                    difR = (rotation - tm.rotation) % 180, difS = (skewX - tm.skewX) % 180, (void 0 === tm.skewX || difX > min || -min > difX || difY > min || -min > difY || difR > -minAngle && minAngle > difR && difR * rnd | !1 || difS > -minAngle && minAngle > difS && difS * rnd | !1) && (tm.scaleX = scaleX, 
                    tm.scaleY = scaleY, tm.rotation = rotation, tm.skewX = skewX), _supports3D && (tm.rotationX = tm.rotationY = tm.z = 0, 
                    tm.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0, tm.scaleZ = 1);
                }
                tm.zOrigin = zOrigin;
                for (i in tm) tm[i] < min && tm[i] > -min && (tm[i] = 0);
            } else tm = {
                x: 0,
                y: 0,
                z: 0,
                scaleX: 1,
                scaleY: 1,
                scaleZ: 1,
                skewX: 0,
                perspective: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                zOrigin: 0
            };
            return rec && (t._gsTransform = tm), tm.xPercent = tm.yPercent = 0, tm;
        }, _setIETransformRatio = function(v) {
            var filters, val, t = this.data, ang = -t.rotation * _DEG2RAD, skew = ang + t.skewX * _DEG2RAD, rnd = 1e5, a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd, b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd, c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd, d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd, style = this.t.style, cs = this.t.currentStyle;
            if (cs) {
                val = b, b = -c, c = -val, filters = cs.filter, style.filter = "";
                var dx, dy, w = this.t.offsetWidth, h = this.t.offsetHeight, clip = "absolute" !== cs.position, m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d, ox = t.x + w * t.xPercent / 100, oy = t.y + h * t.yPercent / 100;
                if (null != t.ox && (dx = (t.oxp ? w * t.ox * .01 : t.ox) - w / 2, dy = (t.oyp ? h * t.oy * .01 : t.oy) - h / 2, 
                ox += dx - (dx * a + dy * b), oy += dy - (dx * c + dy * d)), clip ? (dx = w / 2, 
                dy = h / 2, m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")") : m += ", sizingMethod='auto expand')", 
                style.filter = -1 !== filters.indexOf("DXImageTransform.Microsoft.Matrix(") ? filters.replace(_ieSetMatrixExp, m) : m + " " + filters, 
                (0 === v || 1 === v) && 1 === a && 0 === b && 0 === c && 1 === d && (clip && -1 === m.indexOf("Dx=0, Dy=0") || _opacityExp.test(filters) && 100 !== parseFloat(RegExp.$1) || -1 === filters.indexOf("gradient(" && filters.indexOf("Alpha")) && style.removeAttribute("filter")), 
                !clip) {
                    var marg, prop, dif, mult = 8 > _ieVers ? 1 : -1;
                    for (dx = t.ieOffsetX || 0, dy = t.ieOffsetY || 0, t.ieOffsetX = Math.round((w - ((0 > a ? -a : a) * w + (0 > b ? -b : b) * h)) / 2 + ox), 
                    t.ieOffsetY = Math.round((h - ((0 > d ? -d : d) * h + (0 > c ? -c : c) * w)) / 2 + oy), 
                    i = 0; 4 > i; i++) prop = _margins[i], marg = cs[prop], val = -1 !== marg.indexOf("px") ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0, 
                    dif = val !== t[prop] ? 2 > i ? -t.ieOffsetX : -t.ieOffsetY : 2 > i ? dx - t.ieOffsetX : dy - t.ieOffsetY, 
                    style[prop] = (t[prop] = Math.round(val - dif * (0 === i || 2 === i ? 1 : mult))) + "px";
                }
            }
        }, _set3DTransformRatio = _internals.set3DTransformRatio = function(v) {
            var a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, zOrigin, rnd, cos, sin, t1, t2, t3, t4, t = this.data, style = this.t.style, angle = t.rotation * _DEG2RAD, sx = t.scaleX, sy = t.scaleY, sz = t.scaleZ, x = t.x, y = t.y, z = t.z, perspective = t.perspective;
            if ((1 === v || 0 === v) && "auto" === t.force3D && !(t.rotationY || t.rotationX || 1 !== sz || perspective || z)) return void _set2DTransformRatio.call(this, v);
            if (_isFirefox) {
                var n = 1e-4;
                n > sx && sx > -n && (sx = sz = 2e-5), n > sy && sy > -n && (sy = sz = 2e-5), !perspective || t.z || t.rotationX || t.rotationY || (perspective = 0);
            }
            if (angle || t.skewX) cos = Math.cos(angle), sin = Math.sin(angle), a11 = cos, a21 = sin, 
            t.skewX && (angle -= t.skewX * _DEG2RAD, cos = Math.cos(angle), sin = Math.sin(angle), 
            "simple" === t.skewType && (t1 = Math.tan(t.skewX * _DEG2RAD), t1 = Math.sqrt(1 + t1 * t1), 
            cos *= t1, sin *= t1)), a12 = -sin, a22 = cos; else {
                if (!(t.rotationY || t.rotationX || 1 !== sz || perspective)) return void (style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (1 !== sx || 1 !== sy ? " scale(" + sx + "," + sy + ")" : ""));
                a11 = a22 = 1, a12 = a21 = 0;
            }
            a33 = 1, a13 = a14 = a23 = a24 = a31 = a32 = a34 = a41 = a42 = 0, a43 = perspective ? -1 / perspective : 0, 
            zOrigin = t.zOrigin, rnd = 1e5, angle = t.rotationY * _DEG2RAD, angle && (cos = Math.cos(angle), 
            sin = Math.sin(angle), a31 = a33 * -sin, a41 = a43 * -sin, a13 = a11 * sin, a23 = a21 * sin, 
            a33 *= cos, a43 *= cos, a11 *= cos, a21 *= cos), angle = t.rotationX * _DEG2RAD, 
            angle && (cos = Math.cos(angle), sin = Math.sin(angle), t1 = a12 * cos + a13 * sin, 
            t2 = a22 * cos + a23 * sin, t3 = a32 * cos + a33 * sin, t4 = a42 * cos + a43 * sin, 
            a13 = a12 * -sin + a13 * cos, a23 = a22 * -sin + a23 * cos, a33 = a32 * -sin + a33 * cos, 
            a43 = a42 * -sin + a43 * cos, a12 = t1, a22 = t2, a32 = t3, a42 = t4), 1 !== sz && (a13 *= sz, 
            a23 *= sz, a33 *= sz, a43 *= sz), 1 !== sy && (a12 *= sy, a22 *= sy, a32 *= sy, 
            a42 *= sy), 1 !== sx && (a11 *= sx, a21 *= sx, a31 *= sx, a41 *= sx), zOrigin && (a34 -= zOrigin, 
            a14 = a13 * a34, a24 = a23 * a34, a34 = a33 * a34 + zOrigin), a14 = (t1 = (a14 += x) - (a14 |= 0)) ? (t1 * rnd + (0 > t1 ? -.5 : .5) | 0) / rnd + a14 : a14, 
            a24 = (t1 = (a24 += y) - (a24 |= 0)) ? (t1 * rnd + (0 > t1 ? -.5 : .5) | 0) / rnd + a24 : a24, 
            a34 = (t1 = (a34 += z) - (a34 |= 0)) ? (t1 * rnd + (0 > t1 ? -.5 : .5) | 0) / rnd + a34 : a34, 
            style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(") + [ (a11 * rnd | 0) / rnd, (a21 * rnd | 0) / rnd, (a31 * rnd | 0) / rnd, (a41 * rnd | 0) / rnd, (a12 * rnd | 0) / rnd, (a22 * rnd | 0) / rnd, (a32 * rnd | 0) / rnd, (a42 * rnd | 0) / rnd, (a13 * rnd | 0) / rnd, (a23 * rnd | 0) / rnd, (a33 * rnd | 0) / rnd, (a43 * rnd | 0) / rnd, a14, a24, a34, perspective ? 1 + -a34 / perspective : 1 ].join(",") + ")";
        }, _set2DTransformRatio = _internals.set2DTransformRatio = function(v) {
            var ang, skew, rnd, sx, sy, t = this.data, targ = this.t, style = targ.style, x = t.x, y = t.y;
            return t.rotationX || t.rotationY || t.z || t.force3D === !0 || "auto" === t.force3D && 1 !== v && 0 !== v ? (this.setRatio = _set3DTransformRatio, 
            void _set3DTransformRatio.call(this, v)) : void (t.rotation || t.skewX ? (ang = t.rotation * _DEG2RAD, 
            skew = ang - t.skewX * _DEG2RAD, rnd = 1e5, sx = t.scaleX * rnd, sy = t.scaleY * rnd, 
            style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + (Math.cos(ang) * sx | 0) / rnd + "," + (Math.sin(ang) * sx | 0) / rnd + "," + (Math.sin(skew) * -sy | 0) / rnd + "," + (Math.cos(skew) * sy | 0) / rnd + "," + x + "," + y + ")") : style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + t.scaleX + ",0,0," + t.scaleY + "," + x + "," + y + ")");
        };
        _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
                if (cssp._transform) return pt;
                var m2, skewY, copy, orig, has3D, hasChange, dr, m1 = cssp._transform = _getTransform(t, _cs, !0, vars.parseTransform), style = t.style, min = 1e-6, i = _transformProps.length, v = vars, endRotations = {};
                if ("string" == typeof v.transform && _transformProp) copy = _tempDiv.style, copy[_transformProp] = v.transform, 
                copy.display = "block", copy.position = "absolute", _doc.body.appendChild(_tempDiv), 
                m2 = _getTransform(_tempDiv, null, !1), _doc.body.removeChild(_tempDiv); else if ("object" == typeof v) {
                    if (m2 = {
                        scaleX: _parseVal(null != v.scaleX ? v.scaleX : v.scale, m1.scaleX),
                        scaleY: _parseVal(null != v.scaleY ? v.scaleY : v.scale, m1.scaleY),
                        scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                        x: _parseVal(v.x, m1.x),
                        y: _parseVal(v.y, m1.y),
                        z: _parseVal(v.z, m1.z),
                        xPercent: _parseVal(v.xPercent, m1.xPercent),
                        yPercent: _parseVal(v.yPercent, m1.yPercent),
                        perspective: _parseVal(v.transformPerspective, m1.perspective)
                    }, dr = v.directionalRotation, null != dr) if ("object" == typeof dr) for (copy in dr) v[copy] = dr[copy]; else v.rotation = dr;
                    "string" == typeof v.x && -1 !== v.x.indexOf("%") && (m2.x = 0, m2.xPercent = _parseVal(v.x, m1.xPercent)), 
                    "string" == typeof v.y && -1 !== v.y.indexOf("%") && (m2.y = 0, m2.yPercent = _parseVal(v.y, m1.yPercent)), 
                    m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations), 
                    _supports3D && (m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations), 
                    m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations)), 
                    m2.skewX = null == v.skewX ? m1.skewX : _parseAngle(v.skewX, m1.skewX), m2.skewY = null == v.skewY ? m1.skewY : _parseAngle(v.skewY, m1.skewY), 
                    (skewY = m2.skewY - m1.skewY) && (m2.skewX += skewY, m2.rotation += skewY);
                }
                for (_supports3D && null != v.force3D && (m1.force3D = v.force3D, hasChange = !0), 
                m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType, has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective, 
                has3D || null == v.scale || (m2.scaleZ = 1); --i > -1; ) p = _transformProps[i], 
                orig = m2[p] - m1[p], (orig > min || -min > orig || null != _forcePT[p]) && (hasChange = !0, 
                pt = new CSSPropTween(m1, p, m1[p], orig, pt), p in endRotations && (pt.e = endRotations[p]), 
                pt.xs0 = 0, pt.plugin = plugin, cssp._overwriteProps.push(pt.n));
                return orig = v.transformOrigin, (orig || _supports3D && has3D && m1.zOrigin) && (_transformProp ? (hasChange = !0, 
                p = _transformOriginProp, orig = (orig || _getStyle(t, p, _cs, !1, "50% 50%")) + "", 
                pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin"), pt.b = style[p], 
                pt.plugin = plugin, _supports3D ? (copy = m1.zOrigin, orig = orig.split(" "), m1.zOrigin = (orig.length > 2 && (0 === copy || "0px" !== orig[2]) ? parseFloat(orig[2]) : copy) || 0, 
                pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px", pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n), 
                pt.b = copy, pt.xs0 = pt.e = m1.zOrigin) : pt.xs0 = pt.e = orig) : _parsePosition(orig + "", m1)), 
                hasChange && (cssp._transformType = has3D || 3 === this._transformType ? 3 : 2), 
                pt;
            },
            prefix: !0
        }), _registerComplexSpecialProp("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: !0,
            color: !0,
            multi: !0,
            keyword: "inset"
        }), _registerComplexSpecialProp("borderRadius", {
            defaultValue: "0px",
            parser: function(t, e, p, cssp, pt) {
                e = this.format(e);
                var ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em, props = [ "borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius" ], style = t.style;
                for (w = parseFloat(t.offsetWidth), h = parseFloat(t.offsetHeight), ea1 = e.split(" "), 
                i = 0; i < props.length; i++) this.p.indexOf("border") && (props[i] = _checkPropPrefix(props[i])), 
                bs = bs2 = _getStyle(t, props[i], _cs, !1, "0px"), -1 !== bs.indexOf(" ") && (bs2 = bs.split(" "), 
                bs = bs2[0], bs2 = bs2[1]), es = es2 = ea1[i], bn = parseFloat(bs), bsfx = bs.substr((bn + "").length), 
                rel = "=" === es.charAt(1), rel ? (en = parseInt(es.charAt(0) + "1", 10), es = es.substr(2), 
                en *= parseFloat(es), esfx = es.substr((en + "").length - (0 > en ? 1 : 0)) || "") : (en = parseFloat(es), 
                esfx = es.substr((en + "").length)), "" === esfx && (esfx = _suffixMap[p] || bsfx), 
                esfx !== bsfx && (hn = _convertToPixels(t, "borderLeft", bn, bsfx), vn = _convertToPixels(t, "borderTop", bn, bsfx), 
                "%" === esfx ? (bs = hn / w * 100 + "%", bs2 = vn / h * 100 + "%") : "em" === esfx ? (em = _convertToPixels(t, "borderLeft", 1, "em"), 
                bs = hn / em + "em", bs2 = vn / em + "em") : (bs = hn + "px", bs2 = vn + "px"), 
                rel && (es = parseFloat(bs) + en + esfx, es2 = parseFloat(bs2) + en + esfx)), pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, !1, "0px", pt);
                return pt;
            },
            prefix: !0,
            formatter: _getFormatter("0px 0px 0px 0px", !1, !0)
        }), _registerComplexSpecialProp("backgroundPosition", {
            defaultValue: "0 0",
            parser: function(t, e, p, cssp, pt, plugin) {
                var ba, ea, i, pct, overlap, src, bp = "background-position", cs = _cs || _getComputedStyle(t, null), bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), es = this.format(e);
                if (-1 !== bs.indexOf("%") != (-1 !== es.indexOf("%")) && (src = _getStyle(t, "backgroundImage").replace(_urlExp, ""), 
                src && "none" !== src)) {
                    for (ba = bs.split(" "), ea = es.split(" "), _tempImg.setAttribute("src", src), 
                    i = 2; --i > -1; ) bs = ba[i], pct = -1 !== bs.indexOf("%"), pct !== (-1 !== ea[i].indexOf("%")) && (overlap = 0 === i ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height, 
                    ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%");
                    bs = ba.join(" ");
                }
                return this.parseComplex(t.style, bs, es, pt, plugin);
            },
            formatter: _parsePosition
        }), _registerComplexSpecialProp("backgroundSize", {
            defaultValue: "0 0",
            formatter: _parsePosition
        }), _registerComplexSpecialProp("perspective", {
            defaultValue: "0px",
            prefix: !0
        }), _registerComplexSpecialProp("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: !0
        }), _registerComplexSpecialProp("transformStyle", {
            prefix: !0
        }), _registerComplexSpecialProp("backfaceVisibility", {
            prefix: !0
        }), _registerComplexSpecialProp("userSelect", {
            prefix: !0
        }), _registerComplexSpecialProp("margin", {
            parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
        }), _registerComplexSpecialProp("padding", {
            parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
        }), _registerComplexSpecialProp("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function(t, e, p, cssp, pt, plugin) {
                var b, cs, delim;
                return 9 > _ieVers ? (cs = t.currentStyle, delim = 8 > _ieVers ? " " : ",", b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")", 
                e = this.format(e).split(",").join(delim)) : (b = this.format(_getStyle(t, this.p, _cs, !1, this.dflt)), 
                e = this.format(e)), this.parseComplex(t.style, b, e, pt, plugin);
            }
        }), _registerComplexSpecialProp("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0
        }), _registerComplexSpecialProp("autoRound,strictUnits", {
            parser: function(t, e, p, cssp, pt) {
                return pt;
            }
        }), _registerComplexSpecialProp("border", {
            defaultValue: "0px solid #000",
            parser: function(t, e, p, cssp, pt, plugin) {
                return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, !1, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, !1, "solid") + " " + _getStyle(t, "borderTopColor", _cs, !1, "#000")), this.format(e), pt, plugin);
            },
            color: !0,
            formatter: function(v) {
                var a = v.split(" ");
                return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || [ "#000" ])[0];
            }
        }), _registerComplexSpecialProp("borderWidth", {
            parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        }), _registerComplexSpecialProp("float,cssFloat,styleFloat", {
            parser: function(t, e, p, cssp, pt) {
                var s = t.style, prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
                return new CSSPropTween(s, prop, 0, 0, pt, -1, p, !1, 0, s[prop], e);
            }
        });
        var _setIEOpacityRatio = function(v) {
            var skip, t = this.t, filters = t.filter || _getStyle(this.data, "filter"), val = this.s + this.c * v | 0;
            100 === val && (-1 === filters.indexOf("atrix(") && -1 === filters.indexOf("radient(") && -1 === filters.indexOf("oader(") ? (t.removeAttribute("filter"), 
            skip = !_getStyle(this.data, "filter")) : (t.filter = filters.replace(_alphaFilterExp, ""), 
            skip = !0)), skip || (this.xn1 && (t.filter = filters = filters || "alpha(opacity=" + val + ")"), 
            -1 === filters.indexOf("pacity") ? 0 === val && this.xn1 || (t.filter = filters + " alpha(opacity=" + val + ")") : t.filter = filters.replace(_opacityExp, "opacity=" + val));
        };
        _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
            defaultValue: "1",
            parser: function(t, e, p, cssp, pt, plugin) {
                var b = parseFloat(_getStyle(t, "opacity", _cs, !1, "1")), style = t.style, isAutoAlpha = "autoAlpha" === p;
                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + b), 
                isAutoAlpha && 1 === b && "hidden" === _getStyle(t, "visibility", _cs) && 0 !== e && (b = 0), 
                _supportsOpacity ? pt = new CSSPropTween(style, "opacity", b, e - b, pt) : (pt = new CSSPropTween(style, "opacity", 100 * b, 100 * (e - b), pt), 
                pt.xn1 = isAutoAlpha ? 1 : 0, style.zoom = 1, pt.type = 2, pt.b = "alpha(opacity=" + pt.s + ")", 
                pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")", pt.data = t, pt.plugin = plugin, 
                pt.setRatio = _setIEOpacityRatio), isAutoAlpha && (pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, !1, 0, 0 !== b ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), 
                pt.xs0 = "inherit", cssp._overwriteProps.push(pt.n), cssp._overwriteProps.push(p)), 
                pt;
            }
        });
        var _removeProp = function(s, p) {
            p && (s.removeProperty ? ("ms" === p.substr(0, 2) && (p = "M" + p.substr(1)), s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())) : s.removeAttribute(p));
        }, _setClassNameRatio = function(v) {
            if (this.t._gsClassPT = this, 1 === v || 0 === v) {
                this.t.setAttribute("class", 0 === v ? this.b : this.e);
                for (var mpt = this.data, s = this.t.style; mpt; ) mpt.v ? s[mpt.p] = mpt.v : _removeProp(s, mpt.p), 
                mpt = mpt._next;
                1 === v && this.t._gsClassPT === this && (this.t._gsClassPT = null);
            } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
        };
        _registerComplexSpecialProp("className", {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
                var difData, bs, cnpt, cnptLookup, mpt, b = t.getAttribute("class") || "", cssText = t.style.cssText;
                if (pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2), pt.setRatio = _setClassNameRatio, 
                pt.pr = -11, _hasPriority = !0, pt.b = b, bs = _getAllStyles(t, _cs), cnpt = t._gsClassPT) {
                    for (cnptLookup = {}, mpt = cnpt.data; mpt; ) cnptLookup[mpt.p] = 1, mpt = mpt._next;
                    cnpt.setRatio(1);
                }
                return t._gsClassPT = pt, pt.e = "=" !== e.charAt(1) ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), 
                cssp._tween._duration && (t.setAttribute("class", pt.e), difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup), 
                t.setAttribute("class", b), pt.data = difData.firstMPT, t.style.cssText = cssText, 
                pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin)), pt;
            }
        });
        var _setClearPropsRatio = function(v) {
            if ((1 === v || 0 === v) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var a, p, i, clearTransform, s = this.t.style, transformParse = _specialProps.transform.parse;
                if ("all" === this.e) s.cssText = "", clearTransform = !0; else for (a = this.e.split(","), 
                i = a.length; --i > -1; ) p = a[i], _specialProps[p] && (_specialProps[p].parse === transformParse ? clearTransform = !0 : p = "transformOrigin" === p ? _transformOriginProp : _specialProps[p].p), 
                _removeProp(s, p);
                clearTransform && (_removeProp(s, _transformProp), this.t._gsTransform && delete this.t._gsTransform);
            }
        };
        for (_registerComplexSpecialProp("clearProps", {
            parser: function(t, e, p, cssp, pt) {
                return pt = new CSSPropTween(t, p, 0, 0, pt, 2), pt.setRatio = _setClearPropsRatio, 
                pt.e = e, pt.pr = -10, pt.data = cssp._tween, _hasPriority = !0, pt;
            }
        }), p = "bezier,throwProps,physicsProps,physics2D".split(","), i = p.length; i--; ) _registerPluginProp(p[i]);
        p = CSSPlugin.prototype, p._firstPT = null, p._onInitTween = function(target, vars, tween) {
            if (!target.nodeType) return !1;
            this._target = target, this._tween = tween, this._vars = vars, _autoRound = vars.autoRound, 
            _hasPriority = !1, _suffixMap = vars.suffixMap || CSSPlugin.suffixMap, _cs = _getComputedStyle(target, ""), 
            _overwriteProps = this._overwriteProps;
            var v, pt, pt2, first, last, next, zIndex, tpt, threeD, style = target.style;
            if (_reqSafariFix && "" === style.zIndex && (v = _getStyle(target, "zIndex", _cs), 
            ("auto" === v || "" === v) && this._addLazySet(style, "zIndex", 0)), "string" == typeof vars && (first = style.cssText, 
            v = _getAllStyles(target, _cs), style.cssText = first + ";" + vars, v = _cssDif(target, v, _getAllStyles(target)).difs, 
            !_supportsOpacity && _opacityValExp.test(vars) && (v.opacity = parseFloat(RegExp.$1)), 
            vars = v, style.cssText = first), this._firstPT = pt = this.parse(target, vars, null), 
            this._transformType) {
                for (threeD = 3 === this._transformType, _transformProp ? _isSafari && (_reqSafariFix = !0, 
                "" === style.zIndex && (zIndex = _getStyle(target, "zIndex", _cs), ("auto" === zIndex || "" === zIndex) && this._addLazySet(style, "zIndex", 0)), 
                _isSafariLT6 && this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"))) : style.zoom = 1, 
                pt2 = pt; pt2 && pt2._next; ) pt2 = pt2._next;
                tpt = new CSSPropTween(target, "transform", 0, 0, null, 2), this._linkCSSP(tpt, null, pt2), 
                tpt.setRatio = threeD && _supports3D ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio, 
                tpt.data = this._transform || _getTransform(target, _cs, !0), _overwriteProps.pop();
            }
            if (_hasPriority) {
                for (;pt; ) {
                    for (next = pt._next, pt2 = first; pt2 && pt2.pr > pt.pr; ) pt2 = pt2._next;
                    (pt._prev = pt2 ? pt2._prev : last) ? pt._prev._next = pt : first = pt, (pt._next = pt2) ? pt2._prev = pt : last = pt, 
                    pt = next;
                }
                this._firstPT = first;
            }
            return !0;
        }, p.parse = function(target, vars, pt, plugin) {
            var p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel, style = target.style;
            for (p in vars) es = vars[p], sp = _specialProps[p], sp ? pt = sp.parse(target, es, p, this, pt, plugin, vars) : (bs = _getStyle(target, p, _cs) + "", 
            isStr = "string" == typeof es, "color" === p || "fill" === p || "stroke" === p || -1 !== p.indexOf("Color") || isStr && _rgbhslExp.test(es) ? (isStr || (es = _parseColor(es), 
            es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")"), pt = _parseComplex(style, p, bs, es, !0, "transparent", pt, 0, plugin)) : !isStr || -1 === es.indexOf(" ") && -1 === es.indexOf(",") ? (bn = parseFloat(bs), 
            bsfx = bn || 0 === bn ? bs.substr((bn + "").length) : "", ("" === bs || "auto" === bs) && ("width" === p || "height" === p ? (bn = _getDimension(target, p, _cs), 
            bsfx = "px") : "left" === p || "top" === p ? (bn = _calculateOffset(target, p, _cs), 
            bsfx = "px") : (bn = "opacity" !== p ? 0 : 1, bsfx = "")), rel = isStr && "=" === es.charAt(1), 
            rel ? (en = parseInt(es.charAt(0) + "1", 10), es = es.substr(2), en *= parseFloat(es), 
            esfx = es.replace(_suffixExp, "")) : (en = parseFloat(es), esfx = isStr ? es.substr((en + "").length) || "" : ""), 
            "" === esfx && (esfx = p in _suffixMap ? _suffixMap[p] : bsfx), es = en || 0 === en ? (rel ? en + bn : en) + esfx : vars[p], 
            bsfx !== esfx && "" !== esfx && (en || 0 === en) && bn && (bn = _convertToPixels(target, p, bn, bsfx), 
            "%" === esfx ? (bn /= _convertToPixels(target, p, 100, "%") / 100, vars.strictUnits !== !0 && (bs = bn + "%")) : "em" === esfx ? bn /= _convertToPixels(target, p, 1, "em") : "px" !== esfx && (en = _convertToPixels(target, p, en, esfx), 
            esfx = "px"), rel && (en || 0 === en) && (es = en + bn + esfx)), rel && (en += bn), 
            !bn && 0 !== bn || !en && 0 !== en ? void 0 !== style[p] && (es || es + "" != "NaN" && null != es) ? (pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, !1, 0, bs, es), 
            pt.xs0 = "none" !== es || "display" !== p && -1 === p.indexOf("Style") ? es : bs) : _log("invalid " + p + " tween value: " + vars[p]) : (pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== !1 && ("px" === esfx || "zIndex" === p), 0, bs, es), 
            pt.xs0 = esfx)) : pt = _parseComplex(style, p, bs, es, !0, null, pt, 0, plugin)), 
            plugin && pt && !pt.plugin && (pt.plugin = plugin);
            return pt;
        }, p.setRatio = function(v) {
            var val, str, i, pt = this._firstPT, min = 1e-6;
            if (1 !== v || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (v || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (;pt; ) {
                if (val = pt.c * v + pt.s, pt.r ? val = Math.round(val) : min > val && val > -min && (val = 0), 
                pt.type) if (1 === pt.type) if (i = pt.l, 2 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2; else if (3 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3; else if (4 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4; else if (5 === i) pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5; else {
                    for (str = pt.xs0 + val + pt.xs1, i = 1; i < pt.l; i++) str += pt["xn" + i] + pt["xs" + (i + 1)];
                    pt.t[pt.p] = str;
                } else -1 === pt.type ? pt.t[pt.p] = pt.xs0 : pt.setRatio && pt.setRatio(v); else pt.t[pt.p] = val + pt.xs0;
                pt = pt._next;
            } else for (;pt; ) 2 !== pt.type ? pt.t[pt.p] = pt.b : pt.setRatio(v), pt = pt._next; else for (;pt; ) 2 !== pt.type ? pt.t[pt.p] = pt.e : pt.setRatio(v), 
            pt = pt._next;
        }, p._enableTransforms = function(threeD) {
            this._transformType = threeD || 3 === this._transformType ? 3 : 2, this._transform = this._transform || _getTransform(this._target, _cs, !0);
        };
        var lazySet = function() {
            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
        };
        p._addLazySet = function(t, p, v) {
            var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
            pt.e = v, pt.setRatio = lazySet, pt.data = this;
        }, p._linkCSSP = function(pt, next, prev, remove) {
            return pt && (next && (next._prev = pt), pt._next && (pt._next._prev = pt._prev), 
            pt._prev ? pt._prev._next = pt._next : this._firstPT === pt && (this._firstPT = pt._next, 
            remove = !0), prev ? prev._next = pt : remove || null !== this._firstPT || (this._firstPT = pt), 
            pt._next = next, pt._prev = prev), pt;
        }, p._kill = function(lookup) {
            var pt, p, xfirst, copy = lookup;
            if (lookup.autoAlpha || lookup.alpha) {
                copy = {};
                for (p in lookup) copy[p] = lookup[p];
                copy.opacity = 1, copy.autoAlpha && (copy.visibility = 1);
            }
            return lookup.className && (pt = this._classNamePT) && (xfirst = pt.xfirst, xfirst && xfirst._prev ? this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev) : xfirst === this._firstPT && (this._firstPT = pt._next), 
            pt._next && this._linkCSSP(pt._next, pt._next._next, xfirst._prev), this._classNamePT = null), 
            TweenPlugin.prototype._kill.call(this, copy);
        };
        var _getChildStyles = function(e, props, targets) {
            var children, i, child, type;
            if (e.slice) for (i = e.length; --i > -1; ) _getChildStyles(e[i], props, targets); else for (children = e.childNodes, 
            i = children.length; --i > -1; ) child = children[i], type = child.type, child.style && (props.push(_getAllStyles(child)), 
            targets && targets.push(child)), 1 !== type && 9 !== type && 11 !== type || !child.childNodes.length || _getChildStyles(child, props, targets);
        };
        return CSSPlugin.cascadeTo = function(target, duration, vars) {
            var i, difs, p, tween = TweenLite.to(target, duration, vars), results = [ tween ], b = [], e = [], targets = [], _reservedProps = TweenLite._internals.reservedProps;
            for (target = tween._targets || tween.target, _getChildStyles(target, b, targets), 
            tween.render(duration, !0), _getChildStyles(target, e), tween.render(0, !0), tween._enabled(!0), 
            i = targets.length; --i > -1; ) if (difs = _cssDif(targets[i], b[i], e[i]), difs.firstMPT) {
                difs = difs.difs;
                for (p in vars) _reservedProps[p] && (difs[p] = vars[p]);
                results.push(TweenLite.to(targets[i], duration, difs));
            }
            return results;
        }, TweenPlugin.activate([ CSSPlugin ]), CSSPlugin;
    }, !0), function() {
        var RoundPropsPlugin = _gsScope._gsDefine.plugin({
            propName: "roundProps",
            priority: -1,
            API: 2,
            init: function(target, value, tween) {
                return this._tween = tween, !0;
            }
        }), p = RoundPropsPlugin.prototype;
        p._onInitAllProps = function() {
            for (var prop, pt, next, tween = this._tween, rp = tween.vars.roundProps instanceof Array ? tween.vars.roundProps : tween.vars.roundProps.split(","), i = rp.length, lookup = {}, rpt = tween._propLookup.roundProps; --i > -1; ) lookup[rp[i]] = 1;
            for (i = rp.length; --i > -1; ) for (prop = rp[i], pt = tween._firstPT; pt; ) next = pt._next, 
            pt.pg ? pt.t._roundProps(lookup, !0) : pt.n === prop && (this._add(pt.t, prop, pt.s, pt.c), 
            next && (next._prev = pt._prev), pt._prev ? pt._prev._next = next : tween._firstPT === pt && (tween._firstPT = next), 
            pt._next = pt._prev = null, tween._propLookup[prop] = rpt), pt = next;
            return !1;
        }, p._add = function(target, p, s, c) {
            this._addTween(target, p, s, s + c, p, !0), this._overwriteProps.push(p);
        };
    }(), _gsScope._gsDefine.plugin({
        propName: "attr",
        API: 2,
        version: "0.3.3",
        init: function(target, value) {
            var p, start, end;
            if ("function" != typeof target.setAttribute) return !1;
            this._target = target, this._proxy = {}, this._start = {}, this._end = {};
            for (p in value) this._start[p] = this._proxy[p] = start = target.getAttribute(p), 
            end = this._addTween(this._proxy, p, parseFloat(start), value[p], p), this._end[p] = end ? end.s + end.c : value[p], 
            this._overwriteProps.push(p);
            return !0;
        },
        set: function(ratio) {
            this._super.setRatio.call(this, ratio);
            for (var p, props = this._overwriteProps, i = props.length, lookup = 1 === ratio ? this._end : ratio ? this._proxy : this._start; --i > -1; ) p = props[i], 
            this._target.setAttribute(p, lookup[p] + "");
        }
    }), _gsScope._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.2.1",
        API: 2,
        init: function(target, value) {
            "object" != typeof value && (value = {
                rotation: value
            }), this.finals = {};
            var p, v, start, end, dif, split, cap = value.useRadians === !0 ? 2 * Math.PI : 360, min = 1e-6;
            for (p in value) "useRadians" !== p && (split = (value[p] + "").split("_"), v = split[0], 
            start = parseFloat("function" != typeof target[p] ? target[p] : target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)]()), 
            end = this.finals[p] = "string" == typeof v && "=" === v.charAt(1) ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0, 
            dif = end - start, split.length && (v = split.join("_"), -1 !== v.indexOf("short") && (dif %= cap, 
            dif !== dif % (cap / 2) && (dif = 0 > dif ? dif + cap : dif - cap)), -1 !== v.indexOf("_cw") && 0 > dif ? dif = (dif + 9999999999 * cap) % cap - (dif / cap | 0) * cap : -1 !== v.indexOf("ccw") && dif > 0 && (dif = (dif - 9999999999 * cap) % cap - (dif / cap | 0) * cap)), 
            (dif > min || -min > dif) && (this._addTween(target, p, start, start + dif, p), 
            this._overwriteProps.push(p)));
            return !0;
        },
        set: function(ratio) {
            var pt;
            if (1 !== ratio) this._super.setRatio.call(this, ratio); else for (pt = this._firstPT; pt; ) pt.f ? pt.t[pt.p](this.finals[pt.p]) : pt.t[pt.p] = this.finals[pt.p], 
            pt = pt._next;
        }
    })._autoCSS = !0, _gsScope._gsDefine("easing.Back", [ "easing.Ease" ], function(Ease) {
        var SteppedEase, RoughEase, _createElastic, w = _gsScope.GreenSockGlobals || _gsScope, gs = w.com.greensock, _2PI = 2 * Math.PI, _HALF_PI = Math.PI / 2, _class = gs._class, _create = function(n, f) {
            var C = _class("easing." + n, function() {}, !0), p = C.prototype = new Ease();
            return p.constructor = C, p.getRatio = f, C;
        }, _easeReg = Ease.register || function() {}, _wrap = function(name, EaseOut, EaseIn, EaseInOut) {
            var C = _class("easing." + name, {
                easeOut: new EaseOut(),
                easeIn: new EaseIn(),
                easeInOut: new EaseInOut()
            }, !0);
            return _easeReg(C, name), C;
        }, EasePoint = function(time, value, next) {
            this.t = time, this.v = value, next && (this.next = next, next.prev = this, this.c = next.v - value, 
            this.gap = next.t - time);
        }, _createBack = function(n, f) {
            var C = _class("easing." + n, function(overshoot) {
                this._p1 = overshoot || 0 === overshoot ? overshoot : 1.70158, this._p2 = 1.525 * this._p1;
            }, !0), p = C.prototype = new Ease();
            return p.constructor = C, p.getRatio = f, p.config = function(overshoot) {
                return new C(overshoot);
            }, C;
        }, Back = _wrap("Back", _createBack("BackOut", function(p) {
            return (p -= 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
        }), _createBack("BackIn", function(p) {
            return p * p * ((this._p1 + 1) * p - this._p1);
        }), _createBack("BackInOut", function(p) {
            return (p *= 2) < 1 ? .5 * p * p * ((this._p2 + 1) * p - this._p2) : .5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
        })), SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
            power = power || 0 === power ? power : .7, null == linearRatio ? linearRatio = .7 : linearRatio > 1 && (linearRatio = 1), 
            this._p = 1 !== linearRatio ? power : 0, this._p1 = (1 - linearRatio) / 2, this._p2 = linearRatio, 
            this._p3 = this._p1 + this._p2, this._calcEnd = yoyoMode === !0;
        }, !0), p = SlowMo.prototype = new Ease();
        return p.constructor = SlowMo, p.getRatio = function(p) {
            var r = p + (.5 - p) * this._p;
            return p < this._p1 ? this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r : p > this._p3 ? this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p : this._calcEnd ? 1 : r;
        }, SlowMo.ease = new SlowMo(.7, .7), p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
            return new SlowMo(linearRatio, power, yoyoMode);
        }, SteppedEase = _class("easing.SteppedEase", function(steps) {
            steps = steps || 1, this._p1 = 1 / steps, this._p2 = steps + 1;
        }, !0), p = SteppedEase.prototype = new Ease(), p.constructor = SteppedEase, p.getRatio = function(p) {
            return 0 > p ? p = 0 : p >= 1 && (p = .999999999), (this._p2 * p >> 0) * this._p1;
        }, p.config = SteppedEase.config = function(steps) {
            return new SteppedEase(steps);
        }, RoughEase = _class("easing.RoughEase", function(vars) {
            vars = vars || {};
            for (var x, y, bump, invX, obj, pnt, taper = vars.taper || "none", a = [], cnt = 0, points = 0 | (vars.points || 20), i = points, randomize = vars.randomize !== !1, clamp = vars.clamp === !0, template = vars.template instanceof Ease ? vars.template : null, strength = "number" == typeof vars.strength ? .4 * vars.strength : .4; --i > -1; ) x = randomize ? Math.random() : 1 / points * i, 
            y = template ? template.getRatio(x) : x, "none" === taper ? bump = strength : "out" === taper ? (invX = 1 - x, 
            bump = invX * invX * strength) : "in" === taper ? bump = x * x * strength : .5 > x ? (invX = 2 * x, 
            bump = invX * invX * .5 * strength) : (invX = 2 * (1 - x), bump = invX * invX * .5 * strength), 
            randomize ? y += Math.random() * bump - .5 * bump : i % 2 ? y += .5 * bump : y -= .5 * bump, 
            clamp && (y > 1 ? y = 1 : 0 > y && (y = 0)), a[cnt++] = {
                x: x,
                y: y
            };
            for (a.sort(function(a, b) {
                return a.x - b.x;
            }), pnt = new EasePoint(1, 1, null), i = points; --i > -1; ) obj = a[i], pnt = new EasePoint(obj.x, obj.y, pnt);
            this._prev = new EasePoint(0, 0, 0 !== pnt.t ? pnt : pnt.next);
        }, !0), p = RoughEase.prototype = new Ease(), p.constructor = RoughEase, p.getRatio = function(p) {
            var pnt = this._prev;
            if (p > pnt.t) {
                for (;pnt.next && p >= pnt.t; ) pnt = pnt.next;
                pnt = pnt.prev;
            } else for (;pnt.prev && p <= pnt.t; ) pnt = pnt.prev;
            return this._prev = pnt, pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
        }, p.config = function(vars) {
            return new RoughEase(vars);
        }, RoughEase.ease = new RoughEase(), _wrap("Bounce", _create("BounceOut", function(p) {
            return 1 / 2.75 > p ? 7.5625 * p * p : 2 / 2.75 > p ? 7.5625 * (p -= 1.5 / 2.75) * p + .75 : 2.5 / 2.75 > p ? 7.5625 * (p -= 2.25 / 2.75) * p + .9375 : 7.5625 * (p -= 2.625 / 2.75) * p + .984375;
        }), _create("BounceIn", function(p) {
            return (p = 1 - p) < 1 / 2.75 ? 1 - 7.5625 * p * p : 2 / 2.75 > p ? 1 - (7.5625 * (p -= 1.5 / 2.75) * p + .75) : 2.5 / 2.75 > p ? 1 - (7.5625 * (p -= 2.25 / 2.75) * p + .9375) : 1 - (7.5625 * (p -= 2.625 / 2.75) * p + .984375);
        }), _create("BounceInOut", function(p) {
            var invert = .5 > p;
            return p = invert ? 1 - 2 * p : 2 * p - 1, p = 1 / 2.75 > p ? 7.5625 * p * p : 2 / 2.75 > p ? 7.5625 * (p -= 1.5 / 2.75) * p + .75 : 2.5 / 2.75 > p ? 7.5625 * (p -= 2.25 / 2.75) * p + .9375 : 7.5625 * (p -= 2.625 / 2.75) * p + .984375, 
            invert ? .5 * (1 - p) : .5 * p + .5;
        })), _wrap("Circ", _create("CircOut", function(p) {
            return Math.sqrt(1 - (p -= 1) * p);
        }), _create("CircIn", function(p) {
            return -(Math.sqrt(1 - p * p) - 1);
        }), _create("CircInOut", function(p) {
            return (p *= 2) < 1 ? -.5 * (Math.sqrt(1 - p * p) - 1) : .5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
        })), _createElastic = function(n, f, def) {
            var C = _class("easing." + n, function(amplitude, period) {
                this._p1 = amplitude || 1, this._p2 = period || def, this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
            }, !0), p = C.prototype = new Ease();
            return p.constructor = C, p.getRatio = f, p.config = function(amplitude, period) {
                return new C(amplitude, period);
            }, C;
        }, _wrap("Elastic", _createElastic("ElasticOut", function(p) {
            return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * _2PI / this._p2) + 1;
        }, .3), _createElastic("ElasticIn", function(p) {
            return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2));
        }, .3), _createElastic("ElasticInOut", function(p) {
            return (p *= 2) < 1 ? -.5 * this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2) * .5 + 1;
        }, .45)), _wrap("Expo", _create("ExpoOut", function(p) {
            return 1 - Math.pow(2, -10 * p);
        }), _create("ExpoIn", function(p) {
            return Math.pow(2, 10 * (p - 1)) - .001;
        }), _create("ExpoInOut", function(p) {
            return (p *= 2) < 1 ? .5 * Math.pow(2, 10 * (p - 1)) : .5 * (2 - Math.pow(2, -10 * (p - 1)));
        })), _wrap("Sine", _create("SineOut", function(p) {
            return Math.sin(p * _HALF_PI);
        }), _create("SineIn", function(p) {
            return -Math.cos(p * _HALF_PI) + 1;
        }), _create("SineInOut", function(p) {
            return -.5 * (Math.cos(Math.PI * p) - 1);
        })), _class("easing.EaseLookup", {
            find: function(s) {
                return Ease.map[s];
            }
        }, !0), _easeReg(w.SlowMo, "SlowMo", "ease,"), _easeReg(RoughEase, "RoughEase", "ease,"), 
        _easeReg(SteppedEase, "SteppedEase", "ease,"), Back;
    }, !0);
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function(window, moduleName) {
    "use strict";
    var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
    if (!_globals.TweenLite) {
        var a, i, p, _ticker, _tickerActive, _namespace = function(ns) {
            var i, a = ns.split("."), p = _globals;
            for (i = 0; i < a.length; i++) p[a[i]] = p = p[a[i]] || {};
            return p;
        }, gs = _namespace("com.greensock"), _tinyNum = 1e-10, _slice = function(a) {
            var i, b = [], l = a.length;
            for (i = 0; i !== l; b.push(a[i++])) ;
            return b;
        }, _emptyFunc = function() {}, _isArray = function() {
            var toString = Object.prototype.toString, array = toString.call([]);
            return function(obj) {
                return null != obj && (obj instanceof Array || "object" == typeof obj && !!obj.push && toString.call(obj) === array);
            };
        }(), _defLookup = {}, Definition = function(ns, dependencies, func, global) {
            this.sc = _defLookup[ns] ? _defLookup[ns].sc : [], _defLookup[ns] = this, this.gsClass = null, 
            this.func = func;
            var _classes = [];
            this.check = function(init) {
                for (var cur, a, n, cl, i = dependencies.length, missing = i; --i > -1; ) (cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass ? (_classes[i] = cur.gsClass, 
                missing--) : init && cur.sc.push(this);
                if (0 === missing && func) for (a = ("com.greensock." + ns).split("."), n = a.pop(), 
                cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes), global && (_globals[n] = cl, 
                "function" == typeof define && define.amd ? define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() {
                    return cl;
                }) : ns === moduleName && "undefined" != typeof module && module.exports && (module.exports = cl)), 
                i = 0; i < this.sc.length; i++) this.sc[i].check();
            }, this.check(!0);
        }, _gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
            return new Definition(ns, dependencies, func, global);
        }, _class = gs._class = function(ns, func, global) {
            return func = func || function() {}, _gsDefine(ns, [], function() {
                return func;
            }, global), func;
        };
        _gsDefine.globals = _globals;
        var _baseParams = [ 0, 0, 1, 1 ], _blankArray = [], Ease = _class("easing.Ease", function(func, extraParams, type, power) {
            this._func = func, this._type = type || 0, this._power = power || 0, this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
        }, !0), _easeMap = Ease.map = {}, _easeReg = Ease.register = function(ease, names, types, create) {
            for (var e, name, j, type, na = names.split(","), i = na.length, ta = (types || "easeIn,easeOut,easeInOut").split(","); --i > -1; ) for (name = na[i], 
            e = create ? _class("easing." + name, null, !0) : gs.easing[name] || {}, j = ta.length; --j > -1; ) type = ta[j], 
            _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
        };
        for (p = Ease.prototype, p._calcEnd = !1, p.getRatio = function(p) {
            if (this._func) return this._params[0] = p, this._func.apply(null, this._params);
            var t = this._type, pw = this._power, r = 1 === t ? 1 - p : 2 === t ? p : .5 > p ? 2 * p : 2 * (1 - p);
            return 1 === pw ? r *= r : 2 === pw ? r *= r * r : 3 === pw ? r *= r * r * r : 4 === pw && (r *= r * r * r * r), 
            1 === t ? 1 - r : 2 === t ? r : .5 > p ? r / 2 : 1 - r / 2;
        }, a = [ "Linear", "Quad", "Cubic", "Quart", "Quint,Strong" ], i = a.length; --i > -1; ) p = a[i] + ",Power" + i, 
        _easeReg(new Ease(null, null, 1, i), p, "easeOut", !0), _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (0 === i ? ",easeNone" : "")), 
        _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
        _easeMap.linear = gs.easing.Linear.easeIn, _easeMap.swing = gs.easing.Quad.easeInOut;
        var EventDispatcher = _class("events.EventDispatcher", function(target) {
            this._listeners = {}, this._eventTarget = target || this;
        });
        p = EventDispatcher.prototype, p.addEventListener = function(type, callback, scope, useParam, priority) {
            priority = priority || 0;
            var listener, i, list = this._listeners[type], index = 0;
            for (null == list && (this._listeners[type] = list = []), i = list.length; --i > -1; ) listener = list[i], 
            listener.c === callback && listener.s === scope ? list.splice(i, 1) : 0 === index && listener.pr < priority && (index = i + 1);
            list.splice(index, 0, {
                c: callback,
                s: scope,
                up: useParam,
                pr: priority
            }), this !== _ticker || _tickerActive || _ticker.wake();
        }, p.removeEventListener = function(type, callback) {
            var i, list = this._listeners[type];
            if (list) for (i = list.length; --i > -1; ) if (list[i].c === callback) return void list.splice(i, 1);
        }, p.dispatchEvent = function(type) {
            var i, t, listener, list = this._listeners[type];
            if (list) for (i = list.length, t = this._eventTarget; --i > -1; ) listener = list[i], 
            listener.up ? listener.c.call(listener.s || t, {
                type: type,
                target: t
            }) : listener.c.call(listener.s || t);
        };
        var _reqAnimFrame = window.requestAnimationFrame, _cancelAnimFrame = window.cancelAnimationFrame, _getTime = Date.now || function() {
            return new Date().getTime();
        }, _lastUpdate = _getTime();
        for (a = [ "ms", "moz", "webkit", "o" ], i = a.length; --i > -1 && !_reqAnimFrame; ) _reqAnimFrame = window[a[i] + "RequestAnimationFrame"], 
        _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
        _class("Ticker", function(fps, useRAF) {
            var _fps, _req, _id, _gap, _nextTime, _self = this, _startTime = _getTime(), _useRAF = useRAF !== !1 && _reqAnimFrame, _lagThreshold = 500, _adjustedLag = 33, _tick = function(manual) {
                var overlap, dispatch, elapsed = _getTime() - _lastUpdate;
                elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag), _lastUpdate += elapsed, 
                _self.time = (_lastUpdate - _startTime) / 1e3, overlap = _self.time - _nextTime, 
                (!_fps || overlap > 0 || manual === !0) && (_self.frame++, _nextTime += overlap + (overlap >= _gap ? .004 : _gap - overlap), 
                dispatch = !0), manual !== !0 && (_id = _req(_tick)), dispatch && _self.dispatchEvent("tick");
            };
            EventDispatcher.call(_self), _self.time = _self.frame = 0, _self.tick = function() {
                _tick(!0);
            }, _self.lagSmoothing = function(threshold, adjustedLag) {
                _lagThreshold = threshold || 1 / _tinyNum, _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
            }, _self.sleep = function() {
                null != _id && (_useRAF && _cancelAnimFrame ? _cancelAnimFrame(_id) : clearTimeout(_id), 
                _req = _emptyFunc, _id = null, _self === _ticker && (_tickerActive = !1));
            }, _self.wake = function() {
                null !== _id ? _self.sleep() : _self.frame > 10 && (_lastUpdate = _getTime() - _lagThreshold + 5), 
                _req = 0 === _fps ? _emptyFunc : _useRAF && _reqAnimFrame ? _reqAnimFrame : function(f) {
                    return setTimeout(f, 1e3 * (_nextTime - _self.time) + 1 | 0);
                }, _self === _ticker && (_tickerActive = !0), _tick(2);
            }, _self.fps = function(value) {
                return arguments.length ? (_fps = value, _gap = 1 / (_fps || 60), _nextTime = this.time + _gap, 
                void _self.wake()) : _fps;
            }, _self.useRAF = function(value) {
                return arguments.length ? (_self.sleep(), _useRAF = value, void _self.fps(_fps)) : _useRAF;
            }, _self.fps(fps), setTimeout(function() {
                _useRAF && (!_id || _self.frame < 5) && _self.useRAF(!1);
            }, 1500);
        }), p = gs.Ticker.prototype = new gs.events.EventDispatcher(), p.constructor = gs.Ticker;
        var Animation = _class("core.Animation", function(duration, vars) {
            if (this.vars = vars = vars || {}, this._duration = this._totalDuration = duration || 0, 
            this._delay = Number(vars.delay) || 0, this._timeScale = 1, this._active = vars.immediateRender === !0, 
            this.data = vars.data, this._reversed = vars.reversed === !0, _rootTimeline) {
                _tickerActive || _ticker.wake();
                var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
                tl.add(this, tl._time), this.vars.paused && this.paused(!0);
            }
        });
        _ticker = Animation.ticker = new gs.Ticker(), p = Animation.prototype, p._dirty = p._gc = p._initted = p._paused = !1, 
        p._totalTime = p._time = 0, p._rawPrevTime = -1, p._next = p._last = p._onUpdate = p._timeline = p.timeline = null, 
        p._paused = !1;
        var _checkTimeout = function() {
            _tickerActive && _getTime() - _lastUpdate > 2e3 && _ticker.wake(), setTimeout(_checkTimeout, 2e3);
        };
        _checkTimeout(), p.play = function(from, suppressEvents) {
            return null != from && this.seek(from, suppressEvents), this.reversed(!1).paused(!1);
        }, p.pause = function(atTime, suppressEvents) {
            return null != atTime && this.seek(atTime, suppressEvents), this.paused(!0);
        }, p.resume = function(from, suppressEvents) {
            return null != from && this.seek(from, suppressEvents), this.paused(!1);
        }, p.seek = function(time, suppressEvents) {
            return this.totalTime(Number(time), suppressEvents !== !1);
        }, p.restart = function(includeDelay, suppressEvents) {
            return this.reversed(!1).paused(!1).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== !1, !0);
        }, p.reverse = function(from, suppressEvents) {
            return null != from && this.seek(from || this.totalDuration(), suppressEvents), 
            this.reversed(!0).paused(!1);
        }, p.render = function() {}, p.invalidate = function() {
            return this;
        }, p.isActive = function() {
            var rawTime, tl = this._timeline, startTime = this._startTime;
            return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale;
        }, p._enabled = function(enabled, ignoreTimeline) {
            return _tickerActive || _ticker.wake(), this._gc = !enabled, this._active = this.isActive(), 
            ignoreTimeline !== !0 && (enabled && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !enabled && this.timeline && this._timeline._remove(this, !0)), 
            !1;
        }, p._kill = function() {
            return this._enabled(!1, !1);
        }, p.kill = function(vars, target) {
            return this._kill(vars, target), this;
        }, p._uncache = function(includeSelf) {
            for (var tween = includeSelf ? this : this.timeline; tween; ) tween._dirty = !0, 
            tween = tween.timeline;
            return this;
        }, p._swapSelfInParams = function(params) {
            for (var i = params.length, copy = params.concat(); --i > -1; ) "{self}" === params[i] && (copy[i] = this);
            return copy;
        }, p.eventCallback = function(type, callback, params, scope) {
            if ("on" === (type || "").substr(0, 2)) {
                var v = this.vars;
                if (1 === arguments.length) return v[type];
                null == callback ? delete v[type] : (v[type] = callback, v[type + "Params"] = _isArray(params) && -1 !== params.join("").indexOf("{self}") ? this._swapSelfInParams(params) : params, 
                v[type + "Scope"] = scope), "onUpdate" === type && (this._onUpdate = callback);
            }
            return this;
        }, p.delay = function(value) {
            return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + value - this._delay), 
            this._delay = value, this) : this._delay;
        }, p.duration = function(value) {
            return arguments.length ? (this._duration = this._totalDuration = value, this._uncache(!0), 
            this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== value && this.totalTime(this._totalTime * (value / this._duration), !0), 
            this) : (this._dirty = !1, this._duration);
        }, p.totalDuration = function(value) {
            return this._dirty = !1, arguments.length ? this.duration(value) : this._totalDuration;
        }, p.time = function(value, suppressEvents) {
            return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(value > this._duration ? this._duration : value, suppressEvents)) : this._time;
        }, p.totalTime = function(time, suppressEvents, uncapped) {
            if (_tickerActive || _ticker.wake(), !arguments.length) return this._totalTime;
            if (this._timeline) {
                if (0 > time && !uncapped && (time += this.totalDuration()), this._timeline.smoothChildTiming) {
                    this._dirty && this.totalDuration();
                    var totalDuration = this._totalDuration, tl = this._timeline;
                    if (time > totalDuration && !uncapped && (time = totalDuration), this._startTime = (this._paused ? this._pauseTime : tl._time) - (this._reversed ? totalDuration - time : time) / this._timeScale, 
                    tl._dirty || this._uncache(!1), tl._timeline) for (;tl._timeline; ) tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale && tl.totalTime(tl._totalTime, !0), 
                    tl = tl._timeline;
                }
                this._gc && this._enabled(!0, !1), (this._totalTime !== time || 0 === this._duration) && (this.render(time, suppressEvents, !1), 
                _lazyTweens.length && _lazyRender());
            }
            return this;
        }, p.progress = p.totalProgress = function(value, suppressEvents) {
            return arguments.length ? this.totalTime(this.duration() * value, suppressEvents) : this._time / this.duration();
        }, p.startTime = function(value) {
            return arguments.length ? (value !== this._startTime && (this._startTime = value, 
            this.timeline && this.timeline._sortChildren && this.timeline.add(this, value - this._delay)), 
            this) : this._startTime;
        }, p.timeScale = function(value) {
            if (!arguments.length) return this._timeScale;
            if (value = value || _tinyNum, this._timeline && this._timeline.smoothChildTiming) {
                var pauseTime = this._pauseTime, t = pauseTime || 0 === pauseTime ? pauseTime : this._timeline.totalTime();
                this._startTime = t - (t - this._startTime) * this._timeScale / value;
            }
            return this._timeScale = value, this._uncache(!1);
        }, p.reversed = function(value) {
            return arguments.length ? (value != this._reversed && (this._reversed = value, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), 
            this) : this._reversed;
        }, p.paused = function(value) {
            if (!arguments.length) return this._paused;
            if (value != this._paused && this._timeline) {
                _tickerActive || value || _ticker.wake();
                var tl = this._timeline, raw = tl.rawTime(), elapsed = raw - this._pauseTime;
                !value && tl.smoothChildTiming && (this._startTime += elapsed, this._uncache(!1)), 
                this._pauseTime = value ? raw : null, this._paused = value, this._active = this.isActive(), 
                !value && 0 !== elapsed && this._initted && this.duration() && this.render(tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale, !0, !0);
            }
            return this._gc && !value && this._enabled(!0, !1), this;
        };
        var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
            Animation.call(this, 0, vars), this.autoRemoveChildren = this.smoothChildTiming = !0;
        });
        p = SimpleTimeline.prototype = new Animation(), p.constructor = SimpleTimeline, 
        p.kill()._gc = !1, p._first = p._last = null, p._sortChildren = !1, p.add = p.insert = function(child, position) {
            var prevTween, st;
            if (child._startTime = Number(position || 0) + child._delay, child._paused && this !== child._timeline && (child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale), 
            child.timeline && child.timeline._remove(child, !0), child.timeline = child._timeline = this, 
            child._gc && child._enabled(!0, !0), prevTween = this._last, this._sortChildren) for (st = child._startTime; prevTween && prevTween._startTime > st; ) prevTween = prevTween._prev;
            return prevTween ? (child._next = prevTween._next, prevTween._next = child) : (child._next = this._first, 
            this._first = child), child._next ? child._next._prev = child : this._last = child, 
            child._prev = prevTween, this._timeline && this._uncache(!0), this;
        }, p._remove = function(tween, skipDisable) {
            return tween.timeline === this && (skipDisable || tween._enabled(!1, !0), tween._prev ? tween._prev._next = tween._next : this._first === tween && (this._first = tween._next), 
            tween._next ? tween._next._prev = tween._prev : this._last === tween && (this._last = tween._prev), 
            tween._next = tween._prev = tween.timeline = null, this._timeline && this._uncache(!0)), 
            this;
        }, p.render = function(time, suppressEvents, force) {
            var next, tween = this._first;
            for (this._totalTime = this._time = this._rawPrevTime = time; tween; ) next = tween._next, 
            (tween._active || time >= tween._startTime && !tween._paused) && (tween._reversed ? tween.render((tween._dirty ? tween.totalDuration() : tween._totalDuration) - (time - tween._startTime) * tween._timeScale, suppressEvents, force) : tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)), 
            tween = next;
        }, p.rawTime = function() {
            return _tickerActive || _ticker.wake(), this._totalTime;
        };
        var TweenLite = _class("TweenLite", function(target, duration, vars) {
            if (Animation.call(this, duration, vars), this.render = TweenLite.prototype.render, 
            null == target) throw "Cannot tween a null target.";
            this.target = target = "string" != typeof target ? target : TweenLite.selector(target) || target;
            var i, targ, targets, isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType), overwrite = this.vars.overwrite;
            if (this._overwrite = overwrite = null == overwrite ? _overwriteLookup[TweenLite.defaultOverwrite] : "number" == typeof overwrite ? overwrite >> 0 : _overwriteLookup[overwrite], 
            (isSelector || target instanceof Array || target.push && _isArray(target)) && "number" != typeof target[0]) for (this._targets = targets = _slice(target), 
            this._propLookup = [], this._siblings = [], i = 0; i < targets.length; i++) targ = targets[i], 
            targ ? "string" != typeof targ ? targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType) ? (targets.splice(i--, 1), 
            this._targets = targets = targets.concat(_slice(targ))) : (this._siblings[i] = _register(targ, this, !1), 
            1 === overwrite && this._siblings[i].length > 1 && _applyOverwrite(targ, this, null, 1, this._siblings[i])) : (targ = targets[i--] = TweenLite.selector(targ), 
            "string" == typeof targ && targets.splice(i + 1, 1)) : targets.splice(i--, 1); else this._propLookup = {}, 
            this._siblings = _register(target, this, !1), 1 === overwrite && this._siblings.length > 1 && _applyOverwrite(target, this, null, 1, this._siblings);
            (this.vars.immediateRender || 0 === duration && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -_tinyNum, 
            this.render(-this._delay));
        }, !0), _isSelector = function(v) {
            return v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType);
        }, _autoCSS = function(vars, target) {
            var p, css = {};
            for (p in vars) _reservedProps[p] || p in target && "transform" !== p && "x" !== p && "y" !== p && "width" !== p && "height" !== p && "className" !== p && "border" !== p || !(!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS) || (css[p] = vars[p], 
            delete vars[p]);
            vars.css = css;
        };
        p = TweenLite.prototype = new Animation(), p.constructor = TweenLite, p.kill()._gc = !1, 
        p.ratio = 0, p._firstPT = p._targets = p._overwrittenProps = p._startAt = null, 
        p._notifyPluginsOfEnabled = p._lazy = !1, TweenLite.version = "1.13.1", TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1), 
        TweenLite.defaultOverwrite = "auto", TweenLite.ticker = _ticker, TweenLite.autoSleep = !0, 
        TweenLite.lagSmoothing = function(threshold, adjustedLag) {
            _ticker.lagSmoothing(threshold, adjustedLag);
        }, TweenLite.selector = window.$ || window.jQuery || function(e) {
            var selector = window.$ || window.jQuery;
            return selector ? (TweenLite.selector = selector, selector(e)) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e);
        };
        var _lazyTweens = [], _lazyLookup = {}, _internals = TweenLite._internals = {
            isArray: _isArray,
            isSelector: _isSelector,
            lazyTweens: _lazyTweens
        }, _plugins = TweenLite._plugins = {}, _tweenLookup = _internals.tweenLookup = {}, _tweenLookupNum = 0, _reservedProps = _internals.reservedProps = {
            ease: 1,
            delay: 1,
            overwrite: 1,
            onComplete: 1,
            onCompleteParams: 1,
            onCompleteScope: 1,
            useFrames: 1,
            runBackwards: 1,
            startAt: 1,
            onUpdate: 1,
            onUpdateParams: 1,
            onUpdateScope: 1,
            onStart: 1,
            onStartParams: 1,
            onStartScope: 1,
            onReverseComplete: 1,
            onReverseCompleteParams: 1,
            onReverseCompleteScope: 1,
            onRepeat: 1,
            onRepeatParams: 1,
            onRepeatScope: 1,
            easeParams: 1,
            yoyo: 1,
            immediateRender: 1,
            repeat: 1,
            repeatDelay: 1,
            data: 1,
            paused: 1,
            reversed: 1,
            autoCSS: 1,
            lazy: 1
        }, _overwriteLookup = {
            none: 0,
            all: 1,
            auto: 2,
            concurrent: 3,
            allOnStart: 4,
            preexisting: 5,
            "true": 1,
            "false": 0
        }, _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(), _rootTimeline = Animation._rootTimeline = new SimpleTimeline(), _lazyRender = _internals.lazyRender = function() {
            var i = _lazyTweens.length;
            for (_lazyLookup = {}; --i > -1; ) a = _lazyTweens[i], a && a._lazy !== !1 && (a.render(a._lazy, !1, !0), 
            a._lazy = !1);
            _lazyTweens.length = 0;
        };
        _rootTimeline._startTime = _ticker.time, _rootFramesTimeline._startTime = _ticker.frame, 
        _rootTimeline._active = _rootFramesTimeline._active = !0, setTimeout(_lazyRender, 1), 
        Animation._updateRoot = TweenLite.render = function() {
            var i, a, p;
            if (_lazyTweens.length && _lazyRender(), _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, !1, !1), 
            _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, !1, !1), 
            _lazyTweens.length && _lazyRender(), !(_ticker.frame % 120)) {
                for (p in _tweenLookup) {
                    for (a = _tweenLookup[p].tweens, i = a.length; --i > -1; ) a[i]._gc && a.splice(i, 1);
                    0 === a.length && delete _tweenLookup[p];
                }
                if (p = _rootTimeline._first, (!p || p._paused) && TweenLite.autoSleep && !_rootFramesTimeline._first && 1 === _ticker._listeners.tick.length) {
                    for (;p && p._paused; ) p = p._next;
                    p || _ticker.sleep();
                }
            }
        }, _ticker.addEventListener("tick", Animation._updateRoot);
        var _register = function(target, tween, scrub) {
            var a, i, id = target._gsTweenID;
            if (_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)] || (_tweenLookup[id] = {
                target: target,
                tweens: []
            }), tween && (a = _tweenLookup[id].tweens, a[i = a.length] = tween, scrub)) for (;--i > -1; ) a[i] === tween && a.splice(i, 1);
            return _tweenLookup[id].tweens;
        }, _applyOverwrite = function(target, tween, props, mode, siblings) {
            var i, changed, curTween, l;
            if (1 === mode || mode >= 4) {
                for (l = siblings.length, i = 0; l > i; i++) if ((curTween = siblings[i]) !== tween) curTween._gc || curTween._enabled(!1, !1) && (changed = !0); else if (5 === mode) break;
                return changed;
            }
            var globalStart, startTime = tween._startTime + _tinyNum, overlaps = [], oCount = 0, zeroDur = 0 === tween._duration;
            for (i = siblings.length; --i > -1; ) (curTween = siblings[i]) === tween || curTween._gc || curTween._paused || (curTween._timeline !== tween._timeline ? (globalStart = globalStart || _checkOverlap(tween, 0, zeroDur), 
            0 === _checkOverlap(curTween, globalStart, zeroDur) && (overlaps[oCount++] = curTween)) : curTween._startTime <= startTime && curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime && ((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 2e-10 || (overlaps[oCount++] = curTween)));
            for (i = oCount; --i > -1; ) curTween = overlaps[i], 2 === mode && curTween._kill(props, target) && (changed = !0), 
            (2 !== mode || !curTween._firstPT && curTween._initted) && curTween._enabled(!1, !1) && (changed = !0);
            return changed;
        }, _checkOverlap = function(tween, reference, zeroDur) {
            for (var tl = tween._timeline, ts = tl._timeScale, t = tween._startTime; tl._timeline; ) {
                if (t += tl._startTime, ts *= tl._timeScale, tl._paused) return -100;
                tl = tl._timeline;
            }
            return t /= ts, t > reference ? t - reference : zeroDur && t === reference || !tween._initted && 2 * _tinyNum > t - reference ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
        };
        p._init = function() {
            var i, initPlugins, pt, p, startVars, v = this.vars, op = this._overwrittenProps, dur = this._duration, immediate = !!v.immediateRender, ease = v.ease;
            if (v.startAt) {
                this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), startVars = {};
                for (p in v.startAt) startVars[p] = v.startAt[p];
                if (startVars.overwrite = !1, startVars.immediateRender = !0, startVars.lazy = immediate && v.lazy !== !1, 
                startVars.startAt = startVars.delay = null, this._startAt = TweenLite.to(this.target, 0, startVars), 
                immediate) if (this._time > 0) this._startAt = null; else if (0 !== dur) return;
            } else if (v.runBackwards && 0 !== dur) if (this._startAt) this._startAt.render(-1, !0), 
            this._startAt.kill(), this._startAt = null; else {
                pt = {};
                for (p in v) _reservedProps[p] && "autoCSS" !== p || (pt[p] = v[p]);
                if (pt.overwrite = 0, pt.data = "isFromStart", pt.lazy = immediate && v.lazy !== !1, 
                pt.immediateRender = immediate, this._startAt = TweenLite.to(this.target, 0, pt), 
                immediate) {
                    if (0 === this._time) return;
                } else this._startAt._init(), this._startAt._enabled(!1);
            }
            if (this._ease = ease = ease ? ease instanceof Ease ? ease : "function" == typeof ease ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase : TweenLite.defaultEase, 
            v.easeParams instanceof Array && ease.config && (this._ease = ease.config.apply(ease, v.easeParams)), 
            this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, 
            this._targets) for (i = this._targets.length; --i > -1; ) this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null) && (initPlugins = !0); else initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
            if (initPlugins && TweenLite._onPluginEvent("_onInitAllProps", this), op && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), 
            v.runBackwards) for (pt = this._firstPT; pt; ) pt.s += pt.c, pt.c = -pt.c, pt = pt._next;
            this._onUpdate = v.onUpdate, this._initted = !0;
        }, p._initProps = function(target, propLookup, siblings, overwrittenProps) {
            var p, i, initPlugins, plugin, pt, v;
            if (null == target) return !1;
            _lazyLookup[target._gsTweenID] && _lazyRender(), this.vars.css || target.style && target !== window && target.nodeType && _plugins.css && this.vars.autoCSS !== !1 && _autoCSS(this.vars, target);
            for (p in this.vars) {
                if (v = this.vars[p], _reservedProps[p]) v && (v instanceof Array || v.push && _isArray(v)) && -1 !== v.join("").indexOf("{self}") && (this.vars[p] = v = this._swapSelfInParams(v, this)); else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {
                    for (this._firstPT = pt = {
                        _next: this._firstPT,
                        t: plugin,
                        p: "setRatio",
                        s: 0,
                        c: 1,
                        f: !0,
                        n: p,
                        pg: !0,
                        pr: plugin._priority
                    }, i = plugin._overwriteProps.length; --i > -1; ) propLookup[plugin._overwriteProps[i]] = this._firstPT;
                    (plugin._priority || plugin._onInitAllProps) && (initPlugins = !0), (plugin._onDisable || plugin._onEnable) && (this._notifyPluginsOfEnabled = !0);
                } else this._firstPT = propLookup[p] = pt = {
                    _next: this._firstPT,
                    t: target,
                    p: p,
                    f: "function" == typeof target[p],
                    n: p,
                    pg: !1,
                    pr: 0
                }, pt.s = pt.f ? target[p.indexOf("set") || "function" != typeof target["get" + p.substr(3)] ? p : "get" + p.substr(3)]() : parseFloat(target[p]), 
                pt.c = "string" == typeof v && "=" === v.charAt(1) ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) - pt.s || 0;
                pt && pt._next && (pt._next._prev = pt);
            }
            return overwrittenProps && this._kill(overwrittenProps, target) ? this._initProps(target, propLookup, siblings, overwrittenProps) : this._overwrite > 1 && this._firstPT && siblings.length > 1 && _applyOverwrite(target, this, propLookup, this._overwrite, siblings) ? (this._kill(propLookup, target), 
            this._initProps(target, propLookup, siblings, overwrittenProps)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (_lazyLookup[target._gsTweenID] = !0), 
            initPlugins);
        }, p.render = function(time, suppressEvents, force) {
            var isComplete, callback, pt, rawPrevTime, prevTime = this._time, duration = this._duration, prevRawPrevTime = this._rawPrevTime;
            if (time >= duration) this._totalTime = this._time = duration, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, 
            this._reversed || (isComplete = !0, callback = "onComplete"), 0 === duration && (this._initted || !this.vars.lazy || force) && (this._startTime === this._timeline._duration && (time = 0), 
            (0 === time || 0 > prevRawPrevTime || prevRawPrevTime === _tinyNum) && prevRawPrevTime !== time && (force = !0, 
            prevRawPrevTime > _tinyNum && (callback = "onReverseComplete")), this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum); else if (1e-7 > time) this._totalTime = this._time = 0, 
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== prevTime || 0 === duration && prevRawPrevTime > 0 && prevRawPrevTime !== _tinyNum) && (callback = "onReverseComplete", 
            isComplete = this._reversed), 0 > time ? (this._active = !1, 0 === duration && (this._initted || !this.vars.lazy || force) && (prevRawPrevTime >= 0 && (force = !0), 
            this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum)) : this._initted || (force = !0); else if (this._totalTime = this._time = time, 
            this._easeType) {
                var r = time / duration, type = this._easeType, pow = this._easePower;
                (1 === type || 3 === type && r >= .5) && (r = 1 - r), 3 === type && (r *= 2), 1 === pow ? r *= r : 2 === pow ? r *= r * r : 3 === pow ? r *= r * r * r : 4 === pow && (r *= r * r * r * r), 
                this.ratio = 1 === type ? 1 - r : 2 === type ? r : .5 > time / duration ? r / 2 : 1 - r / 2;
            } else this.ratio = this._ease.getRatio(time / duration);
            if (this._time !== prevTime || force) {
                if (!this._initted) {
                    if (this._init(), !this._initted || this._gc) return;
                    if (!force && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = prevTime, 
                    this._rawPrevTime = prevRawPrevTime, _lazyTweens.push(this), void (this._lazy = time);
                    this._time && !isComplete ? this.ratio = this._ease.getRatio(this._time / duration) : isComplete && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
                }
                for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== prevTime && time >= 0 && (this._active = !0), 
                0 === prevTime && (this._startAt && (time >= 0 ? this._startAt.render(time, suppressEvents, force) : callback || (callback = "_dummyGS")), 
                this.vars.onStart && (0 !== this._time || 0 === duration) && (suppressEvents || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray))), 
                pt = this._firstPT; pt; ) pt.f ? pt.t[pt.p](pt.c * this.ratio + pt.s) : pt.t[pt.p] = pt.c * this.ratio + pt.s, 
                pt = pt._next;
                this._onUpdate && (0 > time && this._startAt && this._startTime && this._startAt.render(time, suppressEvents, force), 
                suppressEvents || (this._time !== prevTime || isComplete) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)), 
                callback && (!this._gc || force) && (0 > time && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(time, suppressEvents, force), 
                isComplete && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), 
                !suppressEvents && this.vars[callback] && this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray), 
                0 === duration && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum && (this._rawPrevTime = 0));
            }
        }, p._kill = function(vars, target) {
            if ("all" === vars && (vars = null), null == vars && (null == target || target === this.target)) return this._lazy = !1, 
            this._enabled(!1, !1);
            target = "string" != typeof target ? target || this._targets || this.target : TweenLite.selector(target) || target;
            var i, overwrittenProps, p, pt, propLookup, changed, killProps, record;
            if ((_isArray(target) || _isSelector(target)) && "number" != typeof target[0]) for (i = target.length; --i > -1; ) this._kill(vars, target[i]) && (changed = !0); else {
                if (this._targets) {
                    for (i = this._targets.length; --i > -1; ) if (target === this._targets[i]) {
                        propLookup = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], 
                        overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
                        break;
                    }
                } else {
                    if (target !== this.target) return !1;
                    propLookup = this._propLookup, overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
                }
                if (propLookup) {
                    killProps = vars || propLookup, record = vars !== overwrittenProps && "all" !== overwrittenProps && vars !== propLookup && ("object" != typeof vars || !vars._tempKill);
                    for (p in killProps) (pt = propLookup[p]) && (pt.pg && pt.t._kill(killProps) && (changed = !0), 
                    pt.pg && 0 !== pt.t._overwriteProps.length || (pt._prev ? pt._prev._next = pt._next : pt === this._firstPT && (this._firstPT = pt._next), 
                    pt._next && (pt._next._prev = pt._prev), pt._next = pt._prev = null), delete propLookup[p]), 
                    record && (overwrittenProps[p] = 1);
                    !this._firstPT && this._initted && this._enabled(!1, !1);
                }
            }
            return changed;
        }, p.invalidate = function() {
            return this._notifyPluginsOfEnabled && TweenLite._onPluginEvent("_onDisable", this), 
            this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, 
            this._initted = this._active = this._notifyPluginsOfEnabled = this._lazy = !1, this._propLookup = this._targets ? {} : [], 
            this;
        }, p._enabled = function(enabled, ignoreTimeline) {
            if (_tickerActive || _ticker.wake(), enabled && this._gc) {
                var i, targets = this._targets;
                if (targets) for (i = targets.length; --i > -1; ) this._siblings[i] = _register(targets[i], this, !0); else this._siblings = _register(this.target, this, !0);
            }
            return Animation.prototype._enabled.call(this, enabled, ignoreTimeline), this._notifyPluginsOfEnabled && this._firstPT ? TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this) : !1;
        }, TweenLite.to = function(target, duration, vars) {
            return new TweenLite(target, duration, vars);
        }, TweenLite.from = function(target, duration, vars) {
            return vars.runBackwards = !0, vars.immediateRender = 0 != vars.immediateRender, 
            new TweenLite(target, duration, vars);
        }, TweenLite.fromTo = function(target, duration, fromVars, toVars) {
            return toVars.startAt = fromVars, toVars.immediateRender = 0 != toVars.immediateRender && 0 != fromVars.immediateRender, 
            new TweenLite(target, duration, toVars);
        }, TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
            return new TweenLite(callback, 0, {
                delay: delay,
                onComplete: callback,
                onCompleteParams: params,
                onCompleteScope: scope,
                onReverseComplete: callback,
                onReverseCompleteParams: params,
                onReverseCompleteScope: scope,
                immediateRender: !1,
                useFrames: useFrames,
                overwrite: 0
            });
        }, TweenLite.set = function(target, vars) {
            return new TweenLite(target, 0, vars);
        }, TweenLite.getTweensOf = function(target, onlyActive) {
            if (null == target) return [];
            target = "string" != typeof target ? target : TweenLite.selector(target) || target;
            var i, a, j, t;
            if ((_isArray(target) || _isSelector(target)) && "number" != typeof target[0]) {
                for (i = target.length, a = []; --i > -1; ) a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
                for (i = a.length; --i > -1; ) for (t = a[i], j = i; --j > -1; ) t === a[j] && a.splice(i, 1);
            } else for (a = _register(target).concat(), i = a.length; --i > -1; ) (a[i]._gc || onlyActive && !a[i].isActive()) && a.splice(i, 1);
            return a;
        }, TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
            "object" == typeof onlyActive && (vars = onlyActive, onlyActive = !1);
            for (var a = TweenLite.getTweensOf(target, onlyActive), i = a.length; --i > -1; ) a[i]._kill(vars, target);
        };
        var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
            this._overwriteProps = (props || "").split(","), this._propName = this._overwriteProps[0], 
            this._priority = priority || 0, this._super = TweenPlugin.prototype;
        }, !0);
        if (p = TweenPlugin.prototype, TweenPlugin.version = "1.10.1", TweenPlugin.API = 2, 
        p._firstPT = null, p._addTween = function(target, prop, start, end, overwriteProp, round) {
            var c, pt;
            return null != end && (c = "number" == typeof end || "=" !== end.charAt(1) ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2))) ? (this._firstPT = pt = {
                _next: this._firstPT,
                t: target,
                p: prop,
                s: start,
                c: c,
                f: "function" == typeof target[prop],
                n: overwriteProp || prop,
                r: round
            }, pt._next && (pt._next._prev = pt), pt) : void 0;
        }, p.setRatio = function(v) {
            for (var val, pt = this._firstPT, min = 1e-6; pt; ) val = pt.c * v + pt.s, pt.r ? val = Math.round(val) : min > val && val > -min && (val = 0), 
            pt.f ? pt.t[pt.p](val) : pt.t[pt.p] = val, pt = pt._next;
        }, p._kill = function(lookup) {
            var i, a = this._overwriteProps, pt = this._firstPT;
            if (null != lookup[this._propName]) this._overwriteProps = []; else for (i = a.length; --i > -1; ) null != lookup[a[i]] && a.splice(i, 1);
            for (;pt; ) null != lookup[pt.n] && (pt._next && (pt._next._prev = pt._prev), pt._prev ? (pt._prev._next = pt._next, 
            pt._prev = null) : this._firstPT === pt && (this._firstPT = pt._next)), pt = pt._next;
            return !1;
        }, p._roundProps = function(lookup, value) {
            for (var pt = this._firstPT; pt; ) (lookup[this._propName] || null != pt.n && lookup[pt.n.split(this._propName + "_").join("")]) && (pt.r = value), 
            pt = pt._next;
        }, TweenLite._onPluginEvent = function(type, tween) {
            var changed, pt2, first, last, next, pt = tween._firstPT;
            if ("_onInitAllProps" === type) {
                for (;pt; ) {
                    for (next = pt._next, pt2 = first; pt2 && pt2.pr > pt.pr; ) pt2 = pt2._next;
                    (pt._prev = pt2 ? pt2._prev : last) ? pt._prev._next = pt : first = pt, (pt._next = pt2) ? pt2._prev = pt : last = pt, 
                    pt = next;
                }
                pt = tween._firstPT = first;
            }
            for (;pt; ) pt.pg && "function" == typeof pt.t[type] && pt.t[type]() && (changed = !0), 
            pt = pt._next;
            return changed;
        }, TweenPlugin.activate = function(plugins) {
            for (var i = plugins.length; --i > -1; ) plugins[i].API === TweenPlugin.API && (_plugins[new plugins[i]()._propName] = plugins[i]);
            return !0;
        }, _gsDefine.plugin = function(config) {
            if (!(config && config.propName && config.init && config.API)) throw "illegal plugin definition.";
            var prop, propName = config.propName, priority = config.priority || 0, overwriteProps = config.overwriteProps, map = {
                init: "_onInitTween",
                set: "setRatio",
                kill: "_kill",
                round: "_roundProps",
                initAll: "_onInitAllProps"
            }, Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function() {
                TweenPlugin.call(this, propName, priority), this._overwriteProps = overwriteProps || [];
            }, config.global === !0), p = Plugin.prototype = new TweenPlugin(propName);
            p.constructor = Plugin, Plugin.API = config.API;
            for (prop in map) "function" == typeof config[prop] && (p[map[prop]] = config[prop]);
            return Plugin.version = config.version, TweenPlugin.activate([ Plugin ]), Plugin;
        }, a = window._gsQueue) {
            for (i = 0; i < a.length; i++) a[i]();
            for (p in _defLookup) _defLookup[p].func || window.console.log("GSAP encountered missing dependency: com.greensock." + p);
        }
        _tickerActive = !1;
    }
}("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax");